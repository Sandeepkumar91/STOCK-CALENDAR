{"ast":null,"code":"/*\n Highcharts JS v7.0.3 (2019-02-06)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (N, I) {\n  \"object\" === typeof module && module.exports ? (I[\"default\"] = I, module.exports = N.document ? I(N) : I) : \"function\" === typeof define && define.amd ? define(function () {\n    return I(N);\n  }) : N.Highcharts = I(N);\n})(\"undefined\" !== typeof window ? window : this, function (N) {\n  var I = function () {\n    var a = \"undefined\" === typeof N ? \"undefined\" !== typeof window ? window : {} : N,\n        y = a.document,\n        F = a.navigator && a.navigator.userAgent || \"\",\n        G = y && y.createElementNS && !!y.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        k = /(edge|msie|trident)/i.test(F) && !a.opera,\n        c = -1 !== F.indexOf(\"Firefox\"),\n        p = -1 !== F.indexOf(\"Chrome\"),\n        t = c && 4 > parseInt(F.split(\"Firefox/\")[1], 10);\n    return a.Highcharts ? a.Highcharts.error(16, !0) : {\n      product: \"Highcharts\",\n      version: \"7.0.3\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: y,\n      hasBidiBug: t,\n      hasTouch: y && void 0 !== y.documentElement.ontouchstart,\n      isMS: k,\n      isWebKit: -1 !== F.indexOf(\"AppleWebKit\"),\n      isFirefox: c,\n      isChrome: p,\n      isSafari: !p && -1 !== F.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(F),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: G,\n      win: a,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function noop() {},\n      charts: []\n    };\n  }();\n\n  (function (a) {\n    a.timers = [];\n    var y = a.charts,\n        F = a.doc,\n        G = a.win;\n\n    a.error = function (k, c, p) {\n      var t = a.isNumber(k) ? \"Highcharts error #\" + k + \": www.highcharts.com/errors/\" + k : k;\n      p && a.fireEvent(p, \"displayError\", {\n        code: k\n      });\n      if (c) throw Error(t);\n      G.console && console.log(t);\n    };\n\n    a.Fx = function (a, c, p) {\n      this.options = c;\n      this.elem = a;\n      this.prop = p;\n    };\n\n    a.Fx.prototype = {\n      dSetter: function dSetter() {\n        var a = this.paths[0],\n            c = this.paths[1],\n            p = [],\n            t = this.now,\n            v = a.length,\n            w;\n        if (1 === t) p = this.toD;else if (v === c.length && 1 > t) for (; v--;) {\n          w = parseFloat(a[v]), p[v] = isNaN(w) ? c[v] : t * parseFloat(c[v] - w) + w;\n        } else p = c;\n        this.elem.attr(\"d\", p, null, !0);\n      },\n      update: function update() {\n        var a = this.elem,\n            c = this.prop,\n            p = this.now,\n            t = this.options.step;\n        if (this[c + \"Setter\"]) this[c + \"Setter\"]();else a.attr ? a.element && a.attr(c, p, null, !0) : a.style[c] = p + this.unit;\n        t && t.call(a, p, this);\n      },\n      run: function run(k, c, p) {\n        var t = this,\n            v = t.options,\n            w = function w(a) {\n          return w.stopped ? !1 : t.step(a);\n        },\n            r = G.requestAnimationFrame || function (a) {\n          setTimeout(a, 13);\n        },\n            h = function h() {\n          for (var e = 0; e < a.timers.length; e++) {\n            a.timers[e]() || a.timers.splice(e--, 1);\n          }\n\n          a.timers.length && r(h);\n        };\n\n        k !== c || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = k, this.end = c, this.unit = p, this.now = this.start, this.pos = 0, w.elem = this.elem, w.prop = this.prop, w() && 1 === a.timers.push(w) && r(h)) : (delete v.curAnim[this.prop], v.complete && 0 === Object.keys(v.curAnim).length && v.complete.call(this.elem));\n      },\n      step: function step(k) {\n        var c = +new Date(),\n            p,\n            t = this.options,\n            v = this.elem,\n            w = t.complete,\n            r = t.duration,\n            h = t.curAnim;\n        v.attr && !v.element ? k = !1 : k || c >= r + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), p = h[this.prop] = !0, a.objectEach(h, function (a) {\n          !0 !== a && (p = !1);\n        }), p && w && w.call(v), k = !1) : (this.pos = t.easing((c - this.startTime) / r), this.now = this.start + (this.end - this.start) * this.pos, this.update(), k = !0);\n        return k;\n      },\n      initPath: function initPath(k, c, p) {\n        function t(a) {\n          var d, g;\n\n          for (b = a.length; b--;) {\n            d = \"M\" === a[b] || \"L\" === a[b], g = /[a-zA-Z]/.test(a[b + 3]), d && g && a.splice(b + 1, 0, a[b + 1], a[b + 2], a[b + 1], a[b + 2]);\n          }\n        }\n\n        function v(a, g) {\n          for (; a.length < d;) {\n            a[0] = g[d - a.length];\n            var e = a.slice(0, n);\n            [].splice.apply(a, [0, 0].concat(e));\n            x && (e = a.slice(a.length - n), [].splice.apply(a, [a.length, 0].concat(e)), b--);\n          }\n\n          a[0] = \"M\";\n        }\n\n        function w(a, b) {\n          for (var e = (d - a.length) / n; 0 < e && e--;) {\n            g = a.slice().splice(a.length / u - n, n * u), g[0] = b[d - n - e * n], l && (g[n - 6] = g[n - 2], g[n - 5] = g[n - 1]), [].splice.apply(a, [a.length / u, 0].concat(g)), x && e--;\n          }\n        }\n\n        c = c || \"\";\n        var r,\n            h = k.startX,\n            e = k.endX,\n            l = -1 < c.indexOf(\"C\"),\n            n = l ? 7 : 3,\n            d,\n            g,\n            b;\n        c = c.split(\" \");\n        p = p.slice();\n        var x = k.isArea,\n            u = x ? 2 : 1,\n            H;\n        l && (t(c), t(p));\n\n        if (h && e) {\n          for (b = 0; b < h.length; b++) {\n            if (h[b] === e[0]) {\n              r = b;\n              break;\n            } else if (h[0] === e[e.length - h.length + b]) {\n              r = b;\n              H = !0;\n              break;\n            }\n          }\n\n          void 0 === r && (c = []);\n        }\n\n        c.length && a.isNumber(r) && (d = p.length + r * u * n, H ? (v(c, p), w(p, c)) : (v(p, c), w(c, p)));\n        return [c, p];\n      },\n      fillSetter: function fillSetter() {\n        a.Fx.prototype.strokeSetter.apply(this, arguments);\n      },\n      strokeSetter: function strokeSetter() {\n        this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0);\n      }\n    };\n\n    a.merge = function () {\n      var k,\n          c = arguments,\n          p,\n          t = {},\n          v = function v(c, r) {\n        \"object\" !== typeof c && (c = {});\n        a.objectEach(r, function (h, e) {\n          !a.isObject(h, !0) || a.isClass(h) || a.isDOMElement(h) ? c[e] = r[e] : c[e] = v(c[e] || {}, h);\n        });\n        return c;\n      };\n\n      !0 === c[0] && (t = c[1], c = Array.prototype.slice.call(c, 2));\n      p = c.length;\n\n      for (k = 0; k < p; k++) {\n        t = v(t, c[k]);\n      }\n\n      return t;\n    };\n\n    a.pInt = function (a, c) {\n      return parseInt(a, c || 10);\n    };\n\n    a.isString = function (a) {\n      return \"string\" === typeof a;\n    };\n\n    a.isArray = function (a) {\n      a = Object.prototype.toString.call(a);\n      return \"[object Array]\" === a || \"[object Array Iterator]\" === a;\n    };\n\n    a.isObject = function (k, c) {\n      return !!k && \"object\" === typeof k && (!c || !a.isArray(k));\n    };\n\n    a.isDOMElement = function (k) {\n      return a.isObject(k) && \"number\" === typeof k.nodeType;\n    };\n\n    a.isClass = function (k) {\n      var c = k && k.constructor;\n      return !(!a.isObject(k, !0) || a.isDOMElement(k) || !c || !c.name || \"Object\" === c.name);\n    };\n\n    a.isNumber = function (a) {\n      return \"number\" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;\n    };\n\n    a.erase = function (a, c) {\n      for (var k = a.length; k--;) {\n        if (a[k] === c) {\n          a.splice(k, 1);\n          break;\n        }\n      }\n    };\n\n    a.defined = function (a) {\n      return void 0 !== a && null !== a;\n    };\n\n    a.attr = function (k, c, p) {\n      var t;\n      a.isString(c) ? a.defined(p) ? k.setAttribute(c, p) : k && k.getAttribute && ((t = k.getAttribute(c)) || \"class\" !== c || (t = k.getAttribute(c + \"Name\"))) : a.defined(c) && a.isObject(c) && a.objectEach(c, function (a, c) {\n        k.setAttribute(c, a);\n      });\n      return t;\n    };\n\n    a.splat = function (k) {\n      return a.isArray(k) ? k : [k];\n    };\n\n    a.syncTimeout = function (a, c, p) {\n      if (c) return setTimeout(a, c, p);\n      a.call(0, p);\n    };\n\n    a.clearTimeout = function (k) {\n      a.defined(k) && clearTimeout(k);\n    };\n\n    a.extend = function (a, c) {\n      var k;\n      a || (a = {});\n\n      for (k in c) {\n        a[k] = c[k];\n      }\n\n      return a;\n    };\n\n    a.pick = function () {\n      var a = arguments,\n          c,\n          p,\n          t = a.length;\n\n      for (c = 0; c < t; c++) {\n        if (p = a[c], void 0 !== p && null !== p) return p;\n      }\n    };\n\n    a.css = function (k, c) {\n      a.isMS && !a.svg && c && void 0 !== c.opacity && (c.filter = \"alpha(opacity\\x3d\" + 100 * c.opacity + \")\");\n      a.extend(k.style, c);\n    };\n\n    a.createElement = function (k, c, p, t, v) {\n      k = F.createElement(k);\n      var w = a.css;\n      c && a.extend(k, c);\n      v && w(k, {\n        padding: 0,\n        border: \"none\",\n        margin: 0\n      });\n      p && w(k, p);\n      t && t.appendChild(k);\n      return k;\n    };\n\n    a.extendClass = function (k, c) {\n      var p = function p() {};\n\n      p.prototype = new k();\n      a.extend(p.prototype, c);\n      return p;\n    };\n\n    a.pad = function (a, c, p) {\n      return Array((c || 2) + 1 - String(a).replace(\"-\", \"\").length).join(p || 0) + a;\n    };\n\n    a.relativeLength = function (a, c, p) {\n      return /%$/.test(a) ? c * parseFloat(a) / 100 + (p || 0) : parseFloat(a);\n    };\n\n    a.wrap = function (a, c, p) {\n      var k = a[c];\n\n      a[c] = function () {\n        var a = Array.prototype.slice.call(arguments),\n            c = arguments,\n            r = this;\n\n        r.proceed = function () {\n          k.apply(r, arguments.length ? arguments : c);\n        };\n\n        a.unshift(k);\n        a = p.apply(this, a);\n        r.proceed = null;\n        return a;\n      };\n    };\n\n    a.datePropsToTimestamps = function (k) {\n      a.objectEach(k, function (c, p) {\n        a.isObject(c) && \"function\" === typeof c.getTime ? k[p] = c.getTime() : (a.isObject(c) || a.isArray(c)) && a.datePropsToTimestamps(c);\n      });\n    };\n\n    a.formatSingle = function (k, c, p) {\n      var t = /\\.([0-9])/,\n          v = a.defaultOptions.lang;\n      /f$/.test(k) ? (p = (p = k.match(t)) ? p[1] : -1, null !== c && (c = a.numberFormat(c, p, v.decimalPoint, -1 < k.indexOf(\",\") ? v.thousandsSep : \"\"))) : c = (p || a.time).dateFormat(k, c);\n      return c;\n    };\n\n    a.format = function (k, c, p) {\n      for (var t = \"{\", v = !1, w, r, h, e, l = [], n; k;) {\n        t = k.indexOf(t);\n        if (-1 === t) break;\n        w = k.slice(0, t);\n\n        if (v) {\n          w = w.split(\":\");\n          r = w.shift().split(\".\");\n          e = r.length;\n          n = c;\n\n          for (h = 0; h < e; h++) {\n            n && (n = n[r[h]]);\n          }\n\n          w.length && (n = a.formatSingle(w.join(\":\"), n, p));\n          l.push(n);\n        } else l.push(w);\n\n        k = k.slice(t + 1);\n        t = (v = !v) ? \"}\" : \"{\";\n      }\n\n      l.push(k);\n      return l.join(\"\");\n    };\n\n    a.getMagnitude = function (a) {\n      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));\n    };\n\n    a.normalizeTickInterval = function (k, c, p, t, v) {\n      var w,\n          r = k;\n      p = a.pick(p, 1);\n      w = k / p;\n      c || (c = v ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === t && (1 === p ? c = c.filter(function (a) {\n        return 0 === a % 1;\n      }) : .1 >= p && (c = [1 / p])));\n\n      for (t = 0; t < c.length && !(r = c[t], v && r * p >= k || !v && w <= (c[t] + (c[t + 1] || c[t])) / 2); t++) {\n        ;\n      }\n\n      return r = a.correctFloat(r * p, -Math.round(Math.log(.001) / Math.LN10));\n    };\n\n    a.stableSort = function (a, c) {\n      var k = a.length,\n          t,\n          v;\n\n      for (v = 0; v < k; v++) {\n        a[v].safeI = v;\n      }\n\n      a.sort(function (a, r) {\n        t = c(a, r);\n        return 0 === t ? a.safeI - r.safeI : t;\n      });\n\n      for (v = 0; v < k; v++) {\n        delete a[v].safeI;\n      }\n    };\n\n    a.arrayMin = function (a) {\n      for (var c = a.length, k = a[0]; c--;) {\n        a[c] < k && (k = a[c]);\n      }\n\n      return k;\n    };\n\n    a.arrayMax = function (a) {\n      for (var c = a.length, k = a[0]; c--;) {\n        a[c] > k && (k = a[c]);\n      }\n\n      return k;\n    };\n\n    a.destroyObjectProperties = function (k, c) {\n      a.objectEach(k, function (a, t) {\n        a && a !== c && a.destroy && a.destroy();\n        delete k[t];\n      });\n    };\n\n    a.discardElement = function (k) {\n      var c = a.garbageBin;\n      c || (c = a.createElement(\"div\"));\n      k && c.appendChild(k);\n      c.innerHTML = \"\";\n    };\n\n    a.correctFloat = function (a, c) {\n      return parseFloat(a.toPrecision(c || 14));\n    };\n\n    a.setAnimation = function (k, c) {\n      c.renderer.globalAnimation = a.pick(k, c.options.chart.animation, !0);\n    };\n\n    a.animObject = function (k) {\n      return a.isObject(k) ? a.merge(k) : {\n        duration: k ? 500 : 0\n      };\n    };\n\n    a.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    };\n\n    a.numberFormat = function (k, c, p, t) {\n      k = +k || 0;\n      c = +c;\n      var v = a.defaultOptions.lang,\n          w = (k.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          r,\n          h,\n          e = k.toString().split(\"e\");\n      -1 === c ? c = Math.min(w, 20) : a.isNumber(c) ? c && e[1] && 0 > e[1] && (r = c + +e[1], 0 <= r ? (e[0] = (+e[0]).toExponential(r).split(\"e\")[0], c = r) : (e[0] = e[0].split(\".\")[0] || 0, k = 20 > c ? (e[0] * Math.pow(10, e[1])).toFixed(c) : 0, e[1] = 0)) : c = 2;\n      h = (Math.abs(e[1] ? e[0] : k) + Math.pow(10, -Math.max(c, w) - 1)).toFixed(c);\n      w = String(a.pInt(h));\n      r = 3 < w.length ? w.length % 3 : 0;\n      p = a.pick(p, v.decimalPoint);\n      t = a.pick(t, v.thousandsSep);\n      k = (0 > k ? \"-\" : \"\") + (r ? w.substr(0, r) + t : \"\");\n      k += w.substr(r).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t);\n      c && (k += p + h.slice(-c));\n      e[1] && 0 !== +k && (k += \"e\" + e[1]);\n      return k;\n    };\n\n    Math.easeInOutSine = function (a) {\n      return -.5 * (Math.cos(Math.PI * a) - 1);\n    };\n\n    a.getStyle = function (k, c, p) {\n      if (\"width\" === c) return Math.max(0, Math.min(k.offsetWidth, k.scrollWidth, k.getBoundingClientRect && \"none\" === a.getStyle(k, \"transform\", !1) ? Math.floor(k.getBoundingClientRect().width) : Infinity) - a.getStyle(k, \"padding-left\") - a.getStyle(k, \"padding-right\"));\n      if (\"height\" === c) return Math.max(0, Math.min(k.offsetHeight, k.scrollHeight) - a.getStyle(k, \"padding-top\") - a.getStyle(k, \"padding-bottom\"));\n      G.getComputedStyle || a.error(27, !0);\n      if (k = G.getComputedStyle(k, void 0)) k = k.getPropertyValue(c), a.pick(p, \"opacity\" !== c) && (k = a.pInt(k));\n      return k;\n    };\n\n    a.inArray = function (a, c, p) {\n      return c.indexOf(a, p);\n    };\n\n    a.find = Array.prototype.find ? function (a, c) {\n      return a.find(c);\n    } : function (a, c) {\n      var k,\n          t = a.length;\n\n      for (k = 0; k < t; k++) {\n        if (c(a[k], k)) return a[k];\n      }\n    };\n    a.keys = Object.keys;\n\n    a.offset = function (a) {\n      var c = F.documentElement;\n      a = a.parentElement || a.parentNode ? a.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: a.top + (G.pageYOffset || c.scrollTop) - (c.clientTop || 0),\n        left: a.left + (G.pageXOffset || c.scrollLeft) - (c.clientLeft || 0)\n      };\n    };\n\n    a.stop = function (k, c) {\n      for (var p = a.timers.length; p--;) {\n        a.timers[p].elem !== k || c && c !== a.timers[p].prop || (a.timers[p].stopped = !0);\n      }\n    };\n\n    a.objectEach = function (a, c, p) {\n      for (var k in a) {\n        a.hasOwnProperty(k) && c.call(p || a[k], a[k], k, a);\n      }\n    };\n\n    a.objectEach({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (k, c) {\n      a[c] = function (a) {\n        return Array.prototype[k].apply(a, [].slice.call(arguments, 1));\n      };\n    });\n\n    a.addEvent = function (k, c, p, t) {\n      var v,\n          w = k.addEventListener || a.addEventListenerPolyfill;\n      v = \"function\" === typeof k && k.prototype ? k.prototype.protoEvents = k.prototype.protoEvents || {} : k.hcEvents = k.hcEvents || {};\n      a.Point && k instanceof a.Point && k.series && k.series.chart && (k.series.chart.runTrackerClick = !0);\n      w && w.call(k, c, p, !1);\n      v[c] || (v[c] = []);\n      v[c].push(p);\n      t && a.isNumber(t.order) && (p.order = t.order, v[c].sort(function (a, h) {\n        return a.order - h.order;\n      }));\n      return function () {\n        a.removeEvent(k, c, p);\n      };\n    };\n\n    a.removeEvent = function (k, c, p) {\n      function t(h, e) {\n        var l = k.removeEventListener || a.removeEventListenerPolyfill;\n        l && l.call(k, h, e, !1);\n      }\n\n      function v(h) {\n        var e, l;\n        k.nodeName && (c ? (e = {}, e[c] = !0) : e = h, a.objectEach(e, function (a, d) {\n          if (h[d]) for (l = h[d].length; l--;) {\n            t(d, h[d][l]);\n          }\n        }));\n      }\n\n      var w, r;\n      [\"protoEvents\", \"hcEvents\"].forEach(function (a) {\n        var e = k[a];\n        e && (c ? (w = e[c] || [], p ? (r = w.indexOf(p), -1 < r && (w.splice(r, 1), e[c] = w), t(c, p)) : (v(e), e[c] = [])) : (v(e), k[a] = {}));\n      });\n    };\n\n    a.fireEvent = function (k, c, p, t) {\n      var v, w, r, h, e;\n      p = p || {};\n      F.createEvent && (k.dispatchEvent || k.fireEvent) ? (v = F.createEvent(\"Events\"), v.initEvent(c, !0, !0), a.extend(v, p), k.dispatchEvent ? k.dispatchEvent(v) : k.fireEvent(c, v)) : [\"protoEvents\", \"hcEvents\"].forEach(function (l) {\n        if (k[l]) for (w = k[l][c] || [], r = w.length, p.target || a.extend(p, {\n          preventDefault: function preventDefault() {\n            p.defaultPrevented = !0;\n          },\n          target: k,\n          type: c\n        }), h = 0; h < r; h++) {\n          (e = w[h]) && !1 === e.call(k, p) && p.preventDefault();\n        }\n      });\n      t && !p.defaultPrevented && t.call(k, p);\n    };\n\n    a.animate = function (k, c, p) {\n      var t,\n          v = \"\",\n          w,\n          r,\n          h;\n      a.isObject(p) || (h = arguments, p = {\n        duration: h[2],\n        easing: h[3],\n        complete: h[4]\n      });\n      a.isNumber(p.duration) || (p.duration = 400);\n      p.easing = \"function\" === typeof p.easing ? p.easing : Math[p.easing] || Math.easeInOutSine;\n      p.curAnim = a.merge(c);\n      a.objectEach(c, function (e, h) {\n        a.stop(k, h);\n        r = new a.Fx(k, p, h);\n        w = null;\n        \"d\" === h ? (r.paths = r.initPath(k, k.d, c.d), r.toD = c.d, t = 0, w = 1) : k.attr ? t = k.attr(h) : (t = parseFloat(a.getStyle(k, h)) || 0, \"opacity\" !== h && (v = \"px\"));\n        w || (w = e);\n        w && w.match && w.match(\"px\") && (w = w.replace(/px/g, \"\"));\n        r.run(t, w, v);\n      });\n    };\n\n    a.seriesType = function (k, c, p, t, v) {\n      var w = a.getOptions(),\n          r = a.seriesTypes;\n      w.plotOptions[k] = a.merge(w.plotOptions[c], p);\n      r[k] = a.extendClass(r[c] || function () {}, t);\n      r[k].prototype.type = k;\n      v && (r[k].prototype.pointClass = a.extendClass(a.Point, v));\n      return r[k];\n    };\n\n    a.uniqueKey = function () {\n      var a = Math.random().toString(36).substring(2, 9),\n          c = 0;\n      return function () {\n        return \"highcharts-\" + a + \"-\" + c++;\n      };\n    }();\n\n    a.isFunction = function (a) {\n      return \"function\" === typeof a;\n    };\n\n    G.jQuery && (G.jQuery.fn.highcharts = function () {\n      var k = [].slice.call(arguments);\n      if (this[0]) return k[0] ? (new a[a.isString(k[0]) ? k.shift() : \"Chart\"](this[0], k[0], k[1]), this) : y[a.attr(this[0], \"data-highcharts-chart\")];\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.isNumber,\n        F = a.merge,\n        G = a.pInt;\n\n    a.Color = function (k) {\n      if (!(this instanceof a.Color)) return new a.Color(k);\n      this.init(k);\n    };\n\n    a.Color.prototype = {\n      parsers: [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function parse(a) {\n          return [G(a[1]), G(a[2]), G(a[3]), parseFloat(a[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function parse(a) {\n          return [G(a[1]), G(a[2]), G(a[3]), 1];\n        }\n      }],\n      names: {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      },\n      init: function init(k) {\n        var c, p, t, v;\n        if ((this.input = k = this.names[k && k.toLowerCase ? k.toLowerCase() : \"\"] || k) && k.stops) this.stops = k.stops.map(function (c) {\n          return new a.Color(c[1]);\n        });else if (k && k.charAt && \"#\" === k.charAt() && (c = k.length, k = parseInt(k.substr(1), 16), 7 === c ? p = [(k & 16711680) >> 16, (k & 65280) >> 8, k & 255, 1] : 4 === c && (p = [(k & 3840) >> 4 | (k & 3840) >> 8, (k & 240) >> 4 | k & 240, (k & 15) << 4 | k & 15, 1])), !p) for (t = this.parsers.length; t-- && !p;) {\n          v = this.parsers[t], (c = v.regex.exec(k)) && (p = v.parse(c));\n        }\n        this.rgba = p || [];\n      },\n      get: function get(a) {\n        var c = this.input,\n            k = this.rgba,\n            t;\n        this.stops ? (t = F(c), t.stops = [].concat(t.stops), this.stops.forEach(function (c, k) {\n          t.stops[k] = [t.stops[k][0], c.get(a)];\n        })) : t = k && y(k[0]) ? \"rgb\" === a || !a && 1 === k[3] ? \"rgb(\" + k[0] + \",\" + k[1] + \",\" + k[2] + \")\" : \"a\" === a ? k[3] : \"rgba(\" + k.join(\",\") + \")\" : c;\n        return t;\n      },\n      brighten: function brighten(a) {\n        var c,\n            k = this.rgba;\n        if (this.stops) this.stops.forEach(function (c) {\n          c.brighten(a);\n        });else if (y(a) && 0 !== a) for (c = 0; 3 > c; c++) {\n          k[c] += G(255 * a), 0 > k[c] && (k[c] = 0), 255 < k[c] && (k[c] = 255);\n        }\n        return this;\n      },\n      setOpacity: function setOpacity(a) {\n        this.rgba[3] = a;\n        return this;\n      },\n      tweenTo: function tweenTo(a, c) {\n        var k = this.rgba,\n            t = a.rgba;\n        t.length && k && k.length ? (a = 1 !== t[3] || 1 !== k[3], c = (a ? \"rgba(\" : \"rgb(\") + Math.round(t[0] + (k[0] - t[0]) * (1 - c)) + \",\" + Math.round(t[1] + (k[1] - t[1]) * (1 - c)) + \",\" + Math.round(t[2] + (k[2] - t[2]) * (1 - c)) + (a ? \",\" + (t[3] + (k[3] - t[3]) * (1 - c)) : \"\") + \")\") : c = a.input || \"none\";\n        return c;\n      }\n    };\n\n    a.color = function (k) {\n      return new a.Color(k);\n    };\n  })(I);\n\n  (function (a) {\n    var y,\n        F,\n        G = a.addEvent,\n        k = a.animate,\n        c = a.attr,\n        p = a.charts,\n        t = a.color,\n        v = a.css,\n        w = a.createElement,\n        r = a.defined,\n        h = a.deg2rad,\n        e = a.destroyObjectProperties,\n        l = a.doc,\n        n = a.extend,\n        d = a.erase,\n        g = a.hasTouch,\n        b = a.isArray,\n        x = a.isFirefox,\n        u = a.isMS,\n        H = a.isObject,\n        E = a.isString,\n        B = a.isWebKit,\n        m = a.merge,\n        z = a.noop,\n        D = a.objectEach,\n        A = a.pick,\n        f = a.pInt,\n        q = a.removeEvent,\n        L = a.splat,\n        K = a.stop,\n        T = a.svg,\n        J = a.SVG_NS,\n        M = a.symbolSizes,\n        R = a.win;\n\n    y = a.SVGElement = function () {\n      return this;\n    };\n\n    n(y.prototype, {\n      opacity: 1,\n      SVG_NS: J,\n      textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor\".split(\" \"),\n      init: function init(f, q) {\n        this.element = \"span\" === q ? w(q) : l.createElementNS(this.SVG_NS, q);\n        this.renderer = f;\n        a.fireEvent(this, \"afterInit\");\n      },\n      animate: function animate(f, q, d) {\n        var C = a.animObject(A(q, this.renderer.globalAnimation, !0));\n        A(l.hidden, l.msHidden, l.webkitHidden, !1) && (C.duration = 0);\n        0 !== C.duration ? (d && (C.complete = d), k(this, f, C)) : (this.attr(f, null, d), a.objectEach(f, function (a, f) {\n          C.step && C.step.call(this, a, {\n            prop: f,\n            pos: 1\n          });\n        }, this));\n        return this;\n      },\n      complexColor: function complexColor(f, q, d) {\n        var C = this.renderer,\n            g,\n            e,\n            n,\n            h,\n            J,\n            z,\n            l,\n            P,\n            x,\n            c,\n            u,\n            K = [],\n            L;\n        a.fireEvent(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          f.radialGradient ? e = \"radialGradient\" : f.linearGradient && (e = \"linearGradient\");\n          e && (n = f[e], J = C.gradients, l = f.stops, c = d.radialReference, b(n) && (f[e] = n = {\n            x1: n[0],\n            y1: n[1],\n            x2: n[2],\n            y2: n[3],\n            gradientUnits: \"userSpaceOnUse\"\n          }), \"radialGradient\" === e && c && !r(n.gradientUnits) && (h = n, n = m(n, C.getRadialAttr(c, h), {\n            gradientUnits: \"userSpaceOnUse\"\n          })), D(n, function (a, f) {\n            \"id\" !== f && K.push(f, a);\n          }), D(l, function (a) {\n            K.push(a);\n          }), K = K.join(\",\"), J[K] ? u = J[K].attr(\"id\") : (n.id = u = a.uniqueKey(), J[K] = z = C.createElement(e).attr(n).add(C.defs), z.radAttr = h, z.stops = [], l.forEach(function (f) {\n            0 === f[1].indexOf(\"rgba\") ? (g = a.color(f[1]), P = g.get(\"rgb\"), x = g.get(\"a\")) : (P = f[1], x = 1);\n            f = C.createElement(\"stop\").attr({\n              offset: f[0],\n              \"stop-color\": P,\n              \"stop-opacity\": x\n            }).add(z);\n            z.stops.push(f);\n          })), L = \"url(\" + C.url + \"#\" + u + \")\", d.setAttribute(q, L), d.gradient = K, f.toString = function () {\n            return L;\n          });\n        });\n      },\n      applyTextOutline: function applyTextOutline(f) {\n        var C = this.element,\n            q,\n            b,\n            g,\n            e,\n            m;\n        -1 !== f.indexOf(\"contrast\") && (f = f.replace(/contrast/g, this.renderer.getContrast(C.style.fill)));\n        f = f.split(\" \");\n        b = f[f.length - 1];\n\n        if ((g = f[0]) && \"none\" !== g && a.svg) {\n          this.fakeTS = !0;\n          f = [].slice.call(C.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          g = g.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, f, C) {\n            return 2 * f + C;\n          });\n\n          for (m = f.length; m--;) {\n            q = f[m], \"highcharts-text-outline\" === q.getAttribute(\"class\") && d(f, C.removeChild(q));\n          }\n\n          e = C.firstChild;\n          f.forEach(function (a, f) {\n            0 === f && (a.setAttribute(\"x\", C.getAttribute(\"x\")), f = C.getAttribute(\"y\"), a.setAttribute(\"y\", f || 0), null === f && C.setAttribute(\"y\", 0));\n            a = a.cloneNode(1);\n            c(a, {\n              \"class\": \"highcharts-text-outline\",\n              fill: b,\n              stroke: b,\n              \"stroke-width\": g,\n              \"stroke-linejoin\": \"round\"\n            });\n            C.insertBefore(a, e);\n          });\n        }\n      },\n      symbolCustomAttribs: \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \"),\n      attr: function attr(f, q, d, b) {\n        var C,\n            g = this.element,\n            e,\n            m = this,\n            n,\n            h,\n            J = this.symbolCustomAttribs;\n        \"string\" === typeof f && void 0 !== q && (C = f, f = {}, f[C] = q);\n        \"string\" === typeof f ? m = (this[f + \"Getter\"] || this._defaultGetter).call(this, f, g) : (D(f, function (C, q) {\n          n = !1;\n          b || K(this, q);\n          this.symbolName && -1 !== a.inArray(q, J) && (e || (this.symbolAttr(f), e = !0), n = !0);\n          !this.rotation || \"x\" !== q && \"y\" !== q || (this.doTransform = !0);\n          n || (h = this[q + \"Setter\"] || this._defaultSetter, h.call(this, C, q, g), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(q) && this.updateShadows(q, C, h));\n        }, this), this.afterSetters());\n        d && d.call(this);\n        return m;\n      },\n      afterSetters: function afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      },\n      updateShadows: function updateShadows(a, f, q) {\n        for (var C = this.shadows, d = C.length; d--;) {\n          q.call(C[d], \"height\" === a ? Math.max(f - (C[d].cutHeight || 0), 0) : \"d\" === a ? this.d : f, a, C[d]);\n        }\n      },\n      addClass: function addClass(a, f) {\n        var C = this.attr(\"class\") || \"\";\n        -1 === C.indexOf(a) && (f || (a = (C + (C ? \" \" : \"\") + a).replace(\"  \", \" \")), this.attr(\"class\", a));\n        return this;\n      },\n      hasClass: function hasClass(a) {\n        return -1 !== (this.attr(\"class\") || \"\").split(\" \").indexOf(a);\n      },\n      removeClass: function removeClass(a) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(a, \"\"));\n      },\n      symbolAttr: function symbolAttr(a) {\n        var f = this;\n        \"x y r start end width height innerR anchorX anchorY\".split(\" \").forEach(function (C) {\n          f[C] = A(a[C], f[C]);\n        });\n        f.attr({\n          d: f.renderer.symbols[f.symbolName](f.x, f.y, f.width, f.height, f)\n        });\n      },\n      clip: function clip(a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      },\n      crisp: function crisp(a, f) {\n        var C;\n        f = f || a.strokeWidth || 0;\n        C = Math.round(f) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + C;\n        a.y = Math.floor(a.y || this.y || 0) + C;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * C);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * C);\n        r(a.strokeWidth) && (a.strokeWidth = f);\n        return a;\n      },\n      css: function css(a) {\n        var C = this.styles,\n            q = {},\n            d = this.element,\n            b,\n            g = \"\",\n            e,\n            m = !C,\n            h = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        C && D(a, function (a, f) {\n          a !== C[f] && (q[f] = a, m = !0);\n        });\n        m && (C && (a = n(C, q)), a && (null === a.width || \"auto\" === a.width ? delete this.textWidth : \"text\" === d.nodeName.toLowerCase() && a.width && (b = this.textWidth = f(a.width))), this.styles = a, b && !T && this.renderer.forExport && delete a.width, d.namespaceURI === this.SVG_NS ? (e = function e(a, f) {\n          return \"-\" + f.toLowerCase();\n        }, D(a, function (a, f) {\n          -1 === h.indexOf(f) && (g += f.replace(/([A-Z])/g, e) + \":\" + a + \";\");\n        }), g && c(d, \"style\", g)) : v(d, a), this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline)));\n        return this;\n      },\n      getStyle: function getStyle(a) {\n        return R.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      },\n      strokeWidth: function strokeWidth() {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\"),\n            q;\n        a.indexOf(\"px\") === a.length - 2 ? a = f(a) : (q = l.createElementNS(J, \"rect\"), c(q, {\n          width: a,\n          \"stroke-width\": 0\n        }), this.element.parentNode.appendChild(q), a = q.getBBox().width, q.parentNode.removeChild(q));\n        return a;\n      },\n      on: function on(a, f) {\n        var C = this,\n            q = C.element;\n        g && \"click\" === a ? (q.ontouchstart = function (a) {\n          C.touchEventFired = Date.now();\n          a.preventDefault();\n          f.call(q, a);\n        }, q.onclick = function (a) {\n          (-1 === R.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (C.touchEventFired || 0)) && f.call(q, a);\n        }) : q[\"on\" + a] = f;\n        return this;\n      },\n      setRadialReference: function setRadialReference(a) {\n        var f = this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        f && f.radAttr && f.animate(this.renderer.getRadialAttr(a, f.radAttr));\n        return this;\n      },\n      translate: function translate(a, f) {\n        return this.attr({\n          translateX: a,\n          translateY: f\n        });\n      },\n      invert: function invert(a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      },\n      updateTransform: function updateTransform() {\n        var a = this.translateX || 0,\n            f = this.translateY || 0,\n            q = this.scaleX,\n            d = this.scaleY,\n            b = this.inverted,\n            g = this.rotation,\n            e = this.matrix,\n            m = this.element;\n        b && (a += this.width, f += this.height);\n        a = [\"translate(\" + a + \",\" + f + \")\"];\n        r(e) && a.push(\"matrix(\" + e.join(\",\") + \")\");\n        b ? a.push(\"rotate(90) scale(-1,1)\") : g && a.push(\"rotate(\" + g + \" \" + A(this.rotationOriginX, m.getAttribute(\"x\"), 0) + \" \" + A(this.rotationOriginY, m.getAttribute(\"y\") || 0) + \")\");\n        (r(q) || r(d)) && a.push(\"scale(\" + A(q, 1) + \" \" + A(d, 1) + \")\");\n        a.length && m.setAttribute(\"transform\", a.join(\" \"));\n      },\n      toFront: function toFront() {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      },\n      align: function align(a, f, q) {\n        var C,\n            b,\n            g,\n            e,\n            m = {};\n        b = this.renderer;\n        g = b.alignedObjects;\n        var n, h;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = f, !q || E(q)) this.alignTo = C = q || \"renderer\", d(g, this), g.push(this), q = null;\n        } else a = this.alignOptions, f = this.alignByTranslate, C = this.alignTo;\n\n        q = A(q, b[C], b);\n        C = a.align;\n        b = a.verticalAlign;\n        g = (q.x || 0) + (a.x || 0);\n        e = (q.y || 0) + (a.y || 0);\n        \"right\" === C ? n = 1 : \"center\" === C && (n = 2);\n        n && (g += (q.width - (a.width || 0)) / n);\n        m[f ? \"translateX\" : \"x\"] = Math.round(g);\n        \"bottom\" === b ? h = 1 : \"middle\" === b && (h = 2);\n        h && (e += (q.height - (a.height || 0)) / h);\n        m[f ? \"translateY\" : \"y\"] = Math.round(e);\n        this[this.placed ? \"animate\" : \"attr\"](m);\n        this.placed = !0;\n        this.alignAttr = m;\n        return this;\n      },\n      getBBox: function getBBox(a, f) {\n        var q,\n            C = this.renderer,\n            d,\n            b = this.element,\n            g = this.styles,\n            e,\n            m = this.textStr,\n            J,\n            z = C.cache,\n            l = C.cacheKeys,\n            x = b.namespaceURI === this.SVG_NS,\n            c;\n        f = A(f, this.rotation);\n        d = f * h;\n        e = C.styledMode ? b && y.prototype.getStyle.call(b, \"font-size\") : g && g.fontSize;\n        r(m) && (c = m.toString(), -1 === c.indexOf(\"\\x3c\") && (c = c.replace(/[0-9]/g, \"0\")), c += [\"\", f || 0, e, this.textWidth, g && g.textOverflow].join());\n        c && !a && (q = z[c]);\n\n        if (!q) {\n          if (x || C.forExport) {\n            try {\n              (J = this.fakeTS && function (a) {\n                [].forEach.call(b.querySelectorAll(\".highcharts-text-outline\"), function (f) {\n                  f.style.display = a;\n                });\n              }) && J(\"none\"), q = b.getBBox ? n({}, b.getBBox()) : {\n                width: b.offsetWidth,\n                height: b.offsetHeight\n              }, J && J(\"\");\n            } catch (Y) {}\n\n            if (!q || 0 > q.width) q = {\n              width: 0,\n              height: 0\n            };\n          } else q = this.htmlGetBBox();\n\n          C.isSVG && (a = q.width, C = q.height, x && (q.height = C = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[g && g.fontSize + \",\" + Math.round(C)] || C), f && (q.width = Math.abs(C * Math.sin(d)) + Math.abs(a * Math.cos(d)), q.height = Math.abs(C * Math.cos(d)) + Math.abs(a * Math.sin(d))));\n\n          if (c && 0 < q.height) {\n            for (; 250 < l.length;) {\n              delete z[l.shift()];\n            }\n\n            z[c] || l.push(c);\n            z[c] = q;\n          }\n        }\n\n        return q;\n      },\n      show: function show(a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      },\n      hide: function hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      },\n      fadeOut: function fadeOut(a) {\n        var f = this;\n        f.animate({\n          opacity: 0\n        }, {\n          duration: a || 150,\n          complete: function complete() {\n            f.attr({\n              y: -9999\n            });\n          }\n        });\n      },\n      add: function add(a) {\n        var f = this.renderer,\n            q = this.element,\n            C;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        void 0 !== this.textStr && f.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) C = this.zIndexSetter();\n        C || (a ? a.element : f.box).appendChild(q);\n        if (this.onAdd) this.onAdd();\n        return this;\n      },\n      safeRemoveChild: function safeRemoveChild(a) {\n        var f = a.parentNode;\n        f && f.removeChild(a);\n      },\n      destroy: function destroy() {\n        var a = this,\n            f = a.element || {},\n            q = a.renderer,\n            b = q.isSVG && \"SPAN\" === f.nodeName && a.parentGroup,\n            g = f.ownerSVGElement,\n            e = a.clipPath;\n        f.onclick = f.onmouseout = f.onmouseover = f.onmousemove = f.point = null;\n        K(a);\n        e && g && ([].forEach.call(g.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n          var f = a.getAttribute(\"clip-path\"),\n              q = e.element.id;\n          (-1 < f.indexOf(\"(#\" + q + \")\") || -1 < f.indexOf('(\"#' + q + '\")')) && a.removeAttribute(\"clip-path\");\n        }), a.clipPath = e.destroy());\n\n        if (a.stops) {\n          for (g = 0; g < a.stops.length; g++) {\n            a.stops[g] = a.stops[g].destroy();\n          }\n\n          a.stops = null;\n        }\n\n        a.safeRemoveChild(f);\n\n        for (q.styledMode || a.destroyShadows(); b && b.div && 0 === b.div.childNodes.length;) {\n          f = b.parentGroup, a.safeRemoveChild(b.div), delete b.div, b = f;\n        }\n\n        a.alignTo && d(q.alignedObjects, a);\n        D(a, function (f, q) {\n          delete a[q];\n        });\n        return null;\n      },\n      shadow: function shadow(a, f, q) {\n        var d = [],\n            C,\n            b,\n            g = this.element,\n            e,\n            m,\n            n,\n            h;\n        if (!a) this.destroyShadows();else if (!this.shadows) {\n          m = A(a.width, 3);\n          n = (a.opacity || .15) / m;\n          h = this.parentInverted ? \"(-1,-1)\" : \"(\" + A(a.offsetX, 1) + \", \" + A(a.offsetY, 1) + \")\";\n\n          for (C = 1; C <= m; C++) {\n            b = g.cloneNode(0), e = 2 * m + 1 - 2 * C, c(b, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": n * C,\n              \"stroke-width\": e,\n              transform: \"translate\" + h,\n              fill: \"none\"\n            }), b.setAttribute(\"class\", (b.getAttribute(\"class\") || \"\") + \" highcharts-shadow\"), q && (c(b, \"height\", Math.max(c(b, \"height\") - e, 0)), b.cutHeight = e), f ? f.element.appendChild(b) : g.parentNode && g.parentNode.insertBefore(b, g), d.push(b);\n          }\n\n          this.shadows = d;\n        }\n        return this;\n      },\n      destroyShadows: function destroyShadows() {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      },\n      xGetter: function xGetter(a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      },\n      _defaultGetter: function _defaultGetter(a) {\n        a = A(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      },\n      dSetter: function dSetter(a, f, q) {\n        a && a.join && (a = a.join(\" \"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[f] !== a && (q.setAttribute(f, a), this[f] = a);\n      },\n      dashstyleSetter: function dashstyleSetter(a) {\n        var q,\n            b = this[\"stroke-width\"];\n        \"inherit\" === b && (b = 1);\n\n        if (a = a && a.toLowerCase()) {\n          a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (q = a.length; q--;) {\n            a[q] = f(a[q]) * b;\n          }\n\n          a = a.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      },\n      alignSetter: function alignSetter(a) {\n        var f = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        f[a] && (this.alignValue = a, this.element.setAttribute(\"text-anchor\", f[a]));\n      },\n      opacitySetter: function opacitySetter(a, f, q) {\n        this[f] = a;\n        q.setAttribute(f, a);\n      },\n      titleSetter: function titleSetter(a) {\n        var f = this.element.getElementsByTagName(\"title\")[0];\n        f || (f = l.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(f));\n        f.firstChild && f.removeChild(f.firstChild);\n        f.appendChild(l.createTextNode(String(A(a), \"\").replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\")));\n      },\n      textSetter: function textSetter(a) {\n        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this));\n      },\n      fillSetter: function fillSetter(a, f, q) {\n        \"string\" === typeof a ? q.setAttribute(f, a) : a && this.complexColor(a, f, q);\n      },\n      visibilitySetter: function visibilitySetter(a, f, q) {\n        \"inherit\" === a ? q.removeAttribute(f) : this[f] !== a && q.setAttribute(f, a);\n        this[f] = a;\n      },\n      zIndexSetter: function zIndexSetter(a, q) {\n        var b = this.renderer,\n            d = this.parentGroup,\n            g = (d || b).element || b.box,\n            e,\n            m = this.element,\n            C,\n            n,\n            b = g === b.box;\n        e = this.added;\n        var h;\n        r(a) ? (m.setAttribute(\"data-z-index\", a), a = +a, this[q] === a && (e = !1)) : r(this[q]) && m.removeAttribute(\"data-z-index\");\n        this[q] = a;\n\n        if (e) {\n          (a = this.zIndex) && d && (d.handleZ = !0);\n          q = g.childNodes;\n\n          for (h = q.length - 1; 0 <= h && !C; h--) {\n            if (d = q[h], e = d.getAttribute(\"data-z-index\"), n = !r(e), d !== m) if (0 > a && n && !b && !h) g.insertBefore(m, q[h]), C = !0;else if (f(e) <= a || n && (!r(a) || 0 <= a)) g.insertBefore(m, q[h + 1] || null), C = !0;\n          }\n\n          C || (g.insertBefore(m, q[b ? 3 : 0] || null), C = !0);\n        }\n\n        return C;\n      },\n      _defaultSetter: function _defaultSetter(a, f, q) {\n        q.setAttribute(f, a);\n      }\n    });\n    y.prototype.yGetter = y.prototype.xGetter;\n\n    y.prototype.translateXSetter = y.prototype.translateYSetter = y.prototype.rotationSetter = y.prototype.verticalAlignSetter = y.prototype.rotationOriginXSetter = y.prototype.rotationOriginYSetter = y.prototype.scaleXSetter = y.prototype.scaleYSetter = y.prototype.matrixSetter = function (a, f) {\n      this[f] = a;\n      this.doTransform = !0;\n    };\n\n    y.prototype[\"stroke-widthSetter\"] = y.prototype.strokeSetter = function (a, f, q) {\n      this[f] = a;\n      this.stroke && this[\"stroke-width\"] ? (y.prototype.fillSetter.call(this, this.stroke, \"stroke\", q), q.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === f && 0 === a && this.hasStroke && (q.removeAttribute(\"stroke\"), this.hasStroke = !1);\n    };\n\n    F = a.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };\n\n    n(F.prototype, {\n      Element: y,\n      SVG_NS: J,\n      init: function init(a, f, q, b, d, g, e) {\n        var m;\n        m = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        e || m.css(this.getStyle(b));\n        b = m.element;\n        a.appendChild(b);\n        c(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && c(b, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = b;\n        this.boxWrapper = m;\n        this.alignedObjects = [];\n        this.url = (x || B) && l.getElementsByTagName(\"base\").length ? R.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(l.createTextNode(\"Created with Highcharts 7.0.3\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = g;\n        this.forExport = d;\n        this.styledMode = e;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(f, q, !1);\n        var n;\n        x && a.getBoundingClientRect && (f = function f() {\n          v(a, {\n            left: 0,\n            top: 0\n          });\n          n = a.getBoundingClientRect();\n          v(a, {\n            left: Math.ceil(n.left) - n.left + \"px\",\n            top: Math.ceil(n.top) - n.top + \"px\"\n          });\n        }, f(), this.unSubPixelFix = G(R, \"resize\", f));\n      },\n      definition: function definition(a) {\n        function f(a, b) {\n          var d;\n          L(a).forEach(function (a) {\n            var g = q.createElement(a.tagName),\n                e = {};\n            D(a, function (a, f) {\n              \"tagName\" !== f && \"children\" !== f && \"textContent\" !== f && (e[f] = a);\n            });\n            g.attr(e);\n            g.add(b || q.defs);\n            a.textContent && g.element.appendChild(l.createTextNode(a.textContent));\n            f(a.children || [], g);\n            d = g;\n          });\n          return d;\n        }\n\n        var q = this;\n        return f(a);\n      },\n      getStyle: function getStyle(a) {\n        return this.style = n({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      },\n      setStyle: function setStyle(a) {\n        this.boxWrapper.css(this.getStyle(a));\n      },\n      isHidden: function isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      },\n      destroy: function destroy() {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        e(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      },\n      createElement: function createElement(a) {\n        var f = new this.Element();\n        f.init(this, a);\n        return f;\n      },\n      draw: z,\n      getRadialAttr: function getRadialAttr(a, f) {\n        return {\n          cx: a[0] - a[2] / 2 + f.cx * a[2],\n          cy: a[1] - a[2] / 2 + f.cy * a[2],\n          r: f.r * a[2]\n        };\n      },\n      truncate: function truncate(a, f, q, b, d, g, e) {\n        var m = this,\n            n = a.rotation,\n            h,\n            C = b ? 1 : 0,\n            J = (q || b).length,\n            z = J,\n            c = [],\n            r = function r(a) {\n          f.firstChild && f.removeChild(f.firstChild);\n          a && f.appendChild(l.createTextNode(a));\n        },\n            x = function x(g, n) {\n          n = n || g;\n          if (void 0 === c[n]) if (f.getSubStringLength) try {\n            c[n] = d + f.getSubStringLength(0, b ? n + 1 : n);\n          } catch (Z) {} else m.getSpanWidth && (r(e(q || b, g)), c[n] = d + m.getSpanWidth(a, f));\n          return c[n];\n        },\n            u,\n            D;\n\n        a.rotation = 0;\n        u = x(f.textContent.length);\n\n        if (D = d + u > g) {\n          for (; C <= J;) {\n            z = Math.ceil((C + J) / 2), b && (h = e(b, z)), u = x(z, h && h.length - 1), C === J ? C = J + 1 : u > g ? J = z - 1 : C = z;\n          }\n\n          0 === J ? r(\"\") : q && J === q.length - 1 || r(h || e(q || b, z));\n        }\n\n        b && b.splice(0, z);\n        a.actualWidth = u;\n        a.rotation = n;\n        return D;\n      },\n      escapes: {\n        \"\\x26\": \"\\x26amp;\",\n        \"\\x3c\": \"\\x26lt;\",\n        \"\\x3e\": \"\\x26gt;\",\n        \"'\": \"\\x26#39;\",\n        '\"': \"\\x26quot;\"\n      },\n      buildText: function buildText(a) {\n        var q = a.element,\n            b = this,\n            d = b.forExport,\n            g = A(a.textStr, \"\").toString(),\n            e = -1 !== g.indexOf(\"\\x3c\"),\n            m = q.childNodes,\n            n,\n            h = c(q, \"x\"),\n            C = a.styles,\n            z = a.textWidth,\n            r = C && C.lineHeight,\n            x = C && C.textOutline,\n            u = C && \"ellipsis\" === C.textOverflow,\n            K = C && \"nowrap\" === C.whiteSpace,\n            L = C && C.fontSize,\n            B,\n            M,\n            k = m.length,\n            C = z && !a.added && this.box,\n            H = function H(a) {\n          var g;\n          b.styledMode || (g = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : L || b.style.fontSize || 12);\n          return r ? f(r) : b.fontMetrics(g, a.getAttribute(\"style\") ? a : q).h;\n        },\n            E = function E(a, f) {\n          D(b.escapes, function (q, b) {\n            f && -1 !== f.indexOf(q) || (a = a.toString().replace(new RegExp(q, \"g\"), b));\n          });\n          return a;\n        },\n            w = function w(a, f) {\n          var q;\n          q = a.indexOf(\"\\x3c\");\n          a = a.substring(q, a.indexOf(\"\\x3e\") - q);\n          q = a.indexOf(f + \"\\x3d\");\n          if (-1 !== q && (q = q + f.length + 1, f = a.charAt(q), '\"' === f || \"'\" === f)) return a = a.substring(q + 1), a.substring(0, a.indexOf(f));\n        };\n\n        B = [g, u, K, r, x, L, z].join();\n\n        if (B !== a.textCache) {\n          for (a.textCache = B; k--;) {\n            q.removeChild(m[k]);\n          }\n\n          e || x || u || z || -1 !== g.indexOf(\" \") ? (C && C.appendChild(q), e ? (g = b.styledMode ? g.replace(/<(b|strong)>/g, '\\x3cspan class\\x3d\"highcharts-strong\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan class\\x3d\"highcharts-emphasized\"\\x3e') : g.replace(/<(b|strong)>/g, '\\x3cspan style\\x3d\"font-weight:bold\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan style\\x3d\"font-style:italic\"\\x3e'), g = g.replace(/<a/g, \"\\x3cspan\").replace(/<\\/(b|strong|i|em|a)>/g, \"\\x3c/span\\x3e\").split(/<br.*?>/g)) : g = [g], g = g.filter(function (a) {\n            return \"\" !== a;\n          }), g.forEach(function (f, g) {\n            var e,\n                m = 0,\n                C = 0;\n            f = f.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||\\x3cspan\").replace(/<\\/span>/g, \"\\x3c/span\\x3e|||\");\n            e = f.split(\"|||\");\n            e.forEach(function (f) {\n              if (\"\" !== f || 1 === e.length) {\n                var r = {},\n                    x = l.createElementNS(b.SVG_NS, \"tspan\"),\n                    D,\n                    A;\n                (D = w(f, \"class\")) && c(x, \"class\", D);\n                if (D = w(f, \"style\")) D = D.replace(/(;| |^)color([ :])/, \"$1fill$2\"), c(x, \"style\", D);\n                (A = w(f, \"href\")) && !d && (c(x, \"onclick\", 'location.href\\x3d\"' + A + '\"'), c(x, \"class\", \"highcharts-anchor\"), b.styledMode || v(x, {\n                  cursor: \"pointer\"\n                }));\n                f = E(f.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== f) {\n                  x.appendChild(l.createTextNode(f));\n                  m ? r.dx = 0 : g && null !== h && (r.x = h);\n                  c(x, r);\n                  q.appendChild(x);\n                  !m && M && (!T && d && v(x, {\n                    display: \"block\"\n                  }), c(x, \"dy\", H(x)));\n\n                  if (z) {\n                    var B = f.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                        r = !K && (1 < e.length || g || 1 < B.length);\n                    A = 0;\n                    var k = H(x);\n                    if (u) n = b.truncate(a, x, f, void 0, 0, Math.max(0, z - parseInt(L || 12, 10)), function (a, f) {\n                      return a.substring(0, f) + \"\\u2026\";\n                    });else if (r) for (; B.length;) {\n                      B.length && !K && 0 < A && (x = l.createElementNS(J, \"tspan\"), c(x, {\n                        dy: k,\n                        x: h\n                      }), D && c(x, \"style\", D), x.appendChild(l.createTextNode(B.join(\" \").replace(/- /g, \"-\"))), q.appendChild(x)), b.truncate(a, x, null, B, 0 === A ? C : 0, z, function (a, f) {\n                        return B.slice(0, f).join(\" \").replace(/- /g, \"-\");\n                      }), C = a.actualWidth, A++;\n                    }\n                  }\n\n                  m++;\n                }\n              }\n            });\n            M = M || q.childNodes.length;\n          }), u && n && a.attr(\"title\", E(a.textStr, [\"\\x26lt;\", \"\\x26gt;\"])), C && C.removeChild(q), x && a.applyTextOutline && a.applyTextOutline(x)) : q.appendChild(l.createTextNode(E(g)));\n        }\n      },\n      getContrast: function getContrast(a) {\n        a = t(a).rgba;\n        a[0] *= 1;\n        a[1] *= 1.2;\n        a[2] *= .5;\n        return 459 < a[0] + a[1] + a[2] ? \"#000000\" : \"#FFFFFF\";\n      },\n      button: function button(a, f, q, b, g, d, e, h, z) {\n        var C = this.label(a, f, q, z, null, null, null, null, \"button\"),\n            J = 0,\n            x = this.styledMode;\n        C.attr(m({\n          padding: 8,\n          r: 2\n        }, g));\n\n        if (!x) {\n          var l, r, c, D;\n          g = m({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, g);\n          l = g.style;\n          delete g.style;\n          d = m(g, {\n            fill: \"#e6e6e6\"\n          }, d);\n          r = d.style;\n          delete d.style;\n          e = m(g, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, e);\n          c = e.style;\n          delete e.style;\n          h = m(g, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, h);\n          D = h.style;\n          delete h.style;\n        }\n\n        G(C.element, u ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== J && C.setState(1);\n        });\n        G(C.element, u ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== J && C.setState(J);\n        });\n\n        C.setState = function (a) {\n          1 !== a && (C.state = J = a);\n          C.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          x || C.attr([g, d, e, h][a || 0]).css([l, r, c, D][a || 0]);\n        };\n\n        x || C.attr(g).css(n({\n          cursor: \"default\"\n        }, l));\n        return C.on(\"click\", function (a) {\n          3 !== J && b.call(C, a);\n        });\n      },\n      crispLine: function crispLine(a, f) {\n        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - f % 2 / 2);\n        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + f % 2 / 2);\n        return a;\n      },\n      path: function path(a) {\n        var f = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        b(a) ? f.d = a : H(a) && n(f, a);\n        return this.createElement(\"path\").attr(f);\n      },\n      circle: function circle(a, f, q) {\n        a = H(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: f,\n          r: q\n        };\n        f = this.createElement(\"circle\");\n\n        f.xSetter = f.ySetter = function (a, f, q) {\n          q.setAttribute(\"c\" + f, a);\n        };\n\n        return f.attr(a);\n      },\n      arc: function arc(a, f, q, b, g, d) {\n        H(a) ? (b = a, f = b.y, q = b.r, a = b.x) : b = {\n          innerR: b,\n          start: g,\n          end: d\n        };\n        a = this.symbol(\"arc\", a, f, q, q, b);\n        a.r = q;\n        return a;\n      },\n      rect: function rect(a, f, q, b, g, d) {\n        g = H(a) ? a.r : g;\n        var e = this.createElement(\"rect\");\n        a = H(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: f,\n          width: Math.max(q, 0),\n          height: Math.max(b, 0)\n        };\n        this.styledMode || (void 0 !== d && (a.strokeWidth = d, a = e.crisp(a)), a.fill = \"none\");\n        g && (a.r = g);\n\n        e.rSetter = function (a, f, q) {\n          c(q, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        return e.attr(a);\n      },\n      setSize: function setSize(a, f, q) {\n        var b = this.alignedObjects,\n            g = b.length;\n        this.width = a;\n        this.height = f;\n\n        for (this.boxWrapper.animate({\n          width: a,\n          height: f\n        }, {\n          step: function step() {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: A(q, !0) ? void 0 : 0\n        }); g--;) {\n          b[g].align();\n        }\n      },\n      g: function g(a) {\n        var f = this.createElement(\"g\");\n        return a ? f.attr({\n          \"class\": \"highcharts-\" + a\n        }) : f;\n      },\n      image: function image(a, f, q, b, g, d) {\n        var e = {\n          preserveAspectRatio: \"none\"\n        },\n            m,\n            h = function h(a, f) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", f) : a.setAttribute(\"hc-svg-href\", f);\n        },\n            J = function J(f) {\n          h(m.element, a);\n          d.call(m, f);\n        };\n\n        1 < arguments.length && n(e, {\n          x: f,\n          y: q,\n          width: b,\n          height: g\n        });\n        m = this.createElement(\"image\").attr(e);\n        d ? (h(m.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw\\x3d\\x3d\"), e = new R.Image(), G(e, \"load\", J), e.src = a, e.complete && J({})) : h(m.element, a);\n        return m;\n      },\n      symbol: function symbol(a, f, q, b, g, d) {\n        var e = this,\n            m,\n            h = /^url\\((.*?)\\)$/,\n            J = h.test(a),\n            z = !J && (this.symbols[a] ? a : \"circle\"),\n            x = z && this.symbols[z],\n            c = r(f) && x && x.call(this.symbols, Math.round(f), Math.round(q), b, g, d),\n            C,\n            u;\n        x ? (m = this.path(c), e.styledMode || m.attr(\"fill\", \"none\"), n(m, {\n          symbolName: z,\n          x: f,\n          y: q,\n          width: b,\n          height: g\n        }), d && n(m, d)) : J && (C = a.match(h)[1], m = this.image(C), m.imgwidth = A(M[C] && M[C].width, d && d.width), m.imgheight = A(M[C] && M[C].height, d && d.height), u = function u() {\n          m.attr({\n            width: m.width,\n            height: m.height\n          });\n        }, [\"width\", \"height\"].forEach(function (a) {\n          m[a + \"Setter\"] = function (a, f) {\n            var q = {},\n                b = this[\"img\" + f],\n                g = \"width\" === f ? \"translateX\" : \"translateY\";\n            this[f] = a;\n            r(b) && (this.element && this.element.setAttribute(f, b), this.alignByTranslate || (q[g] = ((this[f] || 0) - b) / 2, this.attr(q)));\n          };\n        }), r(f) && m.attr({\n          x: f,\n          y: q\n        }), m.isImg = !0, r(m.imgwidth) && r(m.imgheight) ? u() : (m.attr({\n          width: 0,\n          height: 0\n        }), w(\"img\", {\n          onload: function onload() {\n            var a = p[e.chartIndex];\n            0 === this.width && (v(this, {\n              position: \"absolute\",\n              top: \"-999em\"\n            }), l.body.appendChild(this));\n            M[C] = {\n              width: this.width,\n              height: this.height\n            };\n            m.imgwidth = this.width;\n            m.imgheight = this.height;\n            m.element && u();\n            this.parentNode && this.parentNode.removeChild(this);\n            e.imgCount--;\n            if (!e.imgCount && a && a.onload) a.onload();\n          },\n          src: C\n        }), this.imgCount++));\n        return m;\n      },\n      symbols: {\n        circle: function circle(a, f, q, b) {\n          return this.arc(a + q / 2, f + b / 2, q / 2, b / 2, {\n            start: 0,\n            end: 2 * Math.PI,\n            open: !1\n          });\n        },\n        square: function square(a, f, q, b) {\n          return [\"M\", a, f, \"L\", a + q, f, a + q, f + b, a, f + b, \"Z\"];\n        },\n        triangle: function triangle(a, f, q, b) {\n          return [\"M\", a + q / 2, f, \"L\", a + q, f + b, a, f + b, \"Z\"];\n        },\n        \"triangle-down\": function triangleDown(a, f, q, b) {\n          return [\"M\", a, f, \"L\", a + q, f, a + q / 2, f + b, \"Z\"];\n        },\n        diamond: function diamond(a, f, q, b) {\n          return [\"M\", a + q / 2, f, \"L\", a + q, f + b / 2, a + q / 2, f + b, a, f + b / 2, \"Z\"];\n        },\n        arc: function arc(a, f, q, b, g) {\n          var d = g.start,\n              e = g.r || q,\n              m = g.r || b || q,\n              n = g.end - .001;\n          q = g.innerR;\n          b = A(g.open, .001 > Math.abs(g.end - g.start - 2 * Math.PI));\n          var h = Math.cos(d),\n              J = Math.sin(d),\n              z = Math.cos(n),\n              n = Math.sin(n);\n          g = .001 > g.end - d - Math.PI ? 0 : 1;\n          e = [\"M\", a + e * h, f + m * J, \"A\", e, m, 0, g, 1, a + e * z, f + m * n];\n          r(q) && e.push(b ? \"M\" : \"L\", a + q * z, f + q * n, \"A\", q, q, 0, g, 0, a + q * h, f + q * J);\n          e.push(b ? \"\" : \"Z\");\n          return e;\n        },\n        callout: function callout(a, f, q, b, g) {\n          var d = Math.min(g && g.r || 0, q, b),\n              e = d + 6,\n              m = g && g.anchorX;\n          g = g && g.anchorY;\n          var n;\n          n = [\"M\", a + d, f, \"L\", a + q - d, f, \"C\", a + q, f, a + q, f, a + q, f + d, \"L\", a + q, f + b - d, \"C\", a + q, f + b, a + q, f + b, a + q - d, f + b, \"L\", a + d, f + b, \"C\", a, f + b, a, f + b, a, f + b - d, \"L\", a, f + d, \"C\", a, f, a, f, a + d, f];\n          m && m > q ? g > f + e && g < f + b - e ? n.splice(13, 3, \"L\", a + q, g - 6, a + q + 6, g, a + q, g + 6, a + q, f + b - d) : n.splice(13, 3, \"L\", a + q, b / 2, m, g, a + q, b / 2, a + q, f + b - d) : m && 0 > m ? g > f + e && g < f + b - e ? n.splice(33, 3, \"L\", a, g + 6, a - 6, g, a, g - 6, a, f + d) : n.splice(33, 3, \"L\", a, b / 2, m, g, a, b / 2, a, f + d) : g && g > b && m > a + e && m < a + q - e ? n.splice(23, 3, \"L\", m + 6, f + b, m, f + b + 6, m - 6, f + b, a + d, f + b) : g && 0 > g && m > a + e && m < a + q - e && n.splice(3, 3, \"L\", m - 6, f, m, f - 6, m + 6, f, q - d, f);\n          return n;\n        }\n      },\n      clipRect: function clipRect(f, q, b, g) {\n        var d = a.uniqueKey(),\n            e = this.createElement(\"clipPath\").attr({\n          id: d\n        }).add(this.defs);\n        f = this.rect(f, q, b, g, 0).add(e);\n        f.id = d;\n        f.clipPath = e;\n        f.count = 0;\n        return f;\n      },\n      text: function text(a, f, q, b) {\n        var g = {};\n        if (b && (this.allowHTML || !this.forExport)) return this.html(a, f, q);\n        g.x = Math.round(f || 0);\n        q && (g.y = Math.round(q));\n        r(a) && (g.text = a);\n        a = this.createElement(\"text\").attr(g);\n        b || (a.xSetter = function (a, f, q) {\n          var b = q.getElementsByTagName(\"tspan\"),\n              g,\n              d = q.getAttribute(f),\n              e;\n\n          for (e = 0; e < b.length; e++) {\n            g = b[e], g.getAttribute(f) === d && g.setAttribute(f, a);\n          }\n\n          q.setAttribute(f, a);\n        });\n        return a;\n      },\n      fontMetrics: function fontMetrics(a, q) {\n        a = !this.styledMode && /px/.test(a) || !R.getComputedStyle ? a || q && q.style && q.style.fontSize || this.style && this.style.fontSize : q && y.prototype.getStyle.call(q, \"font-size\");\n        a = /px/.test(a) ? f(a) : 12;\n        q = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: q,\n          b: Math.round(.8 * q),\n          f: a\n        };\n      },\n      rotCorr: function rotCorr(a, f, q) {\n        var b = a;\n        f && q && (b = Math.max(b * Math.cos(f * h), 4));\n        return {\n          x: -a / 3 * Math.sin(f * h),\n          y: b\n        };\n      },\n      label: function label(f, b, g, d, e, h, J, z, x) {\n        var l = this,\n            c = l.styledMode,\n            u = l.g(\"button\" !== x && \"label\"),\n            D = u.text = l.text(\"\", 0, 0, J).attr({\n          zIndex: 1\n        }),\n            K,\n            L,\n            C = 0,\n            A = 3,\n            B = 0,\n            M,\n            k,\n            E,\n            H,\n            T,\n            w = {},\n            p,\n            t,\n            R = /^url\\((.*?)\\)$/.test(d),\n            v = c || R,\n            P = function P() {\n          return c ? K.strokeWidth() % 2 / 2 : (p ? parseInt(p, 10) : 0) % 2 / 2;\n        },\n            U,\n            O,\n            S;\n\n        x && u.addClass(\"highcharts-\" + x);\n\n        U = function U() {\n          var a = D.element.style,\n              f = {};\n          L = (void 0 === M || void 0 === k || T) && r(D.textStr) && D.getBBox();\n          u.width = (M || L.width || 0) + 2 * A + B;\n          u.height = (k || L.height || 0) + 2 * A;\n          t = A + Math.min(l.fontMetrics(a && a.fontSize, D).b, L ? L.height : Infinity);\n          v && (K || (u.box = K = l.symbols[d] || R ? l.symbol(d) : l.rect(), K.addClass((\"button\" === x ? \"\" : \"highcharts-label-box\") + (x ? \" highcharts-\" + x + \"-box\" : \"\")), K.add(u), a = P(), f.x = a, f.y = (z ? -t : 0) + a), f.width = Math.round(u.width), f.height = Math.round(u.height), K.attr(n(f, w)), w = {});\n        };\n\n        O = function O() {\n          var a = B + A,\n              f;\n          f = z ? 0 : t;\n          r(M) && L && (\"center\" === T || \"right\" === T) && (a += {\n            center: .5,\n            right: 1\n          }[T] * (M - L.width));\n          if (a !== D.x || f !== D.y) D.attr(\"x\", a), D.hasBoxWidthChanged && (L = D.getBBox(!0), U()), void 0 !== f && D.attr(\"y\", f);\n          D.x = a;\n          D.y = f;\n        };\n\n        S = function S(a, f) {\n          K ? K.attr(a, f) : w[a] = f;\n        };\n\n        u.onAdd = function () {\n          D.add(u);\n          u.attr({\n            text: f || 0 === f ? f : \"\",\n            x: b,\n            y: g\n          });\n          K && r(e) && u.attr({\n            anchorX: e,\n            anchorY: h\n          });\n        };\n\n        u.widthSetter = function (f) {\n          M = a.isNumber(f) ? f : null;\n        };\n\n        u.heightSetter = function (a) {\n          k = a;\n        };\n\n        u[\"text-alignSetter\"] = function (a) {\n          T = a;\n        };\n\n        u.paddingSetter = function (a) {\n          r(a) && a !== A && (A = u.padding = a, O());\n        };\n\n        u.paddingLeftSetter = function (a) {\n          r(a) && a !== B && (B = a, O());\n        };\n\n        u.alignSetter = function (a) {\n          a = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a];\n          a !== C && (C = a, L && u.attr({\n            x: E\n          }));\n        };\n\n        u.textSetter = function (a) {\n          void 0 !== a && D.textSetter(a);\n          U();\n          O();\n        };\n\n        u[\"stroke-widthSetter\"] = function (a, f) {\n          a && (v = !0);\n          p = this[\"stroke-width\"] = a;\n          S(f, a);\n        };\n\n        c ? u.rSetter = function (a, f) {\n          S(f, a);\n        } : u.strokeSetter = u.fillSetter = u.rSetter = function (a, f) {\n          \"r\" !== f && (\"fill\" === f && a && (v = !0), u[f] = a);\n          S(f, a);\n        };\n\n        u.anchorXSetter = function (a, f) {\n          e = u.anchorX = a;\n          S(f, Math.round(a) - P() - E);\n        };\n\n        u.anchorYSetter = function (a, f) {\n          h = u.anchorY = a;\n          S(f, a - H);\n        };\n\n        u.xSetter = function (a) {\n          u.x = a;\n          C && (a -= C * ((M || L.width) + 2 * A), u[\"forceAnimate:x\"] = !0);\n          E = Math.round(a);\n          u.attr(\"translateX\", E);\n        };\n\n        u.ySetter = function (a) {\n          H = u.y = Math.round(a);\n          u.attr(\"translateY\", H);\n        };\n\n        var G = u.css;\n        J = {\n          css: function css(a) {\n            if (a) {\n              var f = {};\n              a = m(a);\n              u.textProps.forEach(function (q) {\n                void 0 !== a[q] && (f[q] = a[q], delete a[q]);\n              });\n              D.css(f);\n              \"width\" in f && U();\n              \"fontSize\" in f && (U(), O());\n            }\n\n            return G.call(u, a);\n          },\n          getBBox: function getBBox() {\n            return {\n              width: L.width + 2 * A,\n              height: L.height + 2 * A,\n              x: L.x - A,\n              y: L.y - A\n            };\n          },\n          destroy: function destroy() {\n            q(u.element, \"mouseenter\");\n            q(u.element, \"mouseleave\");\n            D && (D = D.destroy());\n            K && (K = K.destroy());\n            y.prototype.destroy.call(u);\n            u = l = U = O = S = null;\n          }\n        };\n        c || (J.shadow = function (a) {\n          a && (U(), K && K.shadow(a));\n          return u;\n        });\n        return n(u, J);\n      }\n    });\n    a.Renderer = F;\n  })(I);\n\n  (function (a) {\n    var y = a.attr,\n        F = a.createElement,\n        G = a.css,\n        k = a.defined,\n        c = a.extend,\n        p = a.isFirefox,\n        t = a.isMS,\n        v = a.isWebKit,\n        w = a.pick,\n        r = a.pInt,\n        h = a.SVGElement,\n        e = a.SVGRenderer,\n        l = a.win;\n    c(h.prototype, {\n      htmlCss: function htmlCss(a) {\n        var d = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n            g = w(d && a.width, void 0),\n            b;\n        d && (delete a.width, this.textWidth = g, b = !0);\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = c(this.styles, a);\n        G(this.element, a);\n        b && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function htmlGetBBox() {\n        var a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n              d = this.element,\n              g = this.translateX || 0,\n              b = this.translateY || 0,\n              e = this.x || 0,\n              h = this.y || 0,\n              l = this.textAlign || \"left\",\n              c = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[l],\n              B = this.styles,\n              m = B && B.whiteSpace;\n          G(d, {\n            marginLeft: g,\n            marginTop: b\n          });\n          !a.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            G(a, {\n              marginLeft: g + 1,\n              marginTop: b + 1\n            });\n          });\n          this.inverted && [].forEach.call(d.childNodes, function (f) {\n            a.invertChild(f, d);\n          });\n\n          if (\"SPAN\" === d.tagName) {\n            var B = this.rotation,\n                z = this.textWidth && r(this.textWidth),\n                D = [B, l, d.innerHTML, this.textWidth, this.textAlign].join(),\n                A;\n            (A = z !== this.oldTextWidth) && !(A = z > this.oldTextWidth) && ((A = this.textPxLength) || (G(d, {\n              width: \"\",\n              whiteSpace: m || \"nowrap\"\n            }), A = d.offsetWidth), A = A > z);\n            A && (/[ \\-]/.test(d.textContent || d.innerText) || \"ellipsis\" === d.style.textOverflow) ? (G(d, {\n              width: z + \"px\",\n              display: \"block\",\n              whiteSpace: m || \"normal\"\n            }), this.oldTextWidth = z, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            D !== this.cTT && (m = a.fontMetrics(d.style.fontSize, d).b, !k(B) || B === (this.oldRotation || 0) && l === this.oldAlign || this.setSpanRotation(B, c, m), this.getSpanCorrection(!k(B) && this.textPxLength || d.offsetWidth, m, c, B, l));\n            G(d, {\n              left: e + (this.xCorr || 0) + \"px\",\n              top: h + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = D;\n            this.oldRotation = B;\n            this.oldAlign = l;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function setSpanRotation(a, d, g) {\n        var b = {},\n            e = this.renderer.getTransformKey();\n        b[e] = b.transform = \"rotate(\" + a + \"deg)\";\n        b[e + (p ? \"Origin\" : \"-origin\")] = b.transformOrigin = 100 * d + \"% \" + g + \"px\";\n        G(this.element, b);\n      },\n      getSpanCorrection: function getSpanCorrection(a, d, g) {\n        this.xCorr = -a * g;\n        this.yCorr = -d;\n      }\n    });\n    c(e.prototype, {\n      getTransformKey: function getTransformKey() {\n        return t && !/Edge/.test(l.navigator.userAgent) ? \"-ms-transform\" : v ? \"-webkit-transform\" : p ? \"MozTransform\" : l.opera ? \"-o-transform\" : \"\";\n      },\n      html: function html(e, d, g) {\n        var b = this.createElement(\"span\"),\n            n = b.element,\n            u = b.renderer,\n            l = u.isSVG,\n            r = function r(a, b) {\n          [\"opacity\", \"visibility\"].forEach(function (g) {\n            a[g + \"Setter\"] = function (a, f, q) {\n              h.prototype[g + \"Setter\"].call(this, a, f, q);\n              b[f] = a;\n            };\n          });\n          a.addedSetters = !0;\n        },\n            B = a.charts[u.chartIndex],\n            B = B && B.styledMode;\n\n        b.textSetter = function (a) {\n          a !== n.innerHTML && delete this.bBox;\n          this.textStr = a;\n          n.innerHTML = w(a, \"\");\n          b.doTransform = !0;\n        };\n\n        l && r(b, b.element.style);\n\n        b.xSetter = b.ySetter = b.alignSetter = b.rotationSetter = function (a, g) {\n          \"align\" === g && (g = \"textAlign\");\n          b[g] = a;\n          b.doTransform = !0;\n        };\n\n        b.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        b.attr({\n          text: e,\n          x: Math.round(d),\n          y: Math.round(g)\n        }).css({\n          position: \"absolute\"\n        });\n        B || b.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        n.style.whiteSpace = \"nowrap\";\n        b.css = b.htmlCss;\n        l && (b.add = function (a) {\n          var g,\n              d = u.box.parentNode,\n              e = [];\n\n          if (this.parentGroup = a) {\n            if (g = a.div, !g) {\n              for (; a;) {\n                e.push(a), a = a.parentGroup;\n              }\n\n              e.reverse().forEach(function (a) {\n                function f(f, q) {\n                  a[q] = f;\n                  \"translateX\" === q ? m.left = f + \"px\" : m.top = f + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var m,\n                    h = y(a.element, \"class\");\n                h && (h = {\n                  className: h\n                });\n                g = a.div = a.div || F(\"div\", h, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, g || d);\n                m = g.style;\n                c(a, {\n                  classSetter: function (a) {\n                    return function (f) {\n                      this.element.setAttribute(\"class\", f);\n                      a.className = f;\n                    };\n                  }(g),\n                  on: function on() {\n                    e[0].div && b.on.apply({\n                      element: e[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: f,\n                  translateYSetter: f\n                });\n                a.addedSetters || r(a, m);\n              });\n            }\n          } else g = d;\n\n          g.appendChild(n);\n          b.added = !0;\n          b.alignOnAdd && b.htmlUpdateTransform();\n          return b;\n        });\n        return b;\n      }\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.defined,\n        F = a.extend,\n        G = a.merge,\n        k = a.pick,\n        c = a.timeUnits,\n        p = a.win;\n\n    a.Time = function (a) {\n      this.update(a, !1);\n    };\n\n    a.Time.prototype = {\n      defaultOptions: {},\n      update: function update(a) {\n        var c = k(a && a.useUTC, !0),\n            w = this;\n        this.options = a = G(!0, this.options || {}, a);\n        this.Date = a.Date || p.Date || Date;\n        this.timezoneOffset = (this.useUTC = c) && a.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        (this.variableTimezone = !(c && !a.getTimezoneOffset && !a.timezone)) || this.timezoneOffset ? (this.get = function (a, h) {\n          var e = h.getTime(),\n              l = e - w.getTimezoneOffset(h);\n          h.setTime(l);\n          a = h[\"getUTC\" + a]();\n          h.setTime(e);\n          return a;\n        }, this.set = function (a, h, e) {\n          var l;\n          if (\"Milliseconds\" === a || \"Seconds\" === a || \"Minutes\" === a && 0 === h.getTimezoneOffset() % 60) h[\"set\" + a](e);else l = w.getTimezoneOffset(h), l = h.getTime() - l, h.setTime(l), h[\"setUTC\" + a](e), a = w.getTimezoneOffset(h), l = h.getTime() + a, h.setTime(l);\n        }) : c ? (this.get = function (a, h) {\n          return h[\"getUTC\" + a]();\n        }, this.set = function (a, h, e) {\n          return h[\"setUTC\" + a](e);\n        }) : (this.get = function (a, h) {\n          return h[\"get\" + a]();\n        }, this.set = function (a, h, e) {\n          return h[\"set\" + a](e);\n        });\n      },\n      makeTime: function makeTime(c, p, w, r, h, e) {\n        var l, n, d;\n        this.useUTC ? (l = this.Date.UTC.apply(0, arguments), n = this.getTimezoneOffset(l), l += n, d = this.getTimezoneOffset(l), n !== d ? l += d - n : n - 36E5 !== this.getTimezoneOffset(l - 36E5) || a.isSafari || (l -= 36E5)) : l = new this.Date(c, p, k(w, 1), k(r, 0), k(h, 0), k(e, 0)).getTime();\n        return l;\n      },\n      timezoneOffsetFunction: function timezoneOffsetFunction() {\n        var c = this,\n            k = this.options,\n            w = p.moment;\n        if (!this.useUTC) return function (a) {\n          return 6E4 * new Date(a).getTimezoneOffset();\n        };\n\n        if (k.timezone) {\n          if (w) return function (a) {\n            return 6E4 * -w.tz(a, k.timezone).utcOffset();\n          };\n          a.error(25);\n        }\n\n        return this.useUTC && k.getTimezoneOffset ? function (a) {\n          return 6E4 * k.getTimezoneOffset(a);\n        } : function () {\n          return 6E4 * (c.timezoneOffset || 0);\n        };\n      },\n      dateFormat: function dateFormat(c, k, w) {\n        if (!a.defined(k) || isNaN(k)) return a.defaultOptions.lang.invalidDate || \"\";\n        c = a.pick(c, \"%Y-%m-%d %H:%M:%S\");\n        var r = this,\n            h = new this.Date(k),\n            e = this.get(\"Hours\", h),\n            l = this.get(\"Day\", h),\n            n = this.get(\"Date\", h),\n            d = this.get(\"Month\", h),\n            g = this.get(\"FullYear\", h),\n            b = a.defaultOptions.lang,\n            x = b.weekdays,\n            u = b.shortWeekdays,\n            H = a.pad,\n            h = a.extend({\n          a: u ? u[l] : x[l].substr(0, 3),\n          A: x[l],\n          d: H(n),\n          e: H(n, 2, \" \"),\n          w: l,\n          b: b.shortMonths[d],\n          B: b.months[d],\n          m: H(d + 1),\n          o: d + 1,\n          y: g.toString().substr(2, 2),\n          Y: g,\n          H: H(e),\n          k: e,\n          I: H(e % 12 || 12),\n          l: e % 12 || 12,\n          M: H(r.get(\"Minutes\", h)),\n          p: 12 > e ? \"AM\" : \"PM\",\n          P: 12 > e ? \"am\" : \"pm\",\n          S: H(h.getSeconds()),\n          L: H(Math.floor(k % 1E3), 3)\n        }, a.dateFormats);\n        a.objectEach(h, function (a, b) {\n          for (; -1 !== c.indexOf(\"%\" + b);) {\n            c = c.replace(\"%\" + b, \"function\" === typeof a ? a.call(r, k) : a);\n          }\n        });\n        return w ? c.substr(0, 1).toUpperCase() + c.substr(1) : c;\n      },\n      resolveDTLFormat: function resolveDTLFormat(c) {\n        return a.isObject(c, !0) ? c : (c = a.splat(c), {\n          main: c[0],\n          from: c[1],\n          to: c[2]\n        });\n      },\n      getTimeTicks: function getTimeTicks(a, p, w, r) {\n        var h = this,\n            e = [],\n            l,\n            n = {},\n            d;\n        l = new h.Date(p);\n        var g = a.unitRange,\n            b = a.count || 1,\n            x;\n        r = k(r, 1);\n\n        if (y(p)) {\n          h.set(\"Milliseconds\", l, g >= c.second ? 0 : b * Math.floor(h.get(\"Milliseconds\", l) / b));\n          g >= c.second && h.set(\"Seconds\", l, g >= c.minute ? 0 : b * Math.floor(h.get(\"Seconds\", l) / b));\n          g >= c.minute && h.set(\"Minutes\", l, g >= c.hour ? 0 : b * Math.floor(h.get(\"Minutes\", l) / b));\n          g >= c.hour && h.set(\"Hours\", l, g >= c.day ? 0 : b * Math.floor(h.get(\"Hours\", l) / b));\n          g >= c.day && h.set(\"Date\", l, g >= c.month ? 1 : Math.max(1, b * Math.floor(h.get(\"Date\", l) / b)));\n          g >= c.month && (h.set(\"Month\", l, g >= c.year ? 0 : b * Math.floor(h.get(\"Month\", l) / b)), d = h.get(\"FullYear\", l));\n          g >= c.year && h.set(\"FullYear\", l, d - d % b);\n          g === c.week && (d = h.get(\"Day\", l), h.set(\"Date\", l, h.get(\"Date\", l) - d + r + (d < r ? -7 : 0)));\n          d = h.get(\"FullYear\", l);\n          r = h.get(\"Month\", l);\n          var u = h.get(\"Date\", l),\n              H = h.get(\"Hours\", l);\n          p = l.getTime();\n          h.variableTimezone && (x = w - p > 4 * c.month || h.getTimezoneOffset(p) !== h.getTimezoneOffset(w));\n          p = l.getTime();\n\n          for (l = 1; p < w;) {\n            e.push(p), p = g === c.year ? h.makeTime(d + l * b, 0) : g === c.month ? h.makeTime(d, r + l * b) : !x || g !== c.day && g !== c.week ? x && g === c.hour && 1 < b ? h.makeTime(d, r, u, H + l * b) : p + g * b : h.makeTime(d, r, u + l * b * (g === c.day ? 1 : 7)), l++;\n          }\n\n          e.push(p);\n          g <= c.hour && 1E4 > e.length && e.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === h.dateFormat(\"%H%M%S%L\", a) && (n[a] = \"day\");\n          });\n        }\n\n        e.info = F(a, {\n          higherRanks: n,\n          totalRange: g * b\n        });\n        return e;\n      }\n    };\n  })(I);\n\n  (function (a) {\n    var y = a.color,\n        F = a.merge;\n    a.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: a.Time.prototype.defaultOptions,\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function labelFormatter() {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: a.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: a.isTouchDevice ? 25 : 10,\n        headerFormat: '\\x3cspan style\\x3d\"font-size: 10px\"\\x3e{point.key}\\x3c/span\\x3e\\x3cbr/\\x3e',\n        pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>\",\n        backgroundColor: y(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          pointerEvents: \"none\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n\n    a.setOptions = function (y) {\n      a.defaultOptions = F(!0, a.defaultOptions, y);\n      a.time.update(F(a.defaultOptions.global, a.defaultOptions.time), !1);\n      return a.defaultOptions;\n    };\n\n    a.getOptions = function () {\n      return a.defaultOptions;\n    };\n\n    a.defaultPlotOptions = a.defaultOptions.plotOptions;\n    a.time = new a.Time(F(a.defaultOptions.global, a.defaultOptions.time));\n\n    a.dateFormat = function (y, k, c) {\n      return a.time.dateFormat(y, k, c);\n    };\n  })(I);\n\n  (function (a) {\n    var y = a.correctFloat,\n        F = a.defined,\n        G = a.destroyObjectProperties,\n        k = a.fireEvent,\n        c = a.isNumber,\n        p = a.merge,\n        t = a.pick,\n        v = a.deg2rad;\n\n    a.Tick = function (a, c, h, e, l) {\n      this.axis = a;\n      this.pos = c;\n      this.type = h || \"\";\n      this.isNewLabel = this.isNew = !0;\n      this.parameters = l || {};\n      this.tickmarkOffset = this.parameters.tickmarkOffset;\n      this.options = this.parameters.options;\n      h || e || this.addLabel();\n    };\n\n    a.Tick.prototype = {\n      addLabel: function addLabel() {\n        var c = this,\n            r = c.axis,\n            h = r.options,\n            e = r.chart,\n            l = r.categories,\n            n = r.names,\n            d = c.pos,\n            g = t(c.options && c.options.labels, h.labels),\n            b = r.tickPositions,\n            x = d === b[0],\n            u = d === b[b.length - 1],\n            l = this.parameters.category || (l ? t(l[d], n[d], d) : d),\n            k = c.label,\n            b = b.info,\n            E,\n            B,\n            m,\n            z;\n        r.isDatetimeAxis && b && (B = e.time.resolveDTLFormat(h.dateTimeLabelFormats[!h.grid && b.higherRanks[d] || b.unitName]), E = B.main);\n        c.isFirst = x;\n        c.isLast = u;\n        c.formatCtx = {\n          axis: r,\n          chart: e,\n          isFirst: x,\n          isLast: u,\n          dateTimeLabelFormat: E,\n          tickPositionInfo: b,\n          value: r.isLog ? y(r.lin2log(l)) : l,\n          pos: d\n        };\n        h = r.labelFormatter.call(c.formatCtx, this.formatCtx);\n        if (z = B && B.list) c.shortenLabel = function () {\n          for (m = 0; m < z.length; m++) {\n            if (k.attr({\n              text: r.labelFormatter.call(a.extend(c.formatCtx, {\n                dateTimeLabelFormat: z[m]\n              }))\n            }), k.getBBox().width < r.getSlotWidth(c) - 2 * t(g.padding, 5)) return;\n          }\n\n          k.attr({\n            text: \"\"\n          });\n        };\n        if (F(k)) k && k.textStr !== h && (!k.textWidth || g.style && g.style.width || k.styles.width || k.css({\n          width: null\n        }), k.attr({\n          text: h\n        }));else {\n          if (c.label = k = F(h) && g.enabled ? e.renderer.text(h, 0, 0, g.useHTML).add(r.labelGroup) : null) e.styledMode || k.css(p(g.style)), k.textPxLength = k.getBBox().width;\n          c.rotation = 0;\n        }\n      },\n      getLabelSize: function getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      },\n      handleOverflow: function handleOverflow(a) {\n        var c = this.axis,\n            h = c.options.labels,\n            e = a.x,\n            l = c.chart.chartWidth,\n            n = c.chart.spacing,\n            d = t(c.labelLeft, Math.min(c.pos, n[3])),\n            n = t(c.labelRight, Math.max(c.isRadial ? 0 : c.pos + c.len, l - n[1])),\n            g = this.label,\n            b = this.rotation,\n            x = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[c.labelAlign || g.attr(\"align\")],\n            u = g.getBBox().width,\n            k = c.getSlotWidth(this),\n            E = k,\n            B = 1,\n            m,\n            z = {};\n        if (b || \"justify\" !== t(h.overflow, \"justify\")) 0 > b && e - x * u < d ? m = Math.round(e / Math.cos(b * v) - d) : 0 < b && e + x * u > n && (m = Math.round((l - e) / Math.cos(b * v)));else if (l = e + (1 - x) * u, e - x * u < d ? E = a.x + E * (1 - x) - d : l > n && (E = n - a.x + E * x, B = -1), E = Math.min(k, E), E < k && \"center\" === c.labelAlign && (a.x += B * (k - E - x * (k - Math.min(u, E)))), u > E || c.autoRotation && (g.styles || {}).width) m = E;\n        m && (this.shortenLabel ? this.shortenLabel() : (z.width = Math.floor(m), (h.style || {}).textOverflow || (z.textOverflow = \"ellipsis\"), g.css(z)));\n      },\n      getPosition: function getPosition(c, r, h, e) {\n        var l = this.axis,\n            n = l.chart,\n            d = e && n.oldChartHeight || n.chartHeight;\n        c = {\n          x: c ? a.correctFloat(l.translate(r + h, null, null, e) + l.transB) : l.left + l.offset + (l.opposite ? (e && n.oldChartWidth || n.chartWidth) - l.right - l.left : 0),\n          y: c ? d - l.bottom + l.offset - (l.opposite ? l.height : 0) : a.correctFloat(d - l.translate(r + h, null, null, e) - l.transB)\n        };\n        k(this, \"afterGetPosition\", {\n          pos: c\n        });\n        return c;\n      },\n      getLabelPosition: function getLabelPosition(a, c, h, e, l, n, d, g) {\n        var b = this.axis,\n            x = b.transA,\n            u = b.reversed,\n            r = b.staggerLines,\n            E = b.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            B = l.y,\n            m = e || b.reserveSpaceDefault ? 0 : -b.labelOffset * (\"center\" === b.labelAlign ? .5 : 1),\n            z = {};\n        F(B) || (B = 0 === b.side ? h.rotation ? -8 : -h.getBBox().height : 2 === b.side ? E.y + 8 : Math.cos(h.rotation * v) * (E.y - h.getBBox(!1, 0).height / 2));\n        a = a + l.x + m + E.x - (n && e ? n * x * (u ? -1 : 1) : 0);\n        c = c + B - (n && !e ? n * x * (u ? 1 : -1) : 0);\n        r && (h = d / (g || 1) % r, b.opposite && (h = r - h - 1), c += b.labelOffset / r * h);\n        z.x = a;\n        z.y = Math.round(c);\n        k(this, \"afterGetLabelPosition\", {\n          pos: z,\n          tickmarkOffset: n,\n          index: d\n        });\n        return z;\n      },\n      getMarkPath: function getMarkPath(a, c, h, e, l, n) {\n        return n.crispLine([\"M\", a, c, \"L\", a + (l ? 0 : -h), c + (l ? h : 0)], e);\n      },\n      renderGridLine: function renderGridLine(a, c, h) {\n        var e = this.axis,\n            l = e.options,\n            n = this.gridLine,\n            d = {},\n            g = this.pos,\n            b = this.type,\n            x = t(this.tickmarkOffset, e.tickmarkOffset),\n            u = e.chart.renderer,\n            r = b ? b + \"Grid\" : \"grid\",\n            k = l[r + \"LineWidth\"],\n            B = l[r + \"LineColor\"],\n            l = l[r + \"LineDashStyle\"];\n        n || (e.chart.styledMode || (d.stroke = B, d[\"stroke-width\"] = k, l && (d.dashstyle = l)), b || (d.zIndex = 1), a && (c = 0), this.gridLine = n = u.path().attr(d).addClass(\"highcharts-\" + (b ? b + \"-\" : \"\") + \"grid-line\").add(e.gridGroup));\n        if (n && (h = e.getPlotLinePath(g + x, n.strokeWidth() * h, a, \"pass\"))) n[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: h,\n          opacity: c\n        });\n      },\n      renderMark: function renderMark(a, c, h) {\n        var e = this.axis,\n            l = e.options,\n            n = e.chart.renderer,\n            d = this.type,\n            g = d ? d + \"Tick\" : \"tick\",\n            b = e.tickSize(g),\n            x = this.mark,\n            u = !x,\n            r = a.x;\n        a = a.y;\n        var k = t(l[g + \"Width\"], !d && e.isXAxis ? 1 : 0),\n            l = l[g + \"Color\"];\n        b && (e.opposite && (b[0] = -b[0]), u && (this.mark = x = n.path().addClass(\"highcharts-\" + (d ? d + \"-\" : \"\") + \"tick\").add(e.axisGroup), e.chart.styledMode || x.attr({\n          stroke: l,\n          \"stroke-width\": k\n        })), x[u ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(r, a, b[0], x.strokeWidth() * h, e.horiz, n),\n          opacity: c\n        }));\n      },\n      renderLabel: function renderLabel(a, r, h, e) {\n        var l = this.axis,\n            n = l.horiz,\n            d = l.options,\n            g = this.label,\n            b = d.labels,\n            x = b.step,\n            l = t(this.tickmarkOffset, l.tickmarkOffset),\n            u = !0,\n            k = a.x;\n        a = a.y;\n        g && c(k) && (g.xy = a = this.getLabelPosition(k, a, g, n, b, l, e, x), this.isFirst && !this.isLast && !t(d.showFirstLabel, 1) || this.isLast && !this.isFirst && !t(d.showLastLabel, 1) ? u = !1 : !n || b.step || b.rotation || r || 0 === h || this.handleOverflow(a), x && e % x && (u = !1), u && c(a.y) ? (a.opacity = h, g[this.isNewLabel ? \"attr\" : \"animate\"](a), this.isNewLabel = !1) : (g.attr(\"y\", -9999), this.isNewLabel = !0));\n      },\n      render: function render(c, r, h) {\n        var e = this.axis,\n            l = e.horiz,\n            n = this.pos,\n            d = t(this.tickmarkOffset, e.tickmarkOffset),\n            n = this.getPosition(l, n, d, r),\n            d = n.x,\n            g = n.y,\n            e = l && d === e.pos + e.len || !l && g === e.pos ? -1 : 1;\n        h = t(h, 1);\n        this.isActive = !0;\n        this.renderGridLine(r, h, e);\n        this.renderMark(n, h, e);\n        this.renderLabel(n, r, h, c);\n        this.isNew = !1;\n        a.fireEvent(this, \"afterRender\");\n      },\n      destroy: function destroy() {\n        G(this, this.axis);\n      }\n    };\n  })(I);\n\n  var X = function (a) {\n    var y = a.addEvent,\n        F = a.animObject,\n        G = a.arrayMax,\n        k = a.arrayMin,\n        c = a.color,\n        p = a.correctFloat,\n        t = a.defaultOptions,\n        v = a.defined,\n        w = a.deg2rad,\n        r = a.destroyObjectProperties,\n        h = a.extend,\n        e = a.fireEvent,\n        l = a.format,\n        n = a.getMagnitude,\n        d = a.isArray,\n        g = a.isNumber,\n        b = a.isString,\n        x = a.merge,\n        u = a.normalizeTickInterval,\n        H = a.objectEach,\n        E = a.pick,\n        B = a.removeEvent,\n        m = a.splat,\n        z = a.syncTimeout,\n        D = a.Tick,\n        A = function A() {\n      this.init.apply(this, arguments);\n    };\n\n    a.extend(A.prototype, {\n      defaultOptions: {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      },\n      defaultYAxisOptions: {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          formatter: function formatter() {\n            return a.numberFormat(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      },\n      defaultLeftAxisOptions: {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      },\n      defaultRightAxisOptions: {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      },\n      defaultBottomAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      defaultTopAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      init: function init(a, q) {\n        var f = q.isX,\n            b = this;\n        b.chart = a;\n        b.horiz = a.inverted && !b.isZAxis ? !f : f;\n        b.isXAxis = f;\n        b.coll = b.coll || (f ? \"xAxis\" : \"yAxis\");\n        e(this, \"init\", {\n          userOptions: q\n        });\n        b.opposite = q.opposite;\n        b.side = q.side || (b.horiz ? b.opposite ? 0 : 2 : b.opposite ? 1 : 3);\n        b.setOptions(q);\n        var g = this.options,\n            d = g.type;\n        b.labelFormatter = g.labels.formatter || b.defaultLabelFormatter;\n        b.userOptions = q;\n        b.minPixelPadding = 0;\n        b.reversed = g.reversed;\n        b.visible = !1 !== g.visible;\n        b.zoomEnabled = !1 !== g.zoomEnabled;\n        b.hasNames = \"category\" === d || !0 === g.categories;\n        b.categories = g.categories || b.hasNames;\n        b.names || (b.names = [], b.names.keys = {});\n        b.plotLinesAndBandsGroups = {};\n        b.isLog = \"logarithmic\" === d;\n        b.isDatetimeAxis = \"datetime\" === d;\n        b.positiveValuesOnly = b.isLog && !b.allowNegativeLog;\n        b.isLinked = v(g.linkedTo);\n        b.ticks = {};\n        b.labelEdge = [];\n        b.minorTicks = {};\n        b.plotLinesAndBands = [];\n        b.alternateBands = {};\n        b.len = 0;\n        b.minRange = b.userMinRange = g.minRange || g.maxZoom;\n        b.range = g.range;\n        b.offset = g.offset || 0;\n        b.stacks = {};\n        b.oldStacks = {};\n        b.stacksTouched = 0;\n        b.max = null;\n        b.min = null;\n        b.crosshair = E(g.crosshair, m(a.options.tooltip.crosshairs)[f ? 0 : 1], !1);\n        q = b.options.events;\n        -1 === a.axes.indexOf(b) && (f ? a.axes.splice(a.xAxis.length, 0, b) : a.axes.push(b), a[b.coll].push(b));\n        b.series = b.series || [];\n        a.inverted && !b.isZAxis && f && void 0 === b.reversed && (b.reversed = !0);\n        H(q, function (a, f) {\n          y(b, f, a);\n        });\n        b.lin2log = g.linearToLogConverter || b.lin2log;\n        b.isLog && (b.val2lin = b.log2lin, b.lin2val = b.lin2log);\n        e(this, \"afterInit\");\n      },\n      setOptions: function setOptions(a) {\n        this.options = x(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], x(t[this.coll], a));\n        e(this, \"afterSetOptions\", {\n          userOptions: a\n        });\n      },\n      defaultLabelFormatter: function defaultLabelFormatter() {\n        var f = this.axis,\n            q = this.value,\n            b = f.chart.time,\n            g = f.categories,\n            d = this.dateTimeLabelFormat,\n            e = t.lang,\n            m = e.numericSymbols,\n            e = e.numericSymbolMagnitude || 1E3,\n            h = m && m.length,\n            n,\n            c = f.options.labels.format,\n            f = f.isLog ? Math.abs(q) : f.tickInterval;\n        if (c) n = l(c, this, b);else if (g) n = q;else if (d) n = b.dateFormat(d, q);else if (h && 1E3 <= f) for (; h-- && void 0 === n;) {\n          b = Math.pow(e, h + 1), f >= b && 0 === 10 * q % b && null !== m[h] && 0 !== q && (n = a.numberFormat(q / b, -1) + m[h]);\n        }\n        void 0 === n && (n = 1E4 <= Math.abs(q) ? a.numberFormat(q, -1) : a.numberFormat(q, -1, void 0, \"\"));\n        return n;\n      },\n      getSeriesExtremes: function getSeriesExtremes() {\n        var a = this,\n            q = a.chart;\n        e(this, \"getSeriesExtremes\", null, function () {\n          a.hasVisibleSeries = !1;\n          a.dataMin = a.dataMax = a.threshold = null;\n          a.softThreshold = !a.isXAxis;\n          a.buildStacks && a.buildStacks();\n          a.series.forEach(function (f) {\n            if (f.visible || !q.options.chart.ignoreHiddenSeries) {\n              var b = f.options,\n                  d = b.threshold,\n                  e;\n              a.hasVisibleSeries = !0;\n              a.positiveValuesOnly && 0 >= d && (d = null);\n              if (a.isXAxis) b = f.xData, b.length && (f = k(b), e = G(b), g(f) || f instanceof Date || (b = b.filter(g), f = k(b), e = G(b)), b.length && (a.dataMin = Math.min(E(a.dataMin, b[0], f), f), a.dataMax = Math.max(E(a.dataMax, b[0], e), e)));else if (f.getExtremes(), e = f.dataMax, f = f.dataMin, v(f) && v(e) && (a.dataMin = Math.min(E(a.dataMin, f), f), a.dataMax = Math.max(E(a.dataMax, e), e)), v(d) && (a.threshold = d), !b.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n            }\n          });\n        });\n        e(this, \"afterGetSeriesExtremes\");\n      },\n      translate: function translate(a, q, b, d, e, m) {\n        var f = this.linkedParent || this,\n            h = 1,\n            n = 0,\n            c = d ? f.oldTransA : f.transA;\n        d = d ? f.oldMin : f.min;\n        var u = f.minPixelPadding;\n        e = (f.isOrdinal || f.isBroken || f.isLog && e) && f.lin2val;\n        c || (c = f.transA);\n        b && (h *= -1, n = f.len);\n        f.reversed && (h *= -1, n -= h * (f.sector || f.len));\n        q ? (a = (a * h + n - u) / c + d, e && (a = f.lin2val(a))) : (e && (a = f.val2lin(a)), a = g(d) ? h * (a - d) * c + n + h * u + (g(m) ? c * m : 0) : void 0);\n        return a;\n      },\n      toPixels: function toPixels(a, q) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (q ? 0 : this.pos);\n      },\n      toValue: function toValue(a, q) {\n        return this.translate(a - (q ? 0 : this.pos), !0, !this.horiz, null, !0);\n      },\n      getPlotLinePath: function getPlotLinePath(a, q, b, d, m) {\n        var f = this,\n            h = f.chart,\n            n = f.left,\n            c = f.top,\n            u,\n            l,\n            z,\n            x,\n            D = b && h.oldChartHeight || h.chartHeight,\n            r = b && h.oldChartWidth || h.chartWidth,\n            k,\n            L = f.transB,\n            A,\n            B = function B(a, f, q) {\n          if (\"pass\" !== d && a < f || a > q) d ? a = Math.min(Math.max(f, a), q) : k = !0;\n          return a;\n        };\n\n        A = {\n          value: a,\n          lineWidth: q,\n          old: b,\n          force: d,\n          translatedValue: m\n        };\n        e(this, \"getPlotLinePath\", A, function (e) {\n          m = E(m, f.translate(a, null, null, b));\n          m = Math.min(Math.max(-1E5, m), 1E5);\n          u = z = Math.round(m + L);\n          l = x = Math.round(D - m - L);\n          g(m) ? f.horiz ? (l = c, x = D - f.bottom, u = z = B(u, n, n + f.width)) : (u = n, z = r - f.right, l = x = B(l, c, c + f.height)) : (k = !0, d = !1);\n          e.path = k && !d ? null : h.renderer.crispLine([\"M\", u, l, \"L\", z, x], q || 1);\n        });\n        return A.path;\n      },\n      getLinearTickPositions: function getLinearTickPositions(a, q, b) {\n        var f,\n            g = p(Math.floor(q / a) * a);\n        b = p(Math.ceil(b / a) * a);\n        var d = [],\n            e;\n        p(g + a) === g && (e = 20);\n        if (this.single) return [q];\n\n        for (q = g; q <= b;) {\n          d.push(q);\n          q = p(q + a, e);\n          if (q === f) break;\n          f = q;\n        }\n\n        return d;\n      },\n      getMinorTickInterval: function getMinorTickInterval() {\n        var a = this.options;\n        return !0 === a.minorTicks ? E(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      },\n      getMinorTickPositions: function getMinorTickPositions() {\n        var a = this,\n            q = a.options,\n            b = a.tickPositions,\n            g = a.minorTickInterval,\n            d = [],\n            e = a.pointRangePadding || 0,\n            m = a.min - e,\n            e = a.max + e,\n            h = e - m;\n        if (h && h / g < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function (f, q, b) {\n          q && d.push.apply(d, a.getLogTickPositions(g, b[q - 1], b[q], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === this.getMinorTickInterval()) d = d.concat(a.getTimeTicks(a.normalizeTimeTickInterval(g), m, e, q.startOfWeek));else for (q = m + (b[0] - m) % g; q <= e && q !== d[0]; q += g) {\n          d.push(q);\n        }\n        0 !== d.length && a.trimTicks(d);\n        return d;\n      },\n      adjustForMinRange: function adjustForMinRange() {\n        var a = this.options,\n            q = this.min,\n            b = this.max,\n            g,\n            d,\n            e,\n            m,\n            h,\n            n,\n            c,\n            u;\n        this.isXAxis && void 0 === this.minRange && !this.isLog && (v(a.min) || v(a.max) ? this.minRange = null : (this.series.forEach(function (a) {\n          n = a.xData;\n\n          for (m = c = a.xIncrement ? 1 : n.length - 1; 0 < m; m--) {\n            if (h = n[m] - n[m - 1], void 0 === e || h < e) e = h;\n          }\n        }), this.minRange = Math.min(5 * e, this.dataMax - this.dataMin)));\n        b - q < this.minRange && (d = this.dataMax - this.dataMin >= this.minRange, u = this.minRange, g = (u - b + q) / 2, g = [q - g, E(a.min, q - g)], d && (g[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), q = G(g), b = [q + u, E(a.max, q + u)], d && (b[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), b = k(b), b - q < u && (g[0] = b - u, g[1] = E(a.min, b - u), q = G(g)));\n        this.min = q;\n        this.max = b;\n      },\n      getClosest: function getClosest() {\n        var a;\n        this.categories ? a = 1 : this.series.forEach(function (f) {\n          var q = f.closestPointRange,\n              b = f.visible || !f.chart.options.chart.ignoreHiddenSeries;\n          !f.noSharedTooltip && v(q) && b && (a = v(a) ? Math.min(a, q) : q);\n        });\n        return a;\n      },\n      nameToX: function nameToX(a) {\n        var f = d(this.categories),\n            b = f ? this.categories : this.names,\n            g = a.options.x,\n            e;\n        a.series.requireSorting = !1;\n        v(g) || (g = !1 === this.options.uniqueNames ? a.series.autoIncrement() : f ? b.indexOf(a.name) : E(b.keys[a.name], -1));\n        -1 === g ? f || (e = b.length) : e = g;\n        void 0 !== e && (this.names[e] = a.name, this.names.keys[a.name] = e);\n        return e;\n      },\n      updateNames: function updateNames() {\n        var a = this,\n            q = this.names;\n        0 < q.length && (Object.keys(q.keys).forEach(function (a) {\n          delete q.keys[a];\n        }), q.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (f) {\n          f.xIncrement = null;\n          if (!f.points || f.isDirtyData) a.max = Math.max(a.max, f.xData.length - 1), f.processData(), f.generatePoints();\n          f.data.forEach(function (q, b) {\n            var g;\n            q && q.options && void 0 !== q.name && (g = a.nameToX(q), void 0 !== g && g !== q.x && (q.x = g, f.xData[b] = g));\n          });\n        }));\n      },\n      setAxisTranslation: function setAxisTranslation(a) {\n        var f = this,\n            g = f.max - f.min,\n            d = f.axisPointRange || 0,\n            m,\n            h = 0,\n            n = 0,\n            c = f.linkedParent,\n            u = !!f.categories,\n            l = f.transA,\n            z = f.isXAxis;\n        if (z || u || d) m = f.getClosest(), c ? (h = c.minPointOffset, n = c.pointRangePadding) : f.series.forEach(function (a) {\n          var q = u ? 1 : z ? E(a.options.pointRange, m, 0) : f.axisPointRange || 0;\n          a = a.options.pointPlacement;\n          d = Math.max(d, q);\n          f.single || (h = Math.max(h, z && b(a) ? 0 : q / 2), n = Math.max(n, z && \"on\" === a ? 0 : q));\n        }), c = f.ordinalSlope && m ? f.ordinalSlope / m : 1, f.minPointOffset = h *= c, f.pointRangePadding = n *= c, f.pointRange = Math.min(d, g), z && (f.closestPointRange = m);\n        a && (f.oldTransA = l);\n        f.translationSlope = f.transA = l = f.staticScale || f.len / (g + n || 1);\n        f.transB = f.horiz ? f.left : f.bottom;\n        f.minPixelPadding = l * h;\n        e(this, \"afterSetAxisTranslation\");\n      },\n      minFromRange: function minFromRange() {\n        return this.max - this.range;\n      },\n      setTickInterval: function setTickInterval(f) {\n        var b = this,\n            d = b.chart,\n            m = b.options,\n            h = b.isLog,\n            c = b.isDatetimeAxis,\n            l = b.isXAxis,\n            z = b.isLinked,\n            x = m.maxPadding,\n            D = m.minPadding,\n            r,\n            k = m.tickInterval,\n            A = m.tickPixelInterval,\n            B = b.categories,\n            H = g(b.threshold) ? b.threshold : null,\n            w = b.softThreshold,\n            t,\n            y,\n            G;\n        c || B || z || this.getTickAmount();\n        y = E(b.userMin, m.min);\n        G = E(b.userMax, m.max);\n        z ? (b.linkedParent = d[b.coll][m.linkedTo], r = b.linkedParent.getExtremes(), b.min = E(r.min, r.dataMin), b.max = E(r.max, r.dataMax), m.type !== b.linkedParent.options.type && a.error(11, 1, d)) : (!w && v(H) && (b.dataMin >= H ? (r = H, D = 0) : b.dataMax <= H && (t = H, x = 0)), b.min = E(y, r, b.dataMin), b.max = E(G, t, b.dataMax));\n        h && (b.positiveValuesOnly && !f && 0 >= Math.min(b.min, E(b.dataMin, b.min)) && a.error(10, 1, d), b.min = p(b.log2lin(b.min), 15), b.max = p(b.log2lin(b.max), 15));\n        b.range && v(b.max) && (b.userMin = b.min = y = Math.max(b.dataMin, b.minFromRange()), b.userMax = G = b.max, b.range = null);\n        e(b, \"foundExtremes\");\n        b.beforePadding && b.beforePadding();\n        b.adjustForMinRange();\n        !(B || b.axisPointRange || b.usePercentage || z) && v(b.min) && v(b.max) && (d = b.max - b.min) && (!v(y) && D && (b.min -= d * D), !v(G) && x && (b.max += d * x));\n        g(m.softMin) && !g(b.userMin) && (b.min = Math.min(b.min, m.softMin));\n        g(m.softMax) && !g(b.userMax) && (b.max = Math.max(b.max, m.softMax));\n        g(m.floor) && (b.min = Math.min(Math.max(b.min, m.floor), Number.MAX_VALUE));\n        g(m.ceiling) && (b.max = Math.max(Math.min(b.max, m.ceiling), E(b.userMax, -Number.MAX_VALUE)));\n        w && v(b.dataMin) && (H = H || 0, !v(y) && b.min < H && b.dataMin >= H ? b.min = H : !v(G) && b.max > H && b.dataMax <= H && (b.max = H));\n        b.tickInterval = b.min === b.max || void 0 === b.min || void 0 === b.max ? 1 : z && !k && A === b.linkedParent.options.tickPixelInterval ? k = b.linkedParent.tickInterval : E(k, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, B ? 1 : (b.max - b.min) * A / Math.max(b.len, A));\n        l && !f && b.series.forEach(function (a) {\n          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);\n        });\n        b.setAxisTranslation(!0);\n        b.beforeSetTickPositions && b.beforeSetTickPositions();\n        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));\n        b.pointRange && !k && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));\n        f = E(m.minTickInterval, b.isDatetimeAxis && b.closestPointRange);\n        !k && b.tickInterval < f && (b.tickInterval = f);\n        c || h || k || (b.tickInterval = u(b.tickInterval, null, n(b.tickInterval), E(m.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));\n        this.tickAmount || (b.tickInterval = b.unsquish());\n        this.setTickPositions();\n      },\n      setTickPositions: function setTickPositions() {\n        var f = this.options,\n            b,\n            g = f.tickPositions;\n        b = this.getMinorTickInterval();\n        var d = f.tickPositioner,\n            m = f.startOnTick,\n            h = f.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === f.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === b && this.tickInterval ? this.tickInterval / 5 : b;\n        this.single = this.min === this.max && v(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== f.allowDecimals);\n        this.tickPositions = b = g && g.slice();\n        !b && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (b = [this.min, this.max], a.error(19, !1, this.chart)) : b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, f.units), this.min, this.max, f.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()], b[0] === b[1] && (b.length = 1)), this.tickPositions = b, d && (d = d.apply(this, [this.min, this.max]))) && (this.tickPositions = b = d);\n        this.paddedTicks = b.slice(0);\n        this.trimTicks(b, m, h);\n        this.isLinked || (this.single && 2 > b.length && (this.min -= .5, this.max += .5), g || d || this.adjustTickAmount());\n        e(this, \"afterSetTickPositions\");\n      },\n      trimTicks: function trimTicks(a, b, g) {\n        var f = a[0],\n            d = a[a.length - 1],\n            q = this.minPointOffset || 0;\n        e(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (b && -Infinity !== f) this.min = f;else for (; this.min - q > a[0];) {\n            a.shift();\n          }\n          if (g) this.max = d;else for (; this.max + q < a[a.length - 1];) {\n            a.pop();\n          }\n          0 === a.length && v(f) && !this.options.tickPositions && a.push((d + f) / 2);\n        }\n      },\n      alignToOthers: function alignToOthers() {\n        var a = {},\n            b,\n            g = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === g.alignTicks || !1 === g.startOnTick || !1 === g.endOnTick || this.isLog || this.chart[this.coll].forEach(function (f) {\n          var g = f.options,\n              g = [f.horiz ? g.left : g.top, g.width, g.height, g.pane].join();\n          f.series.length && (a[g] ? b = !0 : a[g] = 1);\n        });\n        return b;\n      },\n      getTickAmount: function getTickAmount() {\n        var a = this.options,\n            b = a.tickAmount,\n            g = a.tickPixelInterval;\n        !v(a.tickInterval) && this.len < g && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);\n        !b && this.alignToOthers() && (b = Math.ceil(this.len / g) + 1);\n        4 > b && (this.finalTickAmt = b, b = 5);\n        this.tickAmount = b;\n      },\n      adjustTickAmount: function adjustTickAmount() {\n        var a = this.options,\n            b = this.tickInterval,\n            g = this.tickPositions,\n            d = this.tickAmount,\n            e = this.finalTickAmt,\n            m = g && g.length,\n            h = E(this.threshold, this.softThreshold ? 0 : null),\n            n;\n\n        if (this.hasData()) {\n          if (m < d) {\n            for (n = this.min; g.length < d;) {\n              g.length % 2 || n === h ? g.push(p(g[g.length - 1] + b)) : g.unshift(p(g[0] - b));\n            }\n\n            this.transA *= (m - 1) / (d - 1);\n            this.min = a.startOnTick ? g[0] : Math.min(this.min, g[0]);\n            this.max = a.endOnTick ? g[g.length - 1] : Math.max(this.max, g[g.length - 1]);\n          } else m > d && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (v(e)) {\n            for (b = a = g.length; b--;) {\n              (3 === e && 1 === b % 2 || 2 >= e && 0 < b && b < a - 1) && g.splice(b, 1);\n            }\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      },\n      setScale: function setScale() {\n        var a = this.series.some(function (a) {\n          return a.isDirtyData || a.isDirty || a.xAxis.isDirty;\n        }),\n            b;\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        (b = this.len !== this.oldAxisLength) || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();\n        e(this, \"afterSetScale\");\n      },\n      setExtremes: function setExtremes(a, b, g, d, m) {\n        var f = this,\n            q = f.chart;\n        g = E(g, !0);\n        f.series.forEach(function (a) {\n          delete a.kdTree;\n        });\n        m = h(m, {\n          min: a,\n          max: b\n        });\n        e(f, \"setExtremes\", m, function () {\n          f.userMin = a;\n          f.userMax = b;\n          f.eventArgs = m;\n          g && q.redraw(d);\n        });\n      },\n      zoom: function zoom(a, b) {\n        var f = this.dataMin,\n            g = this.dataMax,\n            d = this.options,\n            q = Math.min(f, E(d.min, f)),\n            m = Math.max(g, E(d.max, g));\n        a = {\n          newMin: a,\n          newMax: b\n        };\n        e(this, \"zoom\", a, function (a) {\n          var b = a.newMin,\n              d = a.newMax;\n          if (b !== this.min || d !== this.max) this.allowZoomOutside || (v(f) && (b < q && (b = q), b > m && (b = m)), v(g) && (d < q && (d = q), d > m && (d = m))), this.displayBtn = void 0 !== b || void 0 !== d, this.setExtremes(b, d, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          a.zoomed = !0;\n        });\n        return a.zoomed;\n      },\n      setAxisSize: function setAxisSize() {\n        var f = this.chart,\n            b = this.options,\n            g = b.offsets || [0, 0, 0, 0],\n            d = this.horiz,\n            e = this.width = Math.round(a.relativeLength(E(b.width, f.plotWidth - g[3] + g[1]), f.plotWidth)),\n            m = this.height = Math.round(a.relativeLength(E(b.height, f.plotHeight - g[0] + g[2]), f.plotHeight)),\n            h = this.top = Math.round(a.relativeLength(E(b.top, f.plotTop + g[0]), f.plotHeight, f.plotTop)),\n            b = this.left = Math.round(a.relativeLength(E(b.left, f.plotLeft + g[3]), f.plotWidth, f.plotLeft));\n        this.bottom = f.chartHeight - m - h;\n        this.right = f.chartWidth - e - b;\n        this.len = Math.max(d ? e : m, 0);\n        this.pos = d ? b : h;\n      },\n      getExtremes: function getExtremes() {\n        var a = this.isLog;\n        return {\n          min: a ? p(this.lin2log(this.min)) : this.min,\n          max: a ? p(this.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      },\n      getThreshold: function getThreshold(a) {\n        var f = this.isLog,\n            b = f ? this.lin2log(this.min) : this.min,\n            f = f ? this.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = b : Infinity === a ? a = f : b > a ? a = b : f < a && (a = f);\n        return this.translate(a, 0, 1, 0, 1);\n      },\n      autoLabelAlign: function autoLabelAlign(a) {\n        var f = (E(a, 0) - 90 * this.side + 720) % 360;\n        a = {\n          align: \"center\"\n        };\n        e(this, \"autoLabelAlign\", a, function (a) {\n          15 < f && 165 > f ? a.align = \"right\" : 195 < f && 345 > f && (a.align = \"left\");\n        });\n        return a.align;\n      },\n      tickSize: function tickSize(a) {\n        var f = this.options,\n            b = f[a + \"Length\"],\n            g = E(f[a + \"Width\"], \"tick\" === a && this.isXAxis ? 1 : 0),\n            d;\n        g && b && (\"inside\" === f[a + \"Position\"] && (b = -b), d = [b, g]);\n        a = {\n          tickSize: d\n        };\n        e(this, \"afterTickSize\", a);\n        return a.tickSize;\n      },\n      labelMetrics: function labelMetrics() {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      },\n      unsquish: function unsquish() {\n        var a = this.options.labels,\n            b = this.horiz,\n            g = this.tickInterval,\n            d = g,\n            e = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / g),\n            m,\n            h = a.rotation,\n            n = this.labelMetrics(),\n            c,\n            u = Number.MAX_VALUE,\n            z,\n            l = this.max - this.min,\n            x = function x(a) {\n          var f = a / (e || 1),\n              f = 1 < f ? Math.ceil(f) : 1;\n          f * g > l && Infinity !== a && Infinity !== e && (f = Math.ceil(l / g));\n          return p(f * g);\n        };\n\n        b ? (z = !a.staggerLines && !a.step && (v(h) ? [h] : e < E(a.autoRotationLimit, 80) && a.autoRotation)) && z.forEach(function (a) {\n          var f;\n          if (a === h || a && -90 <= a && 90 >= a) c = x(Math.abs(n.h / Math.sin(w * a))), f = c + Math.abs(a / 360), f < u && (u = f, m = a, d = c);\n        }) : a.step || (d = x(n.h));\n        this.autoRotation = z;\n        this.labelRotation = E(m, h);\n        return d;\n      },\n      getSlotWidth: function getSlotWidth(a) {\n        var f = this.chart,\n            b = this.horiz,\n            g = this.options.labels,\n            d = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            e = f.margin[3];\n        return a && a.slotWidth || b && 2 > (g.step || 0) && !g.rotation && (this.staggerLines || 1) * this.len / d || !b && (g.style && parseInt(g.style.width, 10) || e && e - f.spacing[3] || .33 * f.chartWidth);\n      },\n      renderUnsquish: function renderUnsquish() {\n        var a = this.chart,\n            g = a.renderer,\n            d = this.tickPositions,\n            e = this.ticks,\n            m = this.options.labels,\n            h = m && m.style || {},\n            n = this.horiz,\n            c = this.getSlotWidth(),\n            u = Math.max(1, Math.round(c - 2 * (m.padding || 5))),\n            z = {},\n            l = this.labelMetrics(),\n            x = m.style && m.style.textOverflow,\n            D,\n            r,\n            k = 0,\n            A;\n        b(m.rotation) || (z.rotation = m.rotation || 0);\n        d.forEach(function (a) {\n          (a = e[a]) && a.label && a.label.textPxLength > k && (k = a.label.textPxLength);\n        });\n        this.maxLabelLength = k;\n        if (this.autoRotation) k > u && k > l.h ? z.rotation = this.labelRotation : this.labelRotation = 0;else if (c && (D = u, !x)) for (r = \"clip\", u = d.length; !n && u--;) {\n          if (A = d[u], A = e[A].label) A.styles && \"ellipsis\" === A.styles.textOverflow ? A.css({\n            textOverflow: \"clip\"\n          }) : A.textPxLength > c && A.css({\n            width: c + \"px\"\n          }), A.getBBox().height > this.len / d.length - (l.h - l.f) && (A.specificTextOverflow = \"ellipsis\");\n        }\n        z.rotation && (D = k > .5 * a.chartHeight ? .33 * a.chartHeight : k, x || (r = \"ellipsis\"));\n        if (this.labelAlign = m.align || this.autoLabelAlign(this.labelRotation)) z.align = this.labelAlign;\n        d.forEach(function (a) {\n          var f = (a = e[a]) && a.label,\n              b = h.width,\n              g = {};\n          f && (f.attr(z), a.shortenLabel ? a.shortenLabel() : D && !b && \"nowrap\" !== h.whiteSpace && (D < f.textPxLength || \"SPAN\" === f.element.tagName) ? (g.width = D, x || (g.textOverflow = f.specificTextOverflow || r), f.css(g)) : f.styles && f.styles.width && !g.width && !b && f.css({\n            width: null\n          }), delete f.specificTextOverflow, a.rotation = z.rotation);\n        }, this);\n        this.tickRotCorr = g.rotCorr(l.b, this.labelRotation || 0, 0 !== this.side);\n      },\n      hasData: function hasData() {\n        return this.hasVisibleSeries || v(this.min) && v(this.max) && this.tickPositions && 0 < this.tickPositions.length;\n      },\n      addTitle: function addTitle(a) {\n        var f = this.chart.renderer,\n            b = this.horiz,\n            g = this.opposite,\n            d = this.options.title,\n            e,\n            m = this.chart.styledMode;\n        this.axisTitle || ((e = d.textAlign) || (e = (b ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: g ? \"right\" : \"left\",\n          middle: \"center\",\n          high: g ? \"left\" : \"right\"\n        })[d.align]), this.axisTitle = f.text(d.text, 0, 0, d.useHTML).attr({\n          zIndex: 7,\n          rotation: d.rotation || 0,\n          align: e\n        }).addClass(\"highcharts-axis-title\"), m || this.axisTitle.css(x(d.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        m || d.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](!0);\n      },\n      generateTick: function generateTick(a) {\n        var f = this.ticks;\n        f[a] ? f[a].addLabel() : f[a] = new D(this, a);\n      },\n      getOffset: function getOffset() {\n        var a = this,\n            b = a.chart,\n            g = b.renderer,\n            d = a.options,\n            m = a.tickPositions,\n            h = a.ticks,\n            n = a.horiz,\n            c = a.side,\n            u = b.inverted && !a.isZAxis ? [1, 0, 3, 2][c] : c,\n            z,\n            l,\n            x = 0,\n            D,\n            r = 0,\n            k = d.title,\n            A = d.labels,\n            B = 0,\n            p = b.axisOffset,\n            b = b.clipOffset,\n            w = [-1, 1, 1, -1][c],\n            t = d.className,\n            y = a.axisParent;\n        z = a.hasData();\n        a.showAxis = l = z || E(d.showEmpty, !0);\n        a.staggerLines = a.horiz && A.staggerLines;\n        a.axisGroup || (a.gridGroup = g.g(\"grid\").attr({\n          zIndex: d.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (t || \"\")).add(y), a.axisGroup = g.g(\"axis\").attr({\n          zIndex: d.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (t || \"\")).add(y), a.labelGroup = g.g(\"axis-labels\").attr({\n          zIndex: A.zIndex || 7\n        }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (t || \"\")).add(y));\n        z || a.isLinked ? (m.forEach(function (b, f) {\n          a.generateTick(b, f);\n        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === c || 2 === c || {\n          1: \"left\",\n          3: \"right\"\n        }[c] === a.labelAlign, E(A.reserveSpace, \"center\" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && m.forEach(function (a) {\n          B = Math.max(h[a].getLabelSize(), B);\n        }), a.staggerLines && (B *= a.staggerLines), a.labelOffset = B * (a.opposite ? -1 : 1)) : H(h, function (a, b) {\n          a.destroy();\n          delete h[b];\n        });\n        k && k.text && !1 !== k.enabled && (a.addTitle(l), l && !1 !== k.reserveSpace && (a.titleOffset = x = a.axisTitle.getBBox()[n ? \"height\" : \"width\"], D = k.offset, r = v(D) ? 0 : E(k.margin, n ? 5 : 10)));\n        a.renderLine();\n        a.offset = w * E(d.offset, p[c] ? p[c] + (d.margin || 0) : 0);\n        a.tickRotCorr = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        g = 0 === c ? -a.labelMetrics().h : 2 === c ? a.tickRotCorr.y : 0;\n        r = Math.abs(B) + r;\n        B && (r = r - g + w * (n ? E(A.y, a.tickRotCorr.y + 8 * w) : A.x));\n        a.axisTitleMargin = E(D, r);\n        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(h, m));\n        n = this.tickSize(\"tick\");\n        p[c] = Math.max(p[c], a.axisTitleMargin + x + w * a.offset, r, z && m.length && n ? n[0] + w * a.offset : 0);\n        d = d.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n        b[u] = Math.max(b[u], d);\n        e(this, \"afterGetOffset\");\n      },\n      getLinePath: function getLinePath(a) {\n        var b = this.chart,\n            f = this.opposite,\n            g = this.offset,\n            d = this.horiz,\n            e = this.left + (f ? this.width : 0) + g,\n            g = b.chartHeight - this.bottom - (f ? this.height : 0) + g;\n        f && (a *= -1);\n        return b.renderer.crispLine([\"M\", d ? this.left : e, d ? g : this.top, \"L\", d ? b.chartWidth - this.right : e, d ? g : b.chartHeight - this.bottom], a);\n      },\n      renderLine: function renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      },\n      getTitlePosition: function getTitlePosition() {\n        var a = this.horiz,\n            b = this.left,\n            g = this.top,\n            d = this.len,\n            m = this.options.title,\n            h = a ? b : g,\n            n = this.opposite,\n            c = this.offset,\n            u = m.x || 0,\n            z = m.y || 0,\n            l = this.axisTitle,\n            x = this.chart.renderer.fontMetrics(m.style && m.style.fontSize, l),\n            l = Math.max(l.getBBox(null, 0).height - x.h - 1, 0),\n            d = {\n          low: h + (a ? 0 : d),\n          middle: h + d / 2,\n          high: h + (a ? d : 0)\n        }[m.align],\n            b = (a ? g + this.height : b) + (a ? 1 : -1) * (n ? -1 : 1) * this.axisTitleMargin + [-l, l, x.f, -l][this.side],\n            a = {\n          x: a ? d + u : b + (n ? this.width : 0) + c + u,\n          y: a ? b + z - (n ? this.height : 0) + c : d + z\n        };\n        e(this, \"afterGetTitlePosition\", {\n          titlePosition: a\n        });\n        return a;\n      },\n      renderMinorTick: function renderMinorTick(a) {\n        var b = this.chart.hasRendered && g(this.oldMin),\n            f = this.minorTicks;\n        f[a] || (f[a] = new D(this, a, \"minor\"));\n        b && f[a].isNew && f[a].render(null, !0);\n        f[a].render(null, !1, 1);\n      },\n      renderTick: function renderTick(a, b) {\n        var f = this.isLinked,\n            d = this.ticks,\n            e = this.chart.hasRendered && g(this.oldMin);\n        if (!f || a >= this.min && a <= this.max) d[a] || (d[a] = new D(this, a)), e && d[a].isNew && d[a].render(b, !0, -1), d[a].render(b);\n      },\n      render: function render() {\n        var b = this,\n            d = b.chart,\n            m = b.options,\n            h = b.isLog,\n            n = b.isLinked,\n            c = b.tickPositions,\n            u = b.axisTitle,\n            l = b.ticks,\n            x = b.minorTicks,\n            r = b.alternateBands,\n            k = m.stackLabels,\n            A = m.alternateGridColor,\n            B = b.tickmarkOffset,\n            E = b.axisLine,\n            p = b.showAxis,\n            w = F(d.renderer.globalAnimation),\n            t,\n            v;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        [l, x, r].forEach(function (a) {\n          H(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n        if (b.hasData() || n) b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (a) {\n          b.renderMinorTick(a);\n        }), c.length && (c.forEach(function (a, f) {\n          b.renderTick(a, f);\n        }), B && (0 === b.min || b.single) && (l[-1] || (l[-1] = new D(b, -1, null, !0)), l[-1].render(-1))), A && c.forEach(function (f, g) {\n          v = void 0 !== c[g + 1] ? c[g + 1] + B : b.max - B;\n          0 === g % 2 && f < b.max && v <= b.max + (d.polar ? -B : B) && (r[f] || (r[f] = new a.PlotLineOrBand(b)), t = f + B, r[f].options = {\n            from: h ? b.lin2log(t) : t,\n            to: h ? b.lin2log(v) : v,\n            color: A\n          }, r[f].render(), r[f].isActive = !0);\n        }), b._addedPlotLB || ((m.plotLines || []).concat(m.plotBands || []).forEach(function (a) {\n          b.addPlotBandOrLine(a);\n        }), b._addedPlotLB = !0);\n        [l, x, r].forEach(function (a) {\n          var b,\n              f = [],\n              g = w.duration;\n          H(a, function (a, b) {\n            a.isActive || (a.render(b, !1, 0), a.isActive = !1, f.push(b));\n          });\n          z(function () {\n            for (b = f.length; b--;) {\n              a[f[b]] && !a[f[b]].isActive && (a[f[b]].destroy(), delete a[f[b]]);\n            }\n          }, a !== r && d.hasRendered && g ? g : 0);\n        });\n        E && (E[E.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(E.strokeWidth())\n        }), E.isPlaced = !0, E[p ? \"show\" : \"hide\"](!0));\n        u && p && (m = b.getTitlePosition(), g(m.y) ? (u[u.isNew ? \"attr\" : \"animate\"](m), u.isNew = !1) : (u.attr(\"y\", -9999), u.isNew = !0));\n        k && k.enabled && b.renderStackTotals();\n        b.isDirty = !1;\n        e(this, \"afterRender\");\n      },\n      redraw: function redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {\n          a.render();\n        }));\n        this.series.forEach(function (a) {\n          a.isDirty = !0;\n        });\n      },\n      keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n      destroy: function destroy(a) {\n        var b = this,\n            f = b.stacks,\n            g = b.plotLinesAndBands,\n            d;\n        e(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || B(b);\n        H(f, function (a, b) {\n          r(a);\n          f[b] = null;\n        });\n        [b.ticks, b.minorTicks, b.alternateBands].forEach(function (a) {\n          r(a);\n        });\n        if (g) for (a = g.length; a--;) {\n          g[a].destroy();\n        }\n        \"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (a) {\n          b[a] && (b[a] = b[a].destroy());\n        });\n\n        for (d in b.plotLinesAndBandsGroups) {\n          b.plotLinesAndBandsGroups[d] = b.plotLinesAndBandsGroups[d].destroy();\n        }\n\n        H(b, function (a, f) {\n          -1 === b.keepProps.indexOf(f) && delete b[f];\n        });\n      },\n      drawCrosshair: function drawCrosshair(a, b) {\n        var f,\n            g = this.crosshair,\n            d = E(g.snap, !0),\n            m,\n            h = this.cross;\n        e(this, \"drawCrosshair\", {\n          e: a,\n          point: b\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (v(b) || !d)) {\n          d ? v(b) && (m = E(b.crosshairPos, this.isXAxis ? b.plotX : this.len - b.plotY)) : m = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n          v(m) && (f = this.getPlotLinePath(b && (this.isXAxis ? b.x : E(b.stackY, b.y)), null, null, null, m) || null);\n\n          if (!v(f)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          d = this.categories && !this.isRadial;\n          h || (this.cross = h = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (d ? \"category \" : \"thin \") + g.className).attr({\n            zIndex: E(g.zIndex, 2)\n          }).add(), this.chart.styledMode || (h.attr({\n            stroke: g.color || (d ? c(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": E(g.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), g.dashStyle && h.attr({\n            dashstyle: g.dashStyle\n          })));\n          h.show().attr({\n            d: f\n          });\n          d && !g.width && h.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        e(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: b\n        });\n      },\n      hideCrosshair: function hideCrosshair() {\n        this.cross && this.cross.hide();\n        e(this, \"afterHideCrosshair\");\n      }\n    });\n    return a.Axis = A;\n  }(I);\n\n  (function (a) {\n    var y = a.Axis,\n        F = a.getMagnitude,\n        G = a.normalizeTickInterval,\n        k = a.timeUnits;\n\n    y.prototype.getTimeTicks = function () {\n      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    };\n\n    y.prototype.normalizeTimeTickInterval = function (a, p) {\n      var c = p || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n      p = c[c.length - 1];\n      var v = k[p[0]],\n          w = p[1],\n          r;\n\n      for (r = 0; r < c.length && !(p = c[r], v = k[p[0]], w = p[1], c[r + 1] && a <= (v * w[w.length - 1] + k[c[r + 1][0]]) / 2); r++) {\n        ;\n      }\n\n      v === k.year && a < 5 * v && (w = [1, 2, 5]);\n      a = G(a / v, w, \"year\" === p[0] ? Math.max(F(a / v), 1) : 1);\n      return {\n        unitRange: v,\n        count: a,\n        unitName: p[0]\n      };\n    };\n  })(I);\n\n  (function (a) {\n    var y = a.Axis,\n        F = a.getMagnitude,\n        G = a.normalizeTickInterval,\n        k = a.pick;\n\n    y.prototype.getLogTickPositions = function (a, p, t, v) {\n      var c = this.options,\n          r = this.len,\n          h = [];\n      v || (this._minorAutoInterval = null);\n      if (.5 <= a) a = Math.round(a), h = this.getLinearTickPositions(a, p, t);else if (.08 <= a) for (var r = Math.floor(p), e, l, n, d, g, c = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; r < t + 1 && !g; r++) {\n        for (l = c.length, e = 0; e < l && !g; e++) {\n          n = this.log2lin(this.lin2log(r) * c[e]), n > p && (!v || d <= t) && void 0 !== d && h.push(d), d > t && (g = !0), d = n;\n        }\n      } else p = this.lin2log(p), t = this.lin2log(t), a = v ? this.getMinorTickInterval() : c.tickInterval, a = k(\"auto\" === a ? null : a, this._minorAutoInterval, c.tickPixelInterval / (v ? 5 : 1) * (t - p) / ((v ? r / this.tickPositions.length : r) || 1)), a = G(a, null, F(a)), h = this.getLinearTickPositions(a, p, t).map(this.log2lin), v || (this._minorAutoInterval = a / 5);\n      v || (this.tickInterval = a);\n      return h;\n    };\n\n    y.prototype.log2lin = function (a) {\n      return Math.log(a) / Math.LN10;\n    };\n\n    y.prototype.lin2log = function (a) {\n      return Math.pow(10, a);\n    };\n  })(I);\n\n  (function (a, y) {\n    var F = a.arrayMax,\n        G = a.arrayMin,\n        k = a.defined,\n        c = a.destroyObjectProperties,\n        p = a.erase,\n        t = a.merge,\n        v = a.pick;\n\n    a.PlotLineOrBand = function (a, c) {\n      this.axis = a;\n      c && (this.options = c, this.id = c.id);\n    };\n\n    a.PlotLineOrBand.prototype = {\n      render: function render() {\n        a.fireEvent(this, \"render\");\n        var c = this,\n            r = c.axis,\n            h = r.horiz,\n            e = c.options,\n            l = e.label,\n            n = c.label,\n            d = e.to,\n            g = e.from,\n            b = e.value,\n            x = k(g) && k(d),\n            u = k(b),\n            p = c.svgElem,\n            E = !p,\n            B = [],\n            m = e.color,\n            z = v(e.zIndex, 0),\n            D = e.events,\n            B = {\n          \"class\": \"highcharts-plot-\" + (x ? \"band \" : \"line \") + (e.className || \"\")\n        },\n            A = {},\n            f = r.chart.renderer,\n            q = x ? \"bands\" : \"lines\";\n        r.isLog && (g = r.log2lin(g), d = r.log2lin(d), b = r.log2lin(b));\n        r.chart.styledMode || (u ? (B.stroke = m, B[\"stroke-width\"] = e.width, e.dashStyle && (B.dashstyle = e.dashStyle)) : x && (m && (B.fill = m), e.borderWidth && (B.stroke = e.borderColor, B[\"stroke-width\"] = e.borderWidth)));\n        A.zIndex = z;\n        q += \"-\" + z;\n        (m = r.plotLinesAndBandsGroups[q]) || (r.plotLinesAndBandsGroups[q] = m = f.g(\"plot-\" + q).attr(A).add());\n        E && (c.svgElem = p = f.path().attr(B).add(m));\n        if (u) B = r.getPlotLinePath(b, p.strokeWidth());else if (x) B = r.getPlotBandPath(g, d, e);else return;\n        E && B && B.length ? (p.attr({\n          d: B\n        }), D && a.objectEach(D, function (a, b) {\n          p.on(b, function (a) {\n            D[b].apply(c, [a]);\n          });\n        })) : p && (B ? (p.show(), p.animate({\n          d: B\n        })) : (p.hide(), n && (c.label = n = n.destroy())));\n        l && k(l.text) && B && B.length && 0 < r.width && 0 < r.height && !B.isFlat ? (l = t({\n          align: h && x && \"center\",\n          x: h ? !x && 4 : 10,\n          verticalAlign: !h && x && \"middle\",\n          y: h ? x ? 16 : 10 : x ? 6 : -4,\n          rotation: h && !x && 90\n        }, l), this.renderLabel(l, B, x, z)) : n && n.hide();\n        return c;\n      },\n      renderLabel: function renderLabel(a, c, h, e) {\n        var l = this.label,\n            n = this.axis.chart.renderer;\n        l || (l = {\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (h ? \"band\" : \"line\") + \"-label \" + (a.className || \"\")\n        }, l.zIndex = e, this.label = l = n.text(a.text, 0, 0, a.useHTML).attr(l).add(), this.axis.chart.styledMode || l.css(a.style));\n        e = c.xBounds || [c[1], c[4], h ? c[6] : c[1]];\n        c = c.yBounds || [c[2], c[5], h ? c[7] : c[2]];\n        h = G(e);\n        n = G(c);\n        l.align(a, !1, {\n          x: h,\n          y: n,\n          width: F(e) - h,\n          height: F(c) - n\n        });\n        l.show();\n      },\n      destroy: function destroy() {\n        p(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        c(this);\n      }\n    };\n    a.extend(y.prototype, {\n      getPlotBandPath: function getPlotBandPath(a, c) {\n        var h = this.getPlotLinePath(c, null, null, !0),\n            e = this.getPlotLinePath(a, null, null, !0),\n            l = [],\n            n = this.horiz,\n            d = 1,\n            g;\n        a = a < this.min && c < this.min || a > this.max && c > this.max;\n        if (e && h) for (a && (g = e.toString() === h.toString(), d = 0), a = 0; a < e.length; a += 6) {\n          n && h[a + 1] === e[a + 1] ? (h[a + 1] += d, h[a + 4] += d) : n || h[a + 2] !== e[a + 2] || (h[a + 2] += d, h[a + 5] += d), l.push(\"M\", e[a + 1], e[a + 2], \"L\", e[a + 4], e[a + 5], h[a + 4], h[a + 5], h[a + 1], h[a + 2], \"z\"), l.isFlat = g;\n        }\n        return l;\n      },\n      addPlotBand: function addPlotBand(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      },\n      addPlotLine: function addPlotLine(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      },\n      addPlotBandOrLine: function addPlotBandOrLine(c, r) {\n        var h = new a.PlotLineOrBand(this, c).render(),\n            e = this.userOptions;\n        h && (r && (e[r] = e[r] || [], e[r].push(c)), this.plotLinesAndBands.push(h));\n        return h;\n      },\n      removePlotBandOrLine: function removePlotBandOrLine(a) {\n        for (var c = this.plotLinesAndBands, h = this.options, e = this.userOptions, l = c.length; l--;) {\n          c[l].id === a && c[l].destroy();\n        }\n\n        [h.plotLines || [], e.plotLines || [], h.plotBands || [], e.plotBands || []].forEach(function (e) {\n          for (l = e.length; l--;) {\n            e[l].id === a && p(e, e[l]);\n          }\n        });\n      },\n      removePlotBand: function removePlotBand(a) {\n        this.removePlotBandOrLine(a);\n      },\n      removePlotLine: function removePlotLine(a) {\n        this.removePlotBandOrLine(a);\n      }\n    });\n  })(I, X);\n\n  (function (a) {\n    var y = a.doc,\n        F = a.extend,\n        G = a.format,\n        k = a.isNumber,\n        c = a.merge,\n        p = a.pick,\n        t = a.splat,\n        v = a.syncTimeout,\n        w = a.timeUnits;\n\n    a.Tooltip = function () {\n      this.init.apply(this, arguments);\n    };\n\n    a.Tooltip.prototype = {\n      init: function init(a, h) {\n        this.chart = a;\n        this.options = h;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = h.split && !a.inverted;\n        this.shared = h.shared || this.split;\n        this.outside = h.outside && !this.split;\n      },\n      cleanSplit: function cleanSplit(a) {\n        this.chart.series.forEach(function (h) {\n          var e = h && h.tt;\n          e && (!e.isActive || a ? h.tt = e.destroy() : e.isActive = !1);\n        });\n      },\n      applyFilter: function applyFilter() {\n        var a = this.chart;\n        a.renderer.definition({\n          tagName: \"filter\",\n          id: \"drop-shadow-\" + a.index,\n          opacity: .5,\n          children: [{\n            tagName: \"feGaussianBlur\",\n            \"in\": \"SourceAlpha\",\n            stdDeviation: 1\n          }, {\n            tagName: \"feOffset\",\n            dx: 1,\n            dy: 1\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              type: \"linear\",\n              slope: .3\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              \"in\": \"SourceGraphic\"\n            }]\n          }]\n        });\n        a.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + a.index + \"{filter:url(#drop-shadow-\" + a.index + \")}\"\n        });\n      },\n      getLabel: function getLabel() {\n        var c = this,\n            h = this.chart.renderer,\n            e = this.chart.styledMode,\n            l = this.options,\n            n,\n            d;\n        this.label || (this.outside && (this.container = n = a.doc.createElement(\"div\"), n.className = \"highcharts-tooltip-container\", a.css(n, {\n          position: \"absolute\",\n          top: \"1px\",\n          pointerEvents: l.style && l.style.pointerEvents\n        }), a.doc.body.appendChild(n), this.renderer = h = new a.Renderer(n, 0, 0)), this.split ? this.label = h.g(\"tooltip\") : (this.label = h.label(\"\", 0, 0, l.shape || \"callout\", null, null, l.useHTML, null, \"tooltip\").attr({\n          padding: l.padding,\n          r: l.borderRadius\n        }), e || this.label.attr({\n          fill: l.backgroundColor,\n          \"stroke-width\": l.borderWidth\n        }).css(l.style).shadow(l.shadow)), e && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index)), this.outside && (d = {\n          x: this.label.xSetter,\n          y: this.label.ySetter\n        }, this.label.xSetter = function (a, b) {\n          d[b].call(this.label, c.distance);\n          n.style.left = a + \"px\";\n        }, this.label.ySetter = function (a, b) {\n          d[b].call(this.label, c.distance);\n          n.style.top = a + \"px\";\n        }), this.label.attr({\n          zIndex: 8\n        }).add());\n        return this.label;\n      },\n      update: function update(a) {\n        this.destroy();\n        c(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, c(!0, this.options, a));\n      },\n      destroy: function destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), a.discardElement(this.container));\n        a.clearTimeout(this.hideTimer);\n        a.clearTimeout(this.tooltipTimeout);\n      },\n      move: function move(c, h, e, l) {\n        var n = this,\n            d = n.now,\n            g = !1 !== n.options.animation && !n.isHidden && (1 < Math.abs(c - d.x) || 1 < Math.abs(h - d.y)),\n            b = n.followPointer || 1 < n.len;\n        F(d, {\n          x: g ? (2 * d.x + c) / 3 : c,\n          y: g ? (d.y + h) / 2 : h,\n          anchorX: b ? void 0 : g ? (2 * d.anchorX + e) / 3 : e,\n          anchorY: b ? void 0 : g ? (d.anchorY + l) / 2 : l\n        });\n        n.getLabel().attr(d);\n        g && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          n && n.move(c, h, e, l);\n        }, 32));\n      },\n      hide: function hide(c) {\n        var h = this;\n        a.clearTimeout(this.hideTimer);\n        c = p(c, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = v(function () {\n          h.getLabel()[c ? \"fadeOut\" : \"hide\"]();\n          h.isHidden = !0;\n        }, c));\n      },\n      getAnchor: function getAnchor(a, c) {\n        var e = this.chart,\n            h = e.pointer,\n            n = e.inverted,\n            d = e.plotTop,\n            g = e.plotLeft,\n            b = 0,\n            x = 0,\n            u,\n            k;\n        a = t(a);\n        this.followPointer && c ? (void 0 === c.chartX && (c = h.normalize(c)), a = [c.chartX - e.plotLeft, c.chartY - d]) : a[0].tooltipPos ? a = a[0].tooltipPos : (a.forEach(function (a) {\n          u = a.series.yAxis;\n          k = a.series.xAxis;\n          b += a.plotX + (!n && k ? k.left - g : 0);\n          x += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!n && u ? u.top - d : 0);\n        }), b /= a.length, x /= a.length, a = [n ? e.plotWidth - x : b, this.shared && !n && 1 < a.length && c ? c.chartY - d : n ? e.plotHeight - b : x]);\n        return a.map(Math.round);\n      },\n      getPosition: function getPosition(a, c, e) {\n        var h = this.chart,\n            n = this.distance,\n            d = {},\n            g = h.inverted && e.h || 0,\n            b,\n            x = this.outside,\n            u = x ? y.documentElement.clientWidth - 2 * n : h.chartWidth,\n            k = x ? Math.max(y.body.scrollHeight, y.documentElement.scrollHeight, y.body.offsetHeight, y.documentElement.offsetHeight, y.documentElement.clientHeight) : h.chartHeight,\n            r = h.pointer.chartPosition,\n            B = [\"y\", k, c, (x ? r.top - n : 0) + e.plotY + h.plotTop, x ? 0 : h.plotTop, x ? k : h.plotTop + h.plotHeight],\n            m = [\"x\", u, a, (x ? r.left - n : 0) + e.plotX + h.plotLeft, x ? 0 : h.plotLeft, x ? u : h.plotLeft + h.plotWidth],\n            z = !this.followPointer && p(e.ttBelow, !h.inverted === !!e.negative),\n            D = function D(a, b, f, e, m, c) {\n          var h = f < e - n,\n              q = e + n + f < b,\n              u = e - n - f;\n          e += n;\n          if (z && q) d[a] = e;else if (!z && h) d[a] = u;else if (h) d[a] = Math.min(c - f, 0 > u - g ? u : u - g);else if (q) d[a] = Math.max(m, e + g + f > b ? e : e + g);else return !1;\n        },\n            A = function A(a, b, f, g) {\n          var e;\n          g < n || g > b - n ? e = !1 : d[a] = g < f / 2 ? 1 : g > b - f / 2 ? b - f - 2 : g - f / 2;\n          return e;\n        },\n            f = function f(a) {\n          var f = B;\n          B = m;\n          m = f;\n          b = a;\n        },\n            q = function q() {\n          !1 !== D.apply(0, B) ? !1 !== A.apply(0, m) || b || (f(!0), q()) : b ? d.x = d.y = 0 : (f(!0), q());\n        };\n\n        (h.inverted || 1 < this.len) && f();\n        q();\n        return d;\n      },\n      defaultFormatter: function defaultFormatter(a) {\n        var c = this.points || t(this),\n            e;\n        e = [a.tooltipFooterHeaderFormatter(c[0])];\n        e = e.concat(a.bodyFormatter(c));\n        e.push(a.tooltipFooterHeaderFormatter(c[0], !0));\n        return e;\n      },\n      refresh: function refresh(c, h) {\n        var e,\n            l = this.options,\n            n,\n            d = c,\n            g,\n            b = {},\n            x = [];\n        e = l.formatter || this.defaultFormatter;\n        var b = this.shared,\n            u,\n            k = this.chart.styledMode;\n        l.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = t(d)[0].series.tooltipOptions.followPointer, g = this.getAnchor(d, h), h = g[0], n = g[1], !b || d.series && d.series.noSharedTooltip ? b = d.getLabelConfig() : (d.forEach(function (a) {\n          a.setState(\"hover\");\n          x.push(a.getLabelConfig());\n        }), b = {\n          x: d[0].category,\n          y: d[0].y\n        }, b.points = x, d = d[0]), this.len = x.length, b = e.call(b, this), u = d.series, this.distance = p(u.tooltipOptions.distance, 16), !1 === b ? this.hide() : (e = this.getLabel(), this.isHidden && e.attr({\n          opacity: 1\n        }).show(), this.split ? this.renderSplit(b, t(c)) : (l.style.width && !k || e.css({\n          width: this.chart.spacingBox.width\n        }), e.attr({\n          text: b && b.join ? b.join(\"\") : b\n        }), e.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + p(d.colorIndex, u.colorIndex)), k || e.attr({\n          stroke: l.borderColor || d.color || u.color || \"#666666\"\n        }), this.updatePosition({\n          plotX: h,\n          plotY: n,\n          negative: d.negative,\n          ttBelow: d.ttBelow,\n          h: g[2] || 0\n        })), this.isHidden = !1));\n      },\n      renderSplit: function renderSplit(c, h) {\n        var e = this,\n            l = [],\n            n = this.chart,\n            d = n.renderer,\n            g = !0,\n            b = this.options,\n            x = 0,\n            u,\n            k = this.getLabel(),\n            r = n.plotTop;\n        a.isString(c) && (c = [!1, c]);\n        c.slice(0, h.length + 1).forEach(function (a, m) {\n          if (!1 !== a && \"\" !== a) {\n            m = h[m - 1] || {\n              isHeader: !0,\n              plotX: h[0].plotX,\n              plotY: n.plotHeight\n            };\n            var c = m.series || e,\n                D = c.tt,\n                A = m.series || {},\n                f = \"highcharts-color-\" + p(m.colorIndex, A.colorIndex, \"none\");\n            D || (D = {\n              padding: b.padding,\n              r: b.borderRadius\n            }, n.styledMode || (D.fill = b.backgroundColor, D.stroke = b.borderColor || m.color || A.color || \"#333333\", D[\"stroke-width\"] = b.borderWidth), c.tt = D = d.label(null, null, null, (m.isHeader ? b.headerShape : b.shape) || \"callout\", null, null, b.useHTML).addClass(\"highcharts-tooltip-box \" + f).attr(D).add(k));\n            D.isActive = !0;\n            D.attr({\n              text: a\n            });\n            n.styledMode || D.css(b.style).shadow(b.shadow);\n            a = D.getBBox();\n            A = a.width + D.strokeWidth();\n            m.isHeader ? (x = a.height, n.xAxis[0].opposite && (u = !0, r -= x), A = Math.max(0, Math.min(m.plotX + n.plotLeft - A / 2, n.chartWidth + (n.scrollablePixels ? n.scrollablePixels - n.marginRight : 0) - A))) : A = m.plotX + n.plotLeft - p(b.distance, 16) - A;\n            0 > A && (g = !1);\n            a = (m.series && m.series.yAxis && m.series.yAxis.pos) + (m.plotY || 0);\n            a -= r;\n            m.isHeader && (a = u ? -x : n.plotHeight + x);\n            l.push({\n              target: a,\n              rank: m.isHeader ? 1 : 0,\n              size: c.tt.getBBox().height + 1,\n              point: m,\n              x: A,\n              tt: D\n            });\n          }\n        });\n        this.cleanSplit();\n        b.positioner && l.forEach(function (a) {\n          var g = b.positioner.call(e, a.tt.getBBox().width, a.size, a.point);\n          a.x = g.x;\n          a.align = 0;\n          a.target = g.y;\n          a.rank = p(g.rank, a.rank);\n        });\n        a.distribute(l, n.plotHeight + x);\n        l.forEach(function (a) {\n          var d = a.point,\n              c = d.series;\n          a.tt.attr({\n            visibility: void 0 === a.pos ? \"hidden\" : \"inherit\",\n            x: g || d.isHeader || b.positioner ? a.x : d.plotX + n.plotLeft + e.distance,\n            y: a.pos + r,\n            anchorX: d.isHeader ? d.plotX + n.plotLeft : d.plotX + c.xAxis.pos,\n            anchorY: d.isHeader ? n.plotTop + n.plotHeight / 2 : d.plotY + c.yAxis.pos\n          });\n        });\n      },\n      updatePosition: function updatePosition(a) {\n        var c = this.chart,\n            e = this.getLabel(),\n            l = (this.options.positioner || this.getPosition).call(this, e.width, e.height, a),\n            n = a.plotX + c.plotLeft;\n        a = a.plotY + c.plotTop;\n        var d;\n        this.outside && (d = (this.options.borderWidth || 0) + 2 * this.distance, this.renderer.setSize(e.width + d, e.height + d, !1), n += c.pointer.chartPosition.left - l.x, a += c.pointer.chartPosition.top - l.y);\n        this.move(Math.round(l.x), Math.round(l.y || 0), n, a);\n      },\n      getDateFormat: function getDateFormat(a, c, e, l) {\n        var h = this.chart.time,\n            d = h.dateFormat(\"%m-%d %H:%M:%S.%L\", c),\n            g,\n            b,\n            x = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            u = \"millisecond\";\n\n        for (b in w) {\n          if (a === w.week && +h.dateFormat(\"%w\", c) === e && \"00:00:00.000\" === d.substr(6)) {\n            b = \"week\";\n            break;\n          }\n\n          if (w[b] > a) {\n            b = u;\n            break;\n          }\n\n          if (x[b] && d.substr(x[b]) !== \"01-01 00:00:00.000\".substr(x[b])) break;\n          \"week\" !== b && (u = b);\n        }\n\n        b && (g = h.resolveDTLFormat(l[b]).main);\n        return g;\n      },\n      getXDateFormat: function getXDateFormat(a, c, e) {\n        c = c.dateTimeLabelFormats;\n        var h = e && e.closestPointRange;\n        return (h ? this.getDateFormat(h, a.x, e.options.startOfWeek, c) : c.day) || c.year;\n      },\n      tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(c, h) {\n        var e = h ? \"footer\" : \"header\",\n            l = c.series,\n            n = l.tooltipOptions,\n            d = n.xDateFormat,\n            g = l.xAxis,\n            b = g && \"datetime\" === g.options.type && k(c.key),\n            x = n[e + \"Format\"];\n        h = {\n          isFooter: h,\n          labelConfig: c\n        };\n        a.fireEvent(this, \"headerFormatter\", h, function (a) {\n          b && !d && (d = this.getXDateFormat(c, n, g));\n          b && d && (c.point && c.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            x = x.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + d + \"}\");\n          });\n          l.chart.styledMode && (x = this.styledModeFormat(x));\n          a.text = G(x, {\n            point: c,\n            series: l\n          }, this.chart.time);\n        });\n        return h.text;\n      },\n      bodyFormatter: function bodyFormatter(a) {\n        return a.map(function (a) {\n          var e = a.series.tooltipOptions;\n          return (e[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, e[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      },\n      styledModeFormat: function styledModeFormat(a) {\n        return a.replace('style\\x3d\"font-size: 10px\"', 'class\\x3d\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class\\x3d\"highcharts-color-{$1.colorIndex}\"');\n      }\n    };\n  })(I);\n\n  (function (a) {\n    var y = a.addEvent,\n        F = a.attr,\n        G = a.charts,\n        k = a.color,\n        c = a.css,\n        p = a.defined,\n        t = a.extend,\n        v = a.find,\n        w = a.fireEvent,\n        r = a.isNumber,\n        h = a.isObject,\n        e = a.offset,\n        l = a.pick,\n        n = a.splat,\n        d = a.Tooltip;\n\n    a.Pointer = function (a, b) {\n      this.init(a, b);\n    };\n\n    a.Pointer.prototype = {\n      init: function init(a, b) {\n        this.options = b;\n        this.chart = a;\n        this.runChartClick = b.chart.events && !!b.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        d && (a.tooltip = new d(a, b.tooltip), this.followTouchMove = l(b.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      },\n      zoomOption: function zoomOption(a) {\n        var b = this.chart,\n            g = b.options.chart,\n            d = g.zoomType || \"\",\n            b = b.inverted;\n        /touch/.test(a.type) && (d = l(g.pinchType, d));\n        this.zoomX = a = /x/.test(d);\n        this.zoomY = d = /y/.test(d);\n        this.zoomHor = a && !b || d && b;\n        this.zoomVert = d && !b || a && b;\n        this.hasZoom = a || d;\n      },\n      normalize: function normalize(a, b) {\n        var g;\n        g = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;\n        b || (this.chartPosition = b = e(this.chart.container));\n        return t(a, {\n          chartX: Math.round(g.pageX - b.left),\n          chartY: Math.round(g.pageY - b.top)\n        });\n      },\n      getCoordinates: function getCoordinates(a) {\n        var b = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (g) {\n          b[g.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: g,\n            value: g.toValue(a[g.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return b;\n      },\n      findNearestKDPoint: function findNearestKDPoint(a, b, d) {\n        var g;\n        a.forEach(function (a) {\n          var e = !(a.noSharedTooltip && b) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(d, e);\n          if ((e = h(a, !0)) && !(e = !h(g, !0))) var e = g.distX - a.distX,\n              c = g.dist - a.dist,\n              m = (a.series.group && a.series.group.zIndex) - (g.series.group && g.series.group.zIndex),\n              e = 0 < (0 !== e && b ? e : 0 !== c ? c : 0 !== m ? m : g.series.index > a.series.index ? -1 : 1);\n          e && (g = a);\n        });\n        return g;\n      },\n      getPointFromEvent: function getPointFromEvent(a) {\n        a = a.target;\n\n        for (var b; a && !b;) {\n          b = a.point, a = a.parentNode;\n        }\n\n        return b;\n      },\n      getChartCoordinatesFromPoint: function getChartCoordinatesFromPoint(a, b) {\n        var g = a.series,\n            d = g.xAxis,\n            g = g.yAxis,\n            e = l(a.clientX, a.plotX),\n            c = a.shapeArgs;\n        if (d && g) return b ? {\n          chartX: d.len + d.pos - e,\n          chartY: g.len + g.pos - a.plotY\n        } : {\n          chartX: e + d.pos,\n          chartY: a.plotY + g.pos\n        };\n        if (c && c.x && c.y) return {\n          chartX: c.x,\n          chartY: c.y\n        };\n      },\n      getHoverData: function getHoverData(a, b, d, e, c, n) {\n        var g,\n            m = [];\n        e = !(!e || !a);\n        var z = b && !b.stickyTracking ? [b] : d.filter(function (a) {\n          return a.visible && !(!c && a.directTouch) && l(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        b = (g = e ? a : this.findNearestKDPoint(z, c, n)) && g.series;\n        g && (c && !b.noSharedTooltip ? (z = d.filter(function (a) {\n          return a.visible && !(!c && a.directTouch) && l(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), z.forEach(function (a) {\n          var b = v(a.points, function (a) {\n            return a.x === g.x && !a.isNull;\n          });\n          h(b) && (a.chart.isBoosting && (b = a.getPoint(b)), m.push(b));\n        })) : m.push(g));\n        return {\n          hoverPoint: g,\n          hoverSeries: b,\n          hoverPoints: m\n        };\n      },\n      runPointActions: function runPointActions(g, b) {\n        var d = this.chart,\n            e = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0,\n            c = e ? e.shared : !1,\n            h = b || d.hoverPoint,\n            n = h && h.series || d.hoverSeries,\n            n = this.getHoverData(h, n, d.series, \"touchmove\" !== g.type && (!!b || n && n.directTouch && this.isDirectTouch), c, g),\n            m,\n            h = n.hoverPoint;\n        m = n.hoverPoints;\n        b = (n = n.hoverSeries) && n.tooltipOptions.followPointer;\n        c = c && n && !n.noSharedTooltip;\n\n        if (h && (h !== d.hoverPoint || e && e.isHidden)) {\n          (d.hoverPoints || []).forEach(function (a) {\n            -1 === m.indexOf(a) && a.setState();\n          });\n          (m || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          if (d.hoverSeries !== n) n.onMouseOver();\n          d.hoverPoint && d.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!h.series) return;\n          h.firePointEvent(\"mouseOver\");\n          d.hoverPoints = m;\n          d.hoverPoint = h;\n          e && e.refresh(c ? m : h, g);\n        } else b && e && !e.isHidden && (h = e.getAnchor([{}], g), e.updatePosition({\n          plotX: h[0],\n          plotY: h[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = y(d.container.ownerDocument, \"mousemove\", function (b) {\n          var g = G[a.hoverChartIndex];\n          if (g) g.pointer.onDocumentMouseMove(b);\n        }));\n        d.axes.forEach(function (b) {\n          var d = l(b.crosshair.snap, !0),\n              e = d ? a.find(m, function (a) {\n            return a.series[b.coll] === b;\n          }) : void 0;\n          e || !d ? b.drawCrosshair(g, e) : b.hideCrosshair();\n        });\n      },\n      reset: function reset(a, b) {\n        var g = this.chart,\n            d = g.hoverSeries,\n            e = g.hoverPoint,\n            c = g.hoverPoints,\n            h = g.tooltip,\n            m = h && h.shared ? c : e;\n        a && m && n(m).forEach(function (b) {\n          b.series.isCartesian && void 0 === b.plotX && (a = !1);\n        });\n        if (a) h && m && n(m).length && (h.refresh(m), h.shared && c ? c.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : e && (e.setState(e.state, !0), g.axes.forEach(function (a) {\n          a.crosshair && a.drawCrosshair(null, e);\n        })));else {\n          if (e) e.onMouseOut();\n          c && c.forEach(function (a) {\n            a.setState();\n          });\n          if (d) d.onMouseOut();\n          h && h.hide(b);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          g.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = g.hoverPoints = g.hoverPoint = null;\n        }\n      },\n      scaleGroups: function scaleGroups(a, b) {\n        var g = this.chart,\n            d;\n        g.series.forEach(function (e) {\n          d = a || e.getPlotBox();\n          e.xAxis && e.xAxis.zoomEnabled && e.group && (e.group.attr(d), e.markerGroup && (e.markerGroup.attr(d), e.markerGroup.clip(b ? g.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(d));\n        });\n        g.clipRect.attr(b || g.clipBox);\n      },\n      dragStart: function dragStart(a) {\n        var b = this.chart;\n        b.mouseIsDown = a.type;\n        b.cancelClick = !1;\n        b.mouseDownX = this.mouseDownX = a.chartX;\n        b.mouseDownY = this.mouseDownY = a.chartY;\n      },\n      drag: function drag(a) {\n        var b = this.chart,\n            g = b.options.chart,\n            d = a.chartX,\n            e = a.chartY,\n            c = this.zoomHor,\n            h = this.zoomVert,\n            m = b.plotLeft,\n            n = b.plotTop,\n            l = b.plotWidth,\n            A = b.plotHeight,\n            f,\n            q = this.selectionMarker,\n            r = this.mouseDownX,\n            p = this.mouseDownY,\n            t = g.panKey && a[g.panKey + \"Key\"];\n        q && q.touch || (d < m ? d = m : d > m + l && (d = m + l), e < n ? e = n : e > n + A && (e = n + A), this.hasDragged = Math.sqrt(Math.pow(r - d, 2) + Math.pow(p - e, 2)), 10 < this.hasDragged && (f = b.isInsidePlot(r - m, p - n), b.hasCartesianSeries && (this.zoomX || this.zoomY) && f && !t && !q && (this.selectionMarker = q = b.renderer.rect(m, n, c ? 1 : l, h ? 1 : A, 0).attr({\n          \"class\": \"highcharts-selection-marker\",\n          zIndex: 7\n        }).add(), b.styledMode || q.attr({\n          fill: g.selectionMarkerFill || k(\"#335cad\").setOpacity(.25).get()\n        })), q && c && (d -= r, q.attr({\n          width: Math.abs(d),\n          x: (0 < d ? 0 : d) + r\n        })), q && h && (d = e - p, q.attr({\n          height: Math.abs(d),\n          y: (0 < d ? 0 : d) + p\n        })), f && !q && g.panning && b.pan(a, g.panning)));\n      },\n      drop: function drop(a) {\n        var b = this,\n            d = this.chart,\n            g = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var e = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: []\n          },\n              h = this.selectionMarker,\n              n = h.attr ? h.attr(\"x\") : h.x,\n              m = h.attr ? h.attr(\"y\") : h.y,\n              l = h.attr ? h.attr(\"width\") : h.width,\n              D = h.attr ? h.attr(\"height\") : h.height,\n              k;\n          if (this.hasDragged || g) d.axes.forEach(function (f) {\n            if (f.zoomEnabled && p(f.min) && (g || b[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[f.coll]])) {\n              var d = f.horiz,\n                  c = \"touchend\" === a.type ? f.minPixelPadding : 0,\n                  h = f.toValue((d ? n : m) + c),\n                  d = f.toValue((d ? n + l : m + D) - c);\n              e[f.coll].push({\n                axis: f,\n                min: Math.min(h, d),\n                max: Math.max(h, d)\n              });\n              k = !0;\n            }\n          }), k && w(d, \"selection\", e, function (a) {\n            d.zoom(t(a, g ? {\n              animation: !1\n            } : null));\n          });\n          r(d.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          g && this.scaleGroups();\n        }\n\n        d && r(d.index) && (c(d.container, {\n          cursor: d._cursor\n        }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      },\n      onContainerMouseDown: function onContainerMouseDown(a) {\n        a = this.normalize(a);\n        2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));\n      },\n      onDocumentMouseUp: function onDocumentMouseUp(d) {\n        G[a.hoverChartIndex] && G[a.hoverChartIndex].pointer.drop(d);\n      },\n      onDocumentMouseMove: function onDocumentMouseMove(a) {\n        var b = this.chart,\n            d = this.chartPosition;\n        a = this.normalize(a, d);\n        !d || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();\n      },\n      onContainerMouseLeave: function onContainerMouseLeave(d) {\n        var b = G[a.hoverChartIndex];\n        b && (d.relatedTarget || d.toElement) && (b.pointer.reset(), b.pointer.chartPosition = null);\n      },\n      onContainerMouseMove: function onContainerMouseMove(d) {\n        var b = this.chart;\n        p(a.hoverChartIndex) && G[a.hoverChartIndex] && G[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = b.index);\n        d = this.normalize(d);\n        d.preventDefault || (d.returnValue = !1);\n        \"mousedown\" === b.mouseIsDown && this.drag(d);\n        !this.inClass(d.target, \"highcharts-tracker\") && !b.isInsidePlot(d.chartX - b.plotLeft, d.chartY - b.plotTop) || b.openMenu || this.runPointActions(d);\n      },\n      inClass: function inClass(a, b) {\n        for (var d; a;) {\n          if (d = F(a, \"class\")) {\n            if (-1 !== d.indexOf(b)) return !0;\n            if (-1 !== d.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      },\n      onTrackerMouseOut: function onTrackerMouseOut(a) {\n        var b = this.chart.hoverSeries;\n        a = a.relatedTarget || a.toElement;\n        this.isDirectTouch = !1;\n        if (!(!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut();\n      },\n      onContainerClick: function onContainerClick(a) {\n        var b = this.chart,\n            d = b.hoverPoint,\n            g = b.plotLeft,\n            e = b.plotTop;\n        a = this.normalize(a);\n        b.cancelClick || (d && this.inClass(a.target, \"highcharts-tracker\") ? (w(d.series, \"click\", t(a, {\n          point: d\n        })), b.hoverPoint && d.firePointEvent(\"click\", a)) : (t(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - g, a.chartY - e) && w(b, \"click\", a)));\n      },\n      setDOMEvents: function setDOMEvents() {\n        var d = this,\n            b = d.chart.container,\n            e = b.ownerDocument;\n\n        b.onmousedown = function (a) {\n          d.onContainerMouseDown(a);\n        };\n\n        b.onmousemove = function (a) {\n          d.onContainerMouseMove(a);\n        };\n\n        b.onclick = function (a) {\n          d.onContainerClick(a);\n        };\n\n        this.unbindContainerMouseLeave = y(b, \"mouseleave\", d.onContainerMouseLeave);\n        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = y(e, \"mouseup\", d.onDocumentMouseUp));\n        a.hasTouch && (b.ontouchstart = function (a) {\n          d.onContainerTouchStart(a);\n        }, b.ontouchmove = function (a) {\n          d.onContainerTouchMove(a);\n        }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = y(e, \"touchend\", d.onDocumentTouchEnd)));\n      },\n      destroy: function destroy() {\n        var d = this;\n        d.unDocMouseMove && d.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));\n        clearInterval(d.tooltipTimeout);\n        a.objectEach(d, function (a, g) {\n          d[g] = null;\n        });\n      }\n    };\n  })(I);\n\n  (function (a) {\n    var y = a.charts,\n        F = a.extend,\n        G = a.noop,\n        k = a.pick;\n    F(a.Pointer.prototype, {\n      pinchTranslate: function pinchTranslate(a, k, t, v, w, r) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, k, t, v, w, r);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, k, t, v, w, r);\n      },\n      pinchTranslateDirection: function pinchTranslateDirection(a, k, t, v, w, r, h, e) {\n        var c = this.chart,\n            n = a ? \"x\" : \"y\",\n            d = a ? \"X\" : \"Y\",\n            g = \"chart\" + d,\n            b = a ? \"width\" : \"height\",\n            x = c[\"plot\" + (a ? \"Left\" : \"Top\")],\n            u,\n            p,\n            E = e || 1,\n            B = c.inverted,\n            m = c.bounds[a ? \"h\" : \"v\"],\n            z = 1 === k.length,\n            D = k[0][g],\n            A = t[0][g],\n            f = !z && k[1][g],\n            q = !z && t[1][g],\n            L;\n\n        t = function t() {\n          !z && 20 < Math.abs(D - f) && (E = e || Math.abs(A - q) / Math.abs(D - f));\n          p = (x - A) / E + D;\n          u = c[\"plot\" + (a ? \"Width\" : \"Height\")] / E;\n        };\n\n        t();\n        k = p;\n        k < m.min ? (k = m.min, L = !0) : k + u > m.max && (k = m.max - u, L = !0);\n        L ? (A -= .8 * (A - h[n][0]), z || (q -= .8 * (q - h[n][1])), t()) : h[n] = [A, q];\n        B || (r[n] = p - x, r[b] = u);\n        r = B ? 1 / E : E;\n        w[b] = u;\n        w[n] = k;\n        v[B ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + d] = E;\n        v[\"translate\" + d] = r * x + (A - r * D);\n      },\n      pinch: function pinch(a) {\n        var c = this,\n            t = c.chart,\n            v = c.pinchDown,\n            w = a.touches,\n            r = w.length,\n            h = c.lastValidTouch,\n            e = c.hasZoom,\n            l = c.selectionMarker,\n            n = {},\n            d = 1 === r && (c.inClass(a.target, \"highcharts-tracker\") && t.runTrackerClick || c.runChartClick),\n            g = {};\n        1 < r && (c.initiated = !0);\n        e && c.initiated && !d && a.preventDefault();\n        [].map.call(w, function (a) {\n          return c.normalize(a);\n        });\n        \"touchstart\" === a.type ? ([].forEach.call(w, function (a, d) {\n          v[d] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), h.x = [v[0].chartX, v[1] && v[1].chartX], h.y = [v[0].chartY, v[1] && v[1].chartY], t.axes.forEach(function (a) {\n          if (a.zoomEnabled) {\n            var b = t.bounds[a.horiz ? \"h\" : \"v\"],\n                d = a.minPixelPadding,\n                g = a.toPixels(k(a.options.min, a.dataMin)),\n                e = a.toPixels(k(a.options.max, a.dataMax)),\n                c = Math.max(g, e);\n            b.min = Math.min(a.pos, Math.min(g, e) - d);\n            b.max = Math.max(a.pos + a.len, c + d);\n          }\n        }), c.res = !0) : c.followTouchMove && 1 === r ? this.runPointActions(c.normalize(a)) : v.length && (l || (c.selectionMarker = l = F({\n          destroy: G,\n          touch: !0\n        }, t.plotBox)), c.pinchTranslate(v, w, n, l, g, h), c.hasPinched = e, c.scaleGroups(n, g), c.res && (c.res = !1, this.reset(!1, 0)));\n      },\n      touch: function touch(c, p) {\n        var t = this.chart,\n            v,\n            w;\n        if (t.index !== a.hoverChartIndex) this.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        a.hoverChartIndex = t.index;\n        1 === c.touches.length ? (c = this.normalize(c), (w = t.isInsidePlot(c.chartX - t.plotLeft, c.chartY - t.plotTop)) && !t.openMenu ? (p && this.runPointActions(c), \"touchmove\" === c.type && (p = this.pinchDown, v = p[0] ? 4 <= Math.sqrt(Math.pow(p[0].chartX - c.chartX, 2) + Math.pow(p[0].chartY - c.chartY, 2)) : !1), k(v, !0) && this.pinch(c)) : p && this.reset()) : 2 === c.touches.length && this.pinch(c);\n      },\n      onContainerTouchStart: function onContainerTouchStart(a) {\n        this.zoomOption(a);\n        this.touch(a, !0);\n      },\n      onContainerTouchMove: function onContainerTouchMove(a) {\n        this.touch(a);\n      },\n      onDocumentTouchEnd: function onDocumentTouchEnd(c) {\n        y[a.hoverChartIndex] && y[a.hoverChartIndex].pointer.drop(c);\n      }\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.addEvent,\n        F = a.charts,\n        G = a.css,\n        k = a.doc,\n        c = a.extend,\n        p = a.noop,\n        t = a.Pointer,\n        v = a.removeEvent,\n        w = a.win,\n        r = a.wrap;\n\n    if (!a.hasTouch && (w.PointerEvent || w.MSPointerEvent)) {\n      var h = {},\n          e = !!w.PointerEvent,\n          l = function l() {\n        var d = [];\n\n        d.item = function (a) {\n          return this[a];\n        };\n\n        a.objectEach(h, function (a) {\n          d.push({\n            pageX: a.pageX,\n            pageY: a.pageY,\n            target: a.target\n          });\n        });\n        return d;\n      },\n          n = function n(d, g, b, e) {\n        \"touch\" !== d.pointerType && d.pointerType !== d.MSPOINTER_TYPE_TOUCH || !F[a.hoverChartIndex] || (e(d), e = F[a.hoverChartIndex].pointer, e[g]({\n          type: b,\n          target: d.currentTarget,\n          preventDefault: p,\n          touches: l()\n        }));\n      };\n\n      c(t.prototype, {\n        onContainerPointerDown: function onContainerPointerDown(a) {\n          n(a, \"onContainerTouchStart\", \"touchstart\", function (a) {\n            h[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY,\n              target: a.currentTarget\n            };\n          });\n        },\n        onContainerPointerMove: function onContainerPointerMove(a) {\n          n(a, \"onContainerTouchMove\", \"touchmove\", function (a) {\n            h[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY\n            };\n            h[a.pointerId].target || (h[a.pointerId].target = a.currentTarget);\n          });\n        },\n        onDocumentPointerUp: function onDocumentPointerUp(a) {\n          n(a, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n            delete h[a.pointerId];\n          });\n        },\n        batchMSEvents: function batchMSEvents(a) {\n          a(this.chart.container, e ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n          a(this.chart.container, e ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n          a(k, e ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n        }\n      });\n      r(t.prototype, \"init\", function (a, g, b) {\n        a.call(this, g, b);\n        this.hasZoom && G(g.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      });\n      r(t.prototype, \"setDOMEvents\", function (a) {\n        a.apply(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(y);\n      });\n      r(t.prototype, \"destroy\", function (a) {\n        this.batchMSEvents(v);\n        a.call(this);\n      });\n    }\n  })(I);\n\n  (function (a) {\n    var y = a.addEvent,\n        F = a.css,\n        G = a.discardElement,\n        k = a.defined,\n        c = a.fireEvent,\n        p = a.isFirefox,\n        t = a.marginNames,\n        v = a.merge,\n        w = a.pick,\n        r = a.setAnimation,\n        h = a.stableSort,\n        e = a.win,\n        l = a.wrap;\n\n    a.Legend = function (a, d) {\n      this.init(a, d);\n    };\n\n    a.Legend.prototype = {\n      init: function init(a, d) {\n        this.chart = a;\n        this.setOptions(d);\n        d.enabled && (this.render(), y(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = y(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      },\n      setOptions: function setOptions(a) {\n        var d = w(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = v(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.padding = d;\n        this.initialItemY = d - 5;\n        this.symbolWidth = w(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n      },\n      update: function update(a, d) {\n        var g = this.chart;\n        this.setOptions(v(!0, this.options, a));\n        this.destroy();\n        g.isDirtyLegend = g.isDirtyBox = !0;\n        w(d, !0) && g.redraw();\n        c(this, \"afterUpdate\");\n      },\n      colorizeItem: function colorizeItem(a, d) {\n        a.legendGroup[d ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var g = this.options,\n              b = a.legendItem,\n              e = a.legendLine,\n              h = a.legendSymbol,\n              n = this.itemHiddenStyle.color,\n              g = d ? g.itemStyle.color : n,\n              l = d ? a.color || n : n,\n              k = a.options && a.options.marker,\n              m = {\n            fill: l\n          };\n          b && b.css({\n            fill: g,\n            color: g\n          });\n          e && e.attr({\n            stroke: l\n          });\n          h && (k && h.isMarker && (m = a.pointAttribs(), d || (m.stroke = m.fill = n)), h.attr(m));\n        }\n\n        c(this, \"afterColorizeItem\", {\n          item: a,\n          visible: d\n        });\n      },\n      positionItems: function positionItems() {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      },\n      positionItem: function positionItem(a) {\n        var d = this.options,\n            e = d.symbolPadding,\n            d = !d.rtl,\n            b = a._legendItemPos,\n            c = b[0],\n            b = b[1],\n            h = a.checkbox;\n        if ((a = a.legendGroup) && a.element) a[k(a.translateY) ? \"animate\" : \"attr\"]({\n          translateX: d ? c : this.legendWidth - c - 2 * e - 4,\n          translateY: b\n        });\n        h && (h.x = c, h.y = b);\n      },\n      destroyItem: function destroyItem(a) {\n        var d = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (d) {\n          a[d] && (a[d] = a[d].destroy());\n        });\n        d && G(a.checkbox);\n      },\n      destroy: function destroy() {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (d) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, d);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      },\n      positionCheckboxes: function positionCheckboxes() {\n        var a = this.group && this.group.alignAttr,\n            d,\n            e = this.clipHeight || this.legendHeight,\n            b = this.titleHeight;\n        a && (d = a.translateY, this.allItems.forEach(function (g) {\n          var c = g.checkbox,\n              h;\n          c && (h = d + b + c.y + (this.scrollOffset || 0) + 3, F(c, {\n            left: a.translateX + g.checkboxOffset + c.x - 20 + \"px\",\n            top: h + \"px\",\n            display: this.proximate || h > d - 6 && h < d + e - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      },\n      renderTitle: function renderTitle() {\n        var a = this.options,\n            d = this.padding,\n            e = a.title,\n            b = 0;\n        e.text && (this.title || (this.title = this.chart.renderer.label(e.text, d - 3, d - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(e.style), this.title.add(this.group)), e.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), b = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: b\n        }));\n        this.titleHeight = b;\n      },\n      setText: function setText(e) {\n        var d = this.options;\n        e.legendItem.attr({\n          text: d.labelFormat ? a.format(d.labelFormat, e, this.chart.time) : d.labelFormatter.call(e)\n        });\n      },\n      renderItem: function renderItem(a) {\n        var d = this.chart,\n            e = d.renderer,\n            b = this.options,\n            c = this.symbolWidth,\n            h = b.symbolPadding,\n            n = this.itemStyle,\n            l = this.itemHiddenStyle,\n            k = \"horizontal\" === b.layout ? w(b.itemDistance, 20) : 0,\n            m = !b.rtl,\n            z = a.legendItem,\n            D = !a.series,\n            A = !D && a.series.drawLegendSymbol ? a.series : a,\n            f = A.options,\n            f = this.createCheckboxForItem && f && f.showCheckbox,\n            k = c + h + k + (f ? 20 : 0),\n            q = b.useHTML,\n            r = a.options.className;\n        z || (a.legendGroup = e.g(\"legend-item\").addClass(\"highcharts-\" + A.type + \"-series highcharts-color-\" + a.colorIndex + (r ? \" \" + r : \"\") + (D ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = z = e.text(\"\", m ? c + h : -h, this.baseline || 0, q), d.styledMode || z.css(v(a.visible ? n : l)), z.attr({\n          align: m ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = e.fontMetrics(d.styledMode ? 12 : n.fontSize, z), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, z.attr(\"y\", this.baseline)), this.symbolHeight = b.symbolHeight || this.fontMetrics.f, A.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, z, q), f && this.createCheckboxForItem(a));\n        this.colorizeItem(a, a.visible);\n        !d.styledMode && n.width || z.css({\n          width: (b.itemWidth || this.widthOption || d.spacingBox.width) - k\n        });\n        this.setText(a);\n        d = z.getBBox();\n        a.itemWidth = a.checkboxOffset = b.itemWidth || a.legendItemWidth || d.width + k;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || d.height || this.symbolHeight);\n      },\n      layoutItem: function layoutItem(a) {\n        var d = this.options,\n            e = this.padding,\n            b = \"horizontal\" === d.layout,\n            c = a.itemHeight,\n            h = d.itemMarginBottom || 0,\n            n = this.itemMarginTop,\n            l = b ? w(d.itemDistance, 20) : 0,\n            k = this.maxLegendWidth,\n            d = d.alignColumns && this.totalItemWidth > k ? this.maxItemWidth : a.itemWidth;\n        b && this.itemX - e + d > k && (this.itemX = e, this.itemY += n + this.lastLineHeight + h, this.lastLineHeight = 0);\n        this.lastItemY = n + this.itemY + h;\n        this.lastLineHeight = Math.max(c, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        b ? this.itemX += d : (this.itemY += n + c + h, this.lastLineHeight = c);\n        this.offsetWidth = this.widthOption || Math.max((b ? this.itemX - e - (a.checkbox ? 0 : l) : d) + e, this.offsetWidth);\n      },\n      getAllItems: function getAllItems() {\n        var a = [];\n        this.chart.series.forEach(function (d) {\n          var e = d && d.options;\n          d && w(e.showInLegend, k(e.linkedTo) ? !1 : void 0, !0) && (a = a.concat(d.legendItems || (\"point\" === e.legendType ? d.data : d)));\n        });\n        c(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      },\n      getAlignment: function getAlignment() {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      },\n      adjustMargins: function adjustMargins(a, d) {\n        var e = this.chart,\n            b = this.options,\n            c = this.getAlignment(),\n            h = void 0 !== e.options.title.margin ? e.titleOffset + e.options.title.margin : 0;\n        c && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (g, n) {\n          g.test(c) && !k(a[n]) && (e[t[n]] = Math.max(e[t[n]], e.legend[(n + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][n] * b[n % 2 ? \"x\" : \"y\"] + w(b.margin, 12) + d[n] + (0 === n && (0 === e.titleOffset ? 0 : h))));\n        });\n      },\n      proximatePositions: function proximatePositions() {\n        var e = this.chart,\n            d = [],\n            g = \"left\" === this.options.align;\n        this.allItems.forEach(function (b) {\n          var c, h;\n          c = g;\n          b.xAxis && b.points && (b.xAxis.options.reversed && (c = !c), c = a.find(c ? b.points : b.points.slice(0).reverse(), function (b) {\n            return a.isNumber(b.plotY);\n          }), h = b.legendGroup.getBBox().height, d.push({\n            target: b.visible ? (c ? c.plotY : b.xAxis.height) - .3 * h : e.plotHeight,\n            size: h,\n            item: b\n          }));\n        }, this);\n        a.distribute(d, e.plotHeight);\n        d.forEach(function (a) {\n          a.item._legendItemPos[1] = e.plotTop - e.spacing[0] + a.pos;\n        });\n      },\n      render: function render() {\n        var e = this.chart,\n            d = e.renderer,\n            g = this.group,\n            b,\n            l,\n            k,\n            r = this.box,\n            p = this.options,\n            B = this.padding;\n        this.itemX = B;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = a.relativeLength(p.width, e.spacingBox.width - B);\n        b = e.spacingBox.width - 2 * B - p.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (b /= 2);\n        this.maxLegendWidth = this.widthOption || b;\n        g || (this.group = g = d.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = d.g().attr({\n          zIndex: 1\n        }).add(g), this.scrollGroup = d.g().add(this.contentGroup));\n        this.renderTitle();\n        b = this.getAllItems();\n        h(b, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        p.reversed && b.reverse();\n        this.allItems = b;\n        this.display = l = !!b.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        b.forEach(this.renderItem, this);\n        b.forEach(this.layoutItem, this);\n        b = (this.widthOption || this.offsetWidth) + B;\n        k = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        k = this.handleOverflow(k);\n        k += B;\n        r || (this.box = r = d.rect().addClass(\"highcharts-legend-box\").attr({\n          r: p.borderRadius\n        }).add(g), r.isNew = !0);\n        e.styledMode || r.attr({\n          stroke: p.borderColor,\n          \"stroke-width\": p.borderWidth || 0,\n          fill: p.backgroundColor || \"none\"\n        }).shadow(p.shadow);\n        0 < b && 0 < k && (r[r.isNew ? \"attr\" : \"animate\"](r.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: b,\n          height: k\n        }, r.strokeWidth())), r.isNew = !1);\n        r[l ? \"show\" : \"hide\"]();\n        e.styledMode && \"none\" === g.getStyle(\"display\") && (b = k = 0);\n        this.legendWidth = b;\n        this.legendHeight = k;\n        l && (d = e.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (r = d.y + e.titleOffset, d = v(d, {\n          y: 0 < e.titleOffset ? r += e.options.title.margin : r\n        })), g.align(v(p, {\n          width: b,\n          height: k,\n          verticalAlign: this.proximate ? \"top\" : p.verticalAlign\n        }), !0, d));\n        this.proximate || this.positionItems();\n        c(this, \"afterRender\");\n      },\n      handleOverflow: function handleOverflow(a) {\n        var d = this,\n            e = this.chart,\n            b = e.renderer,\n            c = this.options,\n            h = c.y,\n            n = this.padding,\n            h = e.spacingBox.height + (\"top\" === c.verticalAlign ? -h : h) - n,\n            l = c.maxHeight,\n            k,\n            m = this.clipRect,\n            z = c.navigation,\n            D = w(z.animation, !0),\n            r = z.arrowSize || 12,\n            f = this.nav,\n            q = this.pages,\n            p,\n            t = this.allItems,\n            v = function v(a) {\n          \"number\" === typeof a ? m.attr({\n            height: a\n          }) : m && (d.clipRect = m.destroy(), d.contentGroup.clip());\n          d.contentGroup.div && (d.contentGroup.div.style.clip = a ? \"rect(\" + n + \"px,9999px,\" + (n + a) + \"px,0)\" : \"auto\");\n        };\n\n        \"horizontal\" !== c.layout || \"middle\" === c.verticalAlign || c.floating || (h /= 2);\n        l && (h = Math.min(h, l));\n        q.length = 0;\n        a > h && !1 !== z.enabled ? (this.clipHeight = k = Math.max(h - 20 - this.titleHeight - n, 0), this.currentPage = w(this.currentPage, 1), this.fullHeight = a, t.forEach(function (a, b) {\n          var f = a._legendItemPos[1],\n              d = Math.round(a.legendItem.getBBox().height),\n              e = q.length;\n          if (!e || f - q[e - 1] > k && (p || f) !== q[e - 1]) q.push(p || f), e++;\n          a.pageIx = e - 1;\n          p && (t[b - 1].pageIx = e - 1);\n          b === t.length - 1 && f + d - q[e - 1] > k && f !== p && (q.push(f), a.pageIx = e);\n          f !== p && (p = f);\n        }), m || (m = d.clipRect = b.clipRect(0, n, 9999, 0), d.contentGroup.clip(m)), v(k), f || (this.nav = f = b.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = b.symbol(\"triangle\", 0, 0, r, r).on(\"click\", function () {\n          d.scroll(-1, D);\n        }).add(f), this.pager = b.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), e.styledMode || this.pager.css(z.style), this.pager.add(f), this.down = b.symbol(\"triangle-down\", 0, 0, r, r).on(\"click\", function () {\n          d.scroll(1, D);\n        }).add(f)), d.scroll(0), a = h) : f && (v(), this.nav = f.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      },\n      scroll: function scroll(a, d) {\n        var e = this.pages,\n            b = e.length;\n        a = this.currentPage + a;\n        var c = this.clipHeight,\n            h = this.options.navigation,\n            l = this.pager,\n            n = this.padding;\n        a > b && (a = b);\n        0 < a && (void 0 !== d && r(d, this.chart), this.nav.attr({\n          translateX: n,\n          translateY: c + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), this.up.attr({\n          \"class\": 1 === a ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), l.attr({\n          text: a + \"/\" + b\n        }), this.down.attr({\n          x: 18 + this.pager.getBBox().width,\n          \"class\": a === b ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), this.chart.styledMode || (this.up.attr({\n          fill: 1 === a ? h.inactiveColor : h.activeColor\n        }).css({\n          cursor: 1 === a ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: a === b ? h.inactiveColor : h.activeColor\n        }).css({\n          cursor: a === b ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -e[a - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = a, this.positionCheckboxes());\n      }\n    };\n    a.LegendSymbolMixin = {\n      drawRectangle: function drawRectangle(a, d) {\n        var e = a.symbolHeight,\n            b = a.options.squareSymbol;\n        d.legendSymbol = this.chart.renderer.rect(b ? (a.symbolWidth - e) / 2 : 0, a.baseline - e + 1, b ? e : a.symbolWidth, e, w(a.options.symbolRadius, e / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(d.legendGroup);\n      },\n      drawLineMarker: function drawLineMarker(a) {\n        var d = this.options,\n            e = d.marker,\n            b = a.symbolWidth,\n            c = a.symbolHeight,\n            h = c / 2,\n            l = this.chart.renderer,\n            n = this.legendGroup;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        var k = {};\n        this.chart.styledMode || (k = {\n          \"stroke-width\": d.lineWidth || 0\n        }, d.dashStyle && (k.dashstyle = d.dashStyle));\n        this.legendLine = l.path([\"M\", 0, a, \"L\", b, a]).addClass(\"highcharts-graph\").attr(k).add(n);\n        e && !1 !== e.enabled && b && (d = Math.min(w(e.radius, h), h), 0 === this.symbol.indexOf(\"url\") && (e = v(e, {\n          width: c,\n          height: c\n        }), d = 0), this.legendSymbol = e = l.symbol(this.symbol, b / 2 - d, a - d, 2 * d, 2 * d, e).addClass(\"highcharts-point\").add(n), e.isMarker = !0);\n      }\n    };\n    (/Trident\\/7\\.0/.test(e.navigator && e.navigator.userAgent) || p) && l(a.Legend.prototype, \"positionItem\", function (a, d) {\n      var e = this,\n          b = function b() {\n        d._legendItemPos && a.call(e, d);\n      };\n\n      b();\n      e.bubbleLegend || setTimeout(b);\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.addEvent,\n        F = a.animate,\n        G = a.animObject,\n        k = a.attr,\n        c = a.doc,\n        p = a.Axis,\n        t = a.createElement,\n        v = a.defaultOptions,\n        w = a.discardElement,\n        r = a.charts,\n        h = a.css,\n        e = a.defined,\n        l = a.extend,\n        n = a.find,\n        d = a.fireEvent,\n        g = a.isNumber,\n        b = a.isObject,\n        x = a.isString,\n        u = a.Legend,\n        H = a.marginNames,\n        E = a.merge,\n        B = a.objectEach,\n        m = a.Pointer,\n        z = a.pick,\n        D = a.pInt,\n        A = a.removeEvent,\n        f = a.seriesTypes,\n        q = a.splat,\n        L = a.syncTimeout,\n        K = a.win,\n        T = a.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };\n\n    a.chart = function (a, b, f) {\n      return new T(a, b, f);\n    };\n\n    l(T.prototype, {\n      callbacks: [],\n      getArgs: function getArgs() {\n        var a = [].slice.call(arguments);\n        if (x(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n        this.init(a[0], a[1]);\n      },\n      init: function init(b, f) {\n        var e,\n            g,\n            c = b.series,\n            m = b.plotOptions || {};\n        d(this, \"init\", {\n          args: arguments\n        }, function () {\n          b.series = null;\n          e = E(v, b);\n\n          for (g in e.plotOptions) {\n            e.plotOptions[g].tooltip = m[g] && E(m[g].tooltip) || void 0;\n          }\n\n          e.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;\n          e.series = b.series = c;\n          this.userOptions = b;\n          var h = e.chart,\n              q = h.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = f;\n          this.isResizing = 0;\n          this.options = e;\n          this.axes = [];\n          this.series = [];\n          this.time = b.time && Object.keys(b.time).length ? new a.Time(b.time) : a.time;\n          this.styledMode = h.styledMode;\n          this.hasCartesianSeries = h.showAxes;\n          var l = this;\n          l.index = r.length;\n          r.push(l);\n          a.chartCount++;\n          q && B(q, function (a, b) {\n            y(l, b, a);\n          });\n          l.xAxis = [];\n          l.yAxis = [];\n          l.pointCount = l.colorCounter = l.symbolCounter = 0;\n          d(l, \"afterInit\");\n          l.firstRender();\n        });\n      },\n      initSeries: function initSeries(b) {\n        var d = this.options.chart;\n        (d = f[b.type || d.type || d.defaultSeriesType]) || a.error(17, !0, this);\n        d = new d();\n        d.init(this, b);\n        return d;\n      },\n      orderSeries: function orderSeries(a) {\n        var b = this.series;\n\n        for (a = a || 0; a < b.length; a++) {\n          b[a] && (b[a].index = a, b[a].name = b[a].getName());\n        }\n      },\n      isInsidePlot: function isInsidePlot(a, b, f) {\n        var d = f ? b : a;\n        a = f ? a : b;\n        return 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight;\n      },\n      redraw: function redraw(b) {\n        d(this, \"beforeRedraw\");\n        var f = this.axes,\n            e = this.series,\n            g = this.pointer,\n            c = this.legend,\n            m = this.userOptions.legend,\n            h = this.isDirtyLegend,\n            q,\n            n,\n            z = this.hasCartesianSeries,\n            k = this.isDirtyBox,\n            D,\n            u = this.renderer,\n            r = u.isHidden(),\n            A = [];\n        this.setResponsive && this.setResponsive(!1);\n        a.setAnimation(b, this);\n        r && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (b = e.length; b--;) {\n          if (D = e[b], D.options.stacking && (q = !0, D.isDirty)) {\n            n = !0;\n            break;\n          }\n        }\n\n        if (n) for (b = e.length; b--;) {\n          D = e[b], D.options.stacking && (D.isDirty = !0);\n        }\n        e.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (a.updateTotals && a.updateTotals(), h = !0) : m && (m.labelFormatter || m.labelFormat) && (h = !0));\n          a.isDirtyData && d(a, \"updatedData\");\n        });\n        h && c && c.options.enabled && (c.render(), this.isDirtyLegend = !1);\n        q && this.getStacks();\n        z && f.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        z && (f.forEach(function (a) {\n          a.isDirty && (k = !0);\n        }), f.forEach(function (a) {\n          var b = a.min + \",\" + a.max;\n          a.extKey !== b && (a.extKey = b, A.push(function () {\n            d(a, \"afterSetExtremes\", l(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (k || q) && a.redraw();\n        }));\n        k && this.drawChartBox();\n        d(this, \"predraw\");\n        e.forEach(function (a) {\n          (k || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        g && g.reset(!0);\n        u.draw();\n        d(this, \"redraw\");\n        d(this, \"render\");\n        r && this.temporaryDisplay(!0);\n        A.forEach(function (a) {\n          a.call();\n        });\n      },\n      get: function get(a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        var f,\n            d = this.series,\n            e;\n        f = n(this.axes, b) || n(this.series, b);\n\n        for (e = 0; !f && e < d.length; e++) {\n          f = n(d[e].points || [], b);\n        }\n\n        return f;\n      },\n      getAxes: function getAxes() {\n        var a = this,\n            b = this.options,\n            f = b.xAxis = q(b.xAxis || {}),\n            b = b.yAxis = q(b.yAxis || {});\n        d(this, \"getAxes\");\n        f.forEach(function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        b.forEach(function (a, b) {\n          a.index = b;\n        });\n        f.concat(b).forEach(function (b) {\n          new p(a, b);\n        });\n        d(this, \"afterGetAxes\");\n      },\n      getSelectedPoints: function getSelectedPoints() {\n        var a = [];\n        this.series.forEach(function (b) {\n          a = a.concat((b[b.hasGroupedData ? \"points\" : \"data\"] || []).filter(function (a) {\n            return a.selected;\n          }));\n        });\n        return a;\n      },\n      getSelectedSeries: function getSelectedSeries() {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      },\n      setTitle: function setTitle(a, b, f) {\n        var d = this,\n            e = d.options,\n            g = d.styledMode,\n            c;\n        c = e.title = E(!g && {\n          style: {\n            color: \"#333333\",\n            fontSize: e.isStock ? \"16px\" : \"18px\"\n          }\n        }, e.title, a);\n        e = e.subtitle = E(!g && {\n          style: {\n            color: \"#666666\"\n          }\n        }, e.subtitle, b);\n        [[\"title\", a, c], [\"subtitle\", b, e]].forEach(function (a, b) {\n          var f = a[0],\n              e = d[f],\n              c = a[1];\n          a = a[2];\n          e && c && (d[f] = e = e.destroy());\n          a && !e && (d[f] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({\n            align: a.align,\n            \"class\": \"highcharts-\" + f,\n            zIndex: a.zIndex || 4\n          }).add(), d[f].update = function (a) {\n            d.setTitle(!b && a, b && a);\n          }, g || d[f].css(a.style));\n        });\n        d.layOutTitles(f);\n      },\n      layOutTitles: function layOutTitles(a) {\n        var b = 0,\n            f,\n            d = this.renderer,\n            e = this.spacingBox;\n        [\"title\", \"subtitle\"].forEach(function (a) {\n          var f = this[a],\n              g = this.options[a];\n          a = \"title\" === a ? -3 : g.verticalAlign ? 0 : b + 2;\n          var c;\n          f && (this.styledMode || (c = g.style.fontSize), c = d.fontMetrics(c, f).b, f.css({\n            width: (g.width || e.width + g.widthAdjust) + \"px\"\n          }).align(l({\n            y: a + c\n          }, g), !1, \"spacingBox\"), g.floating || g.verticalAlign || (b = Math.ceil(b + f.getBBox(g.useHTML).height)));\n        }, this);\n        f = this.titleOffset !== b;\n        this.titleOffset = b;\n        !this.isDirtyBox && f && (this.isDirtyBox = this.isDirtyLegend = f, this.hasRendered && z(a, !0) && this.isDirtyBox && this.redraw());\n      },\n      getChartSize: function getChartSize() {\n        var b = this.options.chart,\n            f = b.width,\n            b = b.height,\n            d = this.renderTo;\n        e(f) || (this.containerWidth = a.getStyle(d, \"width\"));\n        e(b) || (this.containerHeight = a.getStyle(d, \"height\"));\n        this.chartWidth = Math.max(0, f || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      },\n      temporaryDisplay: function temporaryDisplay(b) {\n        var f = this.renderTo;\n        if (b) for (; f && f.style;) {\n          f.hcOrigStyle && (a.css(f, f.hcOrigStyle), delete f.hcOrigStyle), f.hcOrigDetached && (c.body.removeChild(f), f.hcOrigDetached = !1), f = f.parentNode;\n        } else for (; f && f.style;) {\n          c.body.contains(f) || f.parentNode || (f.hcOrigDetached = !0, c.body.appendChild(f));\n          if (\"none\" === a.getStyle(f, \"display\", !1) || f.hcOricDetached) f.hcOrigStyle = {\n            display: f.style.display,\n            height: f.style.height,\n            overflow: f.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, f !== this.renderTo && (b.height = 0), a.css(f, b), f.offsetWidth || f.style.setProperty(\"display\", \"block\", \"important\");\n          f = f.parentNode;\n          if (f === c.body) break;\n        }\n      },\n      setClassName: function setClassName(a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      },\n      getContainer: function getContainer() {\n        var b,\n            f = this.options,\n            e = f.chart,\n            m,\n            q;\n        b = this.renderTo;\n        var n = a.uniqueKey(),\n            z,\n            u;\n        b || (this.renderTo = b = e.renderTo);\n        x(b) && (this.renderTo = b = c.getElementById(b));\n        b || a.error(13, !0, this);\n        m = D(k(b, \"data-highcharts-chart\"));\n        g(m) && r[m] && r[m].hasRendered && r[m].destroy();\n        k(b, \"data-highcharts-chart\", this.index);\n        b.innerHTML = \"\";\n        e.skipClone || b.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        m = this.chartWidth;\n        q = this.chartHeight;\n        h(b, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (z = l({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: m + \"px\",\n          height: q + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n        }, e.style));\n        this.container = b = t(\"div\", {\n          id: n\n        }, z, b);\n        this._cursor = b.style.cursor;\n        this.renderer = new (a[e.renderer] || a.Renderer)(b, m, q, null, e.forExport, f.exporting && f.exporting.allowHTML, this.styledMode);\n        this.setClassName(e.className);\n        if (this.styledMode) for (u in f.defs) {\n          this.renderer.definition(f.defs[u]);\n        } else this.renderer.setStyle(e.style);\n        this.renderer.chartIndex = this.index;\n        d(this, \"afterGetContainer\");\n      },\n      getMargins: function getMargins(a) {\n        var b = this.spacing,\n            f = this.margin,\n            g = this.titleOffset;\n        this.resetMargins();\n        g && !e(f[0]) && (this.plotTop = Math.max(this.plotTop, g + this.options.title.margin + b[0]));\n        this.legend && this.legend.display && this.legend.adjustMargins(f, b);\n        d(this, \"getMargins\");\n        a || this.getAxisMargins();\n      },\n      getAxisMargins: function getAxisMargins() {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            f = a.margin;\n        a.hasCartesianSeries && a.axes.forEach(function (a) {\n          a.visible && a.getOffset();\n        });\n        H.forEach(function (d, g) {\n          e(f[g]) || (a[d] += b[g]);\n        });\n        a.setChartSize();\n      },\n      reflow: function reflow(b) {\n        var f = this,\n            d = f.options.chart,\n            g = f.renderTo,\n            m = e(d.width) && e(d.height),\n            h = d.width || a.getStyle(g, \"width\"),\n            d = d.height || a.getStyle(g, \"height\"),\n            g = b ? b.target : K;\n\n        if (!m && !f.isPrinting && h && d && (g === K || g === c)) {\n          if (h !== f.containerWidth || d !== f.containerHeight) a.clearTimeout(f.reflowTimeout), f.reflowTimeout = L(function () {\n            f.container && f.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          f.containerWidth = h;\n          f.containerHeight = d;\n        }\n      },\n      setReflow: function setReflow(a) {\n        var b = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = y(K, \"resize\", function (a) {\n          b.reflow(a);\n        }), y(this, \"destroy\", this.unbindReflow));\n      },\n      setSize: function setSize(b, f, e) {\n        var g = this,\n            c = g.renderer,\n            m;\n        g.isResizing += 1;\n        a.setAnimation(e, g);\n        g.oldChartHeight = g.chartHeight;\n        g.oldChartWidth = g.chartWidth;\n        void 0 !== b && (g.options.chart.width = b);\n        void 0 !== f && (g.options.chart.height = f);\n        g.getChartSize();\n        g.styledMode || (m = c.globalAnimation, (m ? F : h)(g.container, {\n          width: g.chartWidth + \"px\",\n          height: g.chartHeight + \"px\"\n        }, m));\n        g.setChartSize(!0);\n        c.setSize(g.chartWidth, g.chartHeight, e);\n        g.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        g.isDirtyLegend = !0;\n        g.isDirtyBox = !0;\n        g.layOutTitles();\n        g.getMargins();\n        g.redraw(e);\n        g.oldChartHeight = null;\n        d(g, \"resize\");\n        L(function () {\n          g && d(g, \"endResize\", null, function () {\n            --g.isResizing;\n          });\n        }, G(m).duration);\n      },\n      setChartSize: function setChartSize(a) {\n        var b = this.inverted,\n            f = this.renderer,\n            e = this.chartWidth,\n            g = this.chartHeight,\n            c = this.options.chart,\n            m = this.spacing,\n            h = this.clipOffset,\n            q,\n            l,\n            n,\n            z;\n        this.plotLeft = q = Math.round(this.plotLeft);\n        this.plotTop = l = Math.round(this.plotTop);\n        this.plotWidth = n = Math.max(0, Math.round(e - q - this.marginRight));\n        this.plotHeight = z = Math.max(0, Math.round(g - l - this.marginBottom));\n        this.plotSizeX = b ? z : n;\n        this.plotSizeY = b ? n : z;\n        this.plotBorderWidth = c.plotBorderWidth || 0;\n        this.spacingBox = f.spacingBox = {\n          x: m[3],\n          y: m[0],\n          width: e - m[3] - m[1],\n          height: g - m[0] - m[2]\n        };\n        this.plotBox = f.plotBox = {\n          x: q,\n          y: l,\n          width: n,\n          height: z\n        };\n        e = 2 * Math.floor(this.plotBorderWidth / 2);\n        b = Math.ceil(Math.max(e, h[3]) / 2);\n        f = Math.ceil(Math.max(e, h[0]) / 2);\n        this.clipBox = {\n          x: b,\n          y: f,\n          width: Math.floor(this.plotSizeX - Math.max(e, h[1]) / 2 - b),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(e, h[2]) / 2 - f))\n        };\n        a || this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        d(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      },\n      resetMargins: function resetMargins() {\n        d(this, \"resetMargins\");\n        var a = this,\n            f = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (d) {\n          var e = f[d],\n              g = b(e) ? e : [e, e, e, e];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (b, e) {\n            a[d][e] = z(f[d + b], g[e]);\n          });\n        });\n        H.forEach(function (b, f) {\n          a[b] = z(a.margin[f], a.spacing[f]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      },\n      drawChartBox: function drawChartBox() {\n        var a = this.options.chart,\n            b = this.renderer,\n            f = this.chartWidth,\n            e = this.chartHeight,\n            g = this.chartBackground,\n            c = this.plotBackground,\n            m = this.plotBorder,\n            h,\n            q = this.styledMode,\n            l = this.plotBGImage,\n            n = a.backgroundColor,\n            z = a.plotBackgroundColor,\n            k = a.plotBackgroundImage,\n            D,\n            u = this.plotLeft,\n            r = this.plotTop,\n            A = this.plotWidth,\n            x = this.plotHeight,\n            p = this.plotBox,\n            B = this.clipRect,\n            t = this.clipBox,\n            v = \"animate\";\n        g || (this.chartBackground = g = b.rect().addClass(\"highcharts-background\").add(), v = \"attr\");\n        if (q) h = D = g.strokeWidth();else {\n          h = a.borderWidth || 0;\n          D = h + (a.shadow ? 8 : 0);\n          n = {\n            fill: n || \"none\"\n          };\n          if (h || g[\"stroke-width\"]) n.stroke = a.borderColor, n[\"stroke-width\"] = h;\n          g.attr(n).shadow(a.shadow);\n        }\n        g[v]({\n          x: D / 2,\n          y: D / 2,\n          width: f - D - h % 2,\n          height: e - D - h % 2,\n          r: a.borderRadius\n        });\n        v = \"animate\";\n        c || (v = \"attr\", this.plotBackground = c = b.rect().addClass(\"highcharts-plot-background\").add());\n        c[v](p);\n        q || (c.attr({\n          fill: z || \"none\"\n        }).shadow(a.plotShadow), k && (l ? l.animate(p) : this.plotBGImage = b.image(k, u, r, A, x).add()));\n        B ? B.animate({\n          width: t.width,\n          height: t.height\n        }) : this.clipRect = b.clipRect(t);\n        v = \"animate\";\n        m || (v = \"attr\", this.plotBorder = m = b.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        q || m.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        m[v](m.crisp({\n          x: u,\n          y: r,\n          width: A,\n          height: x\n        }, -m.strokeWidth()));\n        this.isDirtyBox = !1;\n        d(this, \"afterDrawChartBox\");\n      },\n      propFromSeries: function propFromSeries() {\n        var a = this,\n            b = a.options.chart,\n            d,\n            e = a.options.series,\n            g,\n            c;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (m) {\n          d = f[b.type || b.defaultSeriesType];\n          c = b[m] || d && d.prototype[m];\n\n          for (g = e && e.length; !c && g--;) {\n            (d = f[e[g].type]) && d.prototype[m] && (c = !0);\n          }\n\n          a[m] = c;\n        });\n      },\n      linkSeries: function linkSeries() {\n        var a = this,\n            b = a.series;\n        b.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        b.forEach(function (b) {\n          var f = b.options.linkedTo;\n          x(f) && (f = \":previous\" === f ? a.series[b.index - 1] : a.get(f)) && f.linkedParent !== b && (f.linkedSeries.push(b), b.linkedParent = f, b.visible = z(b.options.visible, f.options.visible, b.visible));\n        });\n        d(this, \"afterLinkSeries\");\n      },\n      renderSeries: function renderSeries() {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      },\n      renderLabels: function renderLabels() {\n        var a = this,\n            b = a.options.labels;\n        b.items && b.items.forEach(function (f) {\n          var d = l(b.style, f.style),\n              e = D(d.left) + a.plotLeft,\n              g = D(d.top) + a.plotTop + 12;\n          delete d.left;\n          delete d.top;\n          a.renderer.text(f.html, e, g).attr({\n            zIndex: 2\n          }).css(d).add();\n        });\n      },\n      render: function render() {\n        var a = this.axes,\n            b = this.renderer,\n            f = this.options,\n            d = 0,\n            e,\n            g,\n            c;\n        this.setTitle();\n        this.legend = new u(this, f.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        f = this.plotWidth;\n        a.some(function (a) {\n          if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return d = 21, !0;\n        });\n        e = this.plotHeight = Math.max(this.plotHeight - d, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        g = 1.1 < f / this.plotWidth;\n        c = 1.05 < e / this.plotHeight;\n        if (g || c) a.forEach(function (a) {\n          (a.horiz && g || !a.horiz && c) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries && a.forEach(function (a) {\n          a.visible && a.render();\n        });\n        this.seriesGroup || (this.seriesGroup = b.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      },\n      addCredits: function addCredits(a) {\n        var b = this;\n        a = E(!0, this.options.credits, a);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (K.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }), b.styledMode || this.credits.css(a.style), this.credits.add().align(a.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();\n          b.addCredits(a);\n        });\n      },\n      destroy: function destroy() {\n        var b = this,\n            f = b.axes,\n            e = b.series,\n            g = b.container,\n            c,\n            m = g && g.parentNode;\n        d(b, \"destroy\");\n        b.renderer.forExport ? a.erase(r, b) : r[b.index] = void 0;\n        a.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        A(b);\n\n        for (c = f.length; c--;) {\n          f[c] = f[c].destroy();\n        }\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (c = e.length; c--;) {\n          e[c] = e[c].destroy();\n        }\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n          var f = b[a];\n          f && f.destroy && (b[a] = f.destroy());\n        });\n        g && (g.innerHTML = \"\", A(g), m && w(g));\n        B(b, function (a, f) {\n          delete b[f];\n        });\n      },\n      firstRender: function firstRender() {\n        var b = this,\n            f = b.options;\n\n        if (!b.isReadyToRender || b.isReadyToRender()) {\n          b.getContainer();\n          b.resetMargins();\n          b.setChartSize();\n          b.propFromSeries();\n          b.getAxes();\n          (a.isArray(f.series) ? f.series : []).forEach(function (a) {\n            b.initSeries(a);\n          });\n          b.linkSeries();\n          d(b, \"beforeRender\");\n          m && (b.pointer = new m(b, f));\n          b.render();\n          if (!b.renderer.imgCount && b.onload) b.onload();\n          b.temporaryDisplay(!0);\n        }\n      },\n      onload: function onload() {\n        [this.callback].concat(this.callbacks).forEach(function (a) {\n          a && void 0 !== this.index && a.apply(this, [this]);\n        }, this);\n        d(this, \"load\");\n        d(this, \"render\");\n        e(this.index) && this.setReflow(this.options.chart.reflow);\n        this.onload = null;\n      }\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.addEvent,\n        F = a.Chart;\n    y(F, \"afterSetChartSize\", function (y) {\n      var k = this.options.chart.scrollablePlotArea;\n      (k = k && k.minWidth) && !this.renderer.forExport && (this.scrollablePixels = k = Math.max(0, k - this.chartWidth)) && (this.plotWidth += k, this.clipBox.width += k, y.skipAxes || this.axes.forEach(function (c) {\n        1 === c.side ? c.getPlotLinePath = function () {\n          var k = this.right,\n              t;\n          this.right = k - c.chart.scrollablePixels;\n          t = a.Axis.prototype.getPlotLinePath.apply(this, arguments);\n          this.right = k;\n          return t;\n        } : (c.setAxisSize(), c.setAxisTranslation());\n      }));\n    });\n    y(F, \"render\", function () {\n      this.scrollablePixels ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    F.prototype.setUpScrolling = function () {\n      this.scrollingContainer = a.createElement(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, {\n        overflowX: \"auto\",\n        WebkitOverflowScrolling: \"touch\"\n      }, this.renderTo);\n      this.innerContainer = a.createElement(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    F.prototype.applyFixed = function () {\n      var y = this.container,\n          k,\n          c,\n          p = !this.fixedDiv;\n      p && (this.fixedDiv = a.createElement(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2\n      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = k = new a.Renderer(this.fixedDiv, 0, 0), this.scrollableMask = k.path().attr({\n        fill: a.color(this.options.chart.backgroundColor || \"#fff\").setOpacity(.85).get(),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), [this.inverted ? \".highcharts-xaxis\" : \".highcharts-yaxis\", this.inverted ? \".highcharts-xaxis-labels\" : \".highcharts-yaxis-labels\", \".highcharts-contextbutton\", \".highcharts-credits\", \".highcharts-legend\", \".highcharts-subtitle\", \".highcharts-title\", \".highcharts-legend-checkbox\"].forEach(function (a) {\n        [].forEach.call(y.querySelectorAll(a), function (a) {\n          (a.namespaceURI === k.SVG_NS ? k.box : k.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      }));\n      this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      c = this.chartWidth + this.scrollablePixels;\n      a.stop(this.container);\n      this.container.style.width = c + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: c,\n        height: this.chartHeight,\n        viewBox: [0, 0, c, this.chartHeight].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: c\n      });\n      p && (c = this.options.chart.scrollablePlotArea, c.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixels * c.scrollPositionX));\n      p = this.axisOffset;\n      c = this.plotTop - p[0] - 1;\n      var p = this.plotTop + this.plotHeight + p[2],\n          t = this.plotLeft + this.plotWidth - this.scrollablePixels;\n      this.scrollableMask.attr({\n        d: this.scrollablePixels ? [\"M\", 0, c, \"L\", this.plotLeft - 1, c, \"L\", this.plotLeft - 1, p, \"L\", 0, p, \"Z\", \"M\", t, c, \"L\", this.chartWidth, c, \"L\", this.chartWidth, p, \"L\", t, p, \"Z\"] : [\"M\", 0, 0]\n      });\n    };\n  })(I);\n\n  (function (a) {\n    var y,\n        F = a.extend,\n        G = a.erase,\n        k = a.fireEvent,\n        c = a.format,\n        p = a.isArray,\n        t = a.isNumber,\n        v = a.pick,\n        w = a.uniqueKey,\n        r = a.defined,\n        h = a.removeEvent;\n\n    a.Point = y = function y() {};\n\n    a.Point.prototype = {\n      init: function init(a, c, h) {\n        var d;\n        d = a.chart.options.chart.colorCount;\n        var e = a.chart.styledMode;\n        this.series = a;\n        e || (this.color = a.color);\n        this.applyOptions(c, h);\n        this.id = r(this.id) ? this.id : w();\n        a.options.colorByPoint ? (e || (d = a.options.colors || a.chart.options.colors, this.color = this.color || d[a.colorCounter], d = d.length), c = a.colorCounter, a.colorCounter++, a.colorCounter === d && (a.colorCounter = 0)) : c = a.colorIndex;\n        this.colorIndex = v(this.colorIndex, c);\n        a.chart.pointCount++;\n        k(this, \"afterInit\");\n        return this;\n      },\n      applyOptions: function applyOptions(a, c) {\n        var e = this.series,\n            d = e.options.pointValKey || e.pointValKey;\n        a = y.prototype.optionsToObject.call(this, a);\n        F(this, a);\n        this.options = this.options ? F(this.options, a) : a;\n        a.group && delete this.group;\n        a.dataLabels && delete this.dataLabels;\n        d && (this.y = this[d]);\n        this.isNull = v(this.isValid && !this.isValid(), null === this.x || !t(this.y, !0));\n        this.selected && (this.state = \"select\");\n        \"name\" in this && void 0 === c && e.xAxis && e.xAxis.hasNames && (this.x = e.xAxis.nameToX(this));\n        void 0 === this.x && e && (this.x = void 0 === c ? e.autoIncrement(this) : c);\n        return this;\n      },\n      setNestedProperty: function setNestedProperty(e, c, h) {\n        h.split(\".\").reduce(function (d, e, b, h) {\n          d[e] = h.length - 1 === b ? c : a.isObject(d[e], !0) ? d[e] : {};\n          return d[e];\n        }, e);\n        return e;\n      },\n      optionsToObject: function optionsToObject(e) {\n        var c = {},\n            h = this.series,\n            d = h.options.keys,\n            g = d || h.pointArrayMap || [\"y\"],\n            b = g.length,\n            k = 0,\n            u = 0;\n        if (t(e) || null === e) c[g[0]] = e;else if (p(e)) for (!d && e.length > b && (h = typeof e[0], \"string\" === h ? c.name = e[0] : \"number\" === h && (c.x = e[0]), k++); u < b;) {\n          d && void 0 === e[k] || (0 < g[u].indexOf(\".\") ? a.Point.prototype.setNestedProperty(c, e[k], g[u]) : c[g[u]] = e[k]), k++, u++;\n        } else \"object\" === typeof e && (c = e, e.dataLabels && (h._hasPointLabels = !0), e.marker && (h._hasPointMarkers = !0));\n        return c;\n      },\n      getClassName: function getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      },\n      getZone: function getZone() {\n        var a = this.series,\n            c = a.zones,\n            a = a.zoneAxis || \"y\",\n            h = 0,\n            d;\n\n        for (d = c[h]; this[a] >= d.value;) {\n          d = c[++h];\n        }\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = d && d.color && !this.options.color ? d.color : this.nonZonedColor;\n        return d;\n      },\n      destroy: function destroy() {\n        var a = this.series.chart,\n            c = a.hoverPoints,\n            n;\n        a.pointCount--;\n        c && (this.setState(), G(c, this), c.length || (a.hoverPoints = null));\n        if (this === a.hoverPoint) this.onMouseOut();\n        if (this.graphic || this.dataLabel || this.dataLabels) h(this), this.destroyElements();\n        this.legendItem && a.legend.destroyItem(this);\n\n        for (n in this) {\n          this[n] = null;\n        }\n      },\n      destroyElements: function destroyElements() {\n        for (var a = [\"graphic\", \"dataLabel\", \"dataLabelUpper\", \"connector\", \"shadowGroup\"], c, h = 6; h--;) {\n          c = a[h], this[c] && (this[c] = this[c].destroy());\n        }\n\n        this.dataLabels && (this.dataLabels.forEach(function (a) {\n          a.element && a.destroy();\n        }), delete this.dataLabels);\n        this.connectors && (this.connectors.forEach(function (a) {\n          a.element && a.destroy();\n        }), delete this.connectors);\n      },\n      getLabelConfig: function getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      },\n      tooltipFormatter: function tooltipFormatter(a) {\n        var e = this.series,\n            h = e.tooltipOptions,\n            d = v(h.valueDecimals, \"\"),\n            g = h.valuePrefix || \"\",\n            b = h.valueSuffix || \"\";\n        e.chart.styledMode && (a = e.chart.tooltip.styledModeFormat(a));\n        (e.pointArrayMap || [\"y\"]).forEach(function (e) {\n          e = \"{point.\" + e;\n          if (g || b) a = a.replace(RegExp(e + \"}\", \"g\"), g + e + \"}\" + b);\n          a = a.replace(RegExp(e + \"}\", \"g\"), e + \":,.\" + d + \"f}\");\n        });\n        return c(a, {\n          point: this,\n          series: this.series\n        }, e.chart.time);\n      },\n      firePointEvent: function firePointEvent(a, c, h) {\n        var d = this,\n            e = this.series.options;\n        (e.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents();\n        \"click\" === a && e.allowPointSelect && (h = function h(a) {\n          d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        k(this, a, c, h);\n      },\n      visible: !0\n    };\n  })(I);\n\n  (function (a) {\n    var y = a.addEvent,\n        F = a.animObject,\n        G = a.arrayMax,\n        k = a.arrayMin,\n        c = a.correctFloat,\n        p = a.defaultOptions,\n        t = a.defaultPlotOptions,\n        v = a.defined,\n        w = a.erase,\n        r = a.extend,\n        h = a.fireEvent,\n        e = a.isArray,\n        l = a.isNumber,\n        n = a.isString,\n        d = a.merge,\n        g = a.objectEach,\n        b = a.pick,\n        x = a.removeEvent,\n        u = a.splat,\n        H = a.SVGElement,\n        E = a.syncTimeout,\n        B = a.win;\n    a.Series = a.seriesType(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        lineWidth: 0,\n        lineColor: \"#ffffff\",\n        enabledThreshold: 2,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function formatter() {\n          return null === this.y ? \"\" : a.numberFormat(this.y, -1);\n        },\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        padding: 5\n      },\n      cropThreshold: 300,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      isCartesian: !0,\n      pointClass: a.Point,\n      sorted: !0,\n      requireSorting: !0,\n      directTouch: !1,\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      colorCounter: 0,\n      parallelArrays: [\"x\", \"y\"],\n      coll: \"series\",\n      cropShoulder: 1,\n      init: function init(a, d) {\n        h(this, \"init\", {\n          options: d\n        });\n        var e = this,\n            c,\n            f = a.series,\n            m;\n        e.chart = a;\n        e.options = d = e.setOptions(d);\n        e.linkedSeries = [];\n        e.bindAxes();\n        r(e, {\n          name: d.name,\n          state: \"\",\n          visible: !1 !== d.visible,\n          selected: !0 === d.selected\n        });\n        c = d.events;\n        g(c, function (a, b) {\n          e.hcEvents && e.hcEvents[b] && -1 !== e.hcEvents[b].indexOf(a) || y(e, b, a);\n        });\n        if (c && c.click || d.point && d.point.events && d.point.events.click || d.allowPointSelect) a.runTrackerClick = !0;\n        e.getColor();\n        e.getSymbol();\n        e.parallelArrays.forEach(function (a) {\n          e[a + \"Data\"] = [];\n        });\n        e.setData(d.data, !1);\n        e.isCartesian && (a.hasCartesianSeries = !0);\n        f.length && (m = f[f.length - 1]);\n        e._i = b(m && m._i, -1) + 1;\n        a.orderSeries(this.insert(f));\n        h(this, \"afterInit\");\n      },\n      insert: function insert(a) {\n        var d = this.options.index,\n            e;\n\n        if (l(d)) {\n          for (e = a.length; e--;) {\n            if (d >= b(a[e].options.index, a[e]._i)) {\n              a.splice(e + 1, 0, this);\n              break;\n            }\n          }\n\n          -1 === e && a.unshift(this);\n          e += 1;\n        } else a.push(this);\n\n        return b(e, a.length - 1);\n      },\n      bindAxes: function bindAxes() {\n        var b = this,\n            d = b.options,\n            e = b.chart,\n            g;\n        h(this, \"bindAxes\", null, function () {\n          (b.axisTypes || []).forEach(function (f) {\n            e[f].forEach(function (a) {\n              g = a.options;\n              if (d[f] === g.index || void 0 !== d[f] && d[f] === g.id || void 0 === d[f] && 0 === g.index) b.insert(a.series), b[f] = a, a.isDirty = !0;\n            });\n            b[f] || b.optionalAxis === f || a.error(18, !0, e);\n          });\n        });\n      },\n      updateParallelArrays: function updateParallelArrays(a, b) {\n        var d = a.series,\n            e = arguments,\n            f = l(b) ? function (f) {\n          var e = \"y\" === f && d.toYData ? d.toYData(a) : a[f];\n          d[f + \"Data\"][b] = e;\n        } : function (a) {\n          Array.prototype[b].apply(d[a + \"Data\"], Array.prototype.slice.call(e, 2));\n        };\n        d.parallelArrays.forEach(f);\n      },\n      autoIncrement: function autoIncrement() {\n        var a = this.options,\n            d = this.xIncrement,\n            e,\n            g = a.pointIntervalUnit,\n            f = this.chart.time,\n            d = b(d, a.pointStart, 0);\n        this.pointInterval = e = b(this.pointInterval, a.pointInterval, 1);\n        g && (a = new f.Date(d), \"day\" === g ? f.set(\"Date\", a, f.get(\"Date\", a) + e) : \"month\" === g ? f.set(\"Month\", a, f.get(\"Month\", a) + e) : \"year\" === g && f.set(\"FullYear\", a, f.get(\"FullYear\", a) + e), e = a.getTime() - d);\n        this.xIncrement = d + e;\n        return d;\n      },\n      setOptions: function setOptions(a) {\n        var e = this.chart,\n            g = e.options,\n            c = g.plotOptions,\n            f = (e.userOptions || {}).plotOptions || {},\n            m = c[this.type],\n            l = d(a);\n        a = e.styledMode;\n        h(this, \"setOptions\", {\n          userOptions: l\n        });\n        this.userOptions = l;\n        e = d(m, c.series, l);\n        this.tooltipOptions = d(p.tooltip, p.plotOptions.series && p.plotOptions.series.tooltip, p.plotOptions[this.type].tooltip, g.tooltip.userOptions, c.series && c.series.tooltip, c[this.type].tooltip, l.tooltip);\n        this.stickyTracking = b(l.stickyTracking, f[this.type] && f[this.type].stickyTracking, f.series && f.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : e.stickyTracking);\n        null === m.marker && delete e.marker;\n        this.zoneAxis = e.zoneAxis;\n        g = this.zones = (e.zones || []).slice();\n        !e.negativeColor && !e.negativeFillColor || e.zones || (c = {\n          value: e[this.zoneAxis + \"Threshold\"] || e.threshold || 0,\n          className: \"highcharts-negative\"\n        }, a || (c.color = e.negativeColor, c.fillColor = e.negativeFillColor), g.push(c));\n        g.length && v(g[g.length - 1].value) && g.push(a ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        h(this, \"afterSetOptions\", {\n          options: e\n        });\n        return e;\n      },\n      getName: function getName() {\n        return b(this.options.name, \"Series \" + (this.index + 1));\n      },\n      getCyclic: function getCyclic(a, d, e) {\n        var g,\n            f = this.chart,\n            c = this.userOptions,\n            h = a + \"Index\",\n            m = a + \"Counter\",\n            l = e ? e.length : b(f.options.chart[a + \"Count\"], f[a + \"Count\"]);\n        d || (g = b(c[h], c[\"_\" + h]), v(g) || (f.series.length || (f[m] = 0), c[\"_\" + h] = g = f[m] % l, f[m] += 1), e && (d = e[g]));\n        void 0 !== g && (this[h] = g);\n        this[a] = d;\n      },\n      getColor: function getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || t[this.type].color, this.chart.options.colors);\n      },\n      getSymbol: function getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,\n      updateData: function updateData(b) {\n        var d = this.options,\n            e = this.points,\n            g = [],\n            f,\n            c,\n            h,\n            m = this.requireSorting;\n        this.xIncrement = null;\n        b.forEach(function (b) {\n          var c, q, k;\n          c = a.defined(b) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, b) || {};\n          k = c.x;\n          if ((c = c.id) || l(k)) c && (q = (q = this.chart.get(c)) && q.index), void 0 === q && l(k) && (q = this.xData.indexOf(k, h)), -1 !== q && void 0 !== q && this.cropped && (q = q >= this.cropStart ? q - this.cropStart : q), -1 === q || void 0 === q || e[q] && e[q].touched ? g.push(b) : b !== d.data[q] ? (e[q].update(b, !1, null, !1), e[q].touched = !0, m && (h = q + 1)) : e[q] && (e[q].touched = !0), f = !0;\n        }, this);\n        if (f) for (b = e.length; b--;) {\n          c = e[b], c.touched || c.remove(!1), c.touched = !1;\n        } else if (b.length === e.length) b.forEach(function (a, b) {\n          e[b].update && a !== d.data[b] && e[b].update(a, !1, null, !1);\n        });else return !1;\n        g.forEach(function (a) {\n          this.addPoint(a, !1);\n        }, this);\n        return !0;\n      },\n      setData: function setData(d, g, c, h) {\n        var f = this,\n            m = f.points,\n            k = m && m.length || 0,\n            z,\n            u = f.options,\n            r = f.chart,\n            D = null,\n            x = f.xAxis,\n            A = u.turboThreshold,\n            p = this.xData,\n            B = this.yData,\n            t = (z = f.pointArrayMap) && z.length,\n            v = u.keys,\n            E = 0,\n            w = 1,\n            H;\n        d = d || [];\n        z = d.length;\n        g = b(g, !0);\n        !1 !== h && z && k && !f.cropped && !f.hasGroupedData && f.visible && !f.isSeriesBoosting && (H = this.updateData(d));\n\n        if (!H) {\n          f.xIncrement = null;\n          f.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            f[a + \"Data\"].length = 0;\n          });\n\n          if (A && z > A) {\n            for (c = 0; null === D && c < z;) {\n              D = d[c], c++;\n            }\n\n            if (l(D)) for (c = 0; c < z; c++) {\n              p[c] = this.autoIncrement(), B[c] = d[c];\n            } else if (e(D)) {\n              if (t) for (c = 0; c < z; c++) {\n                D = d[c], p[c] = D[0], B[c] = D.slice(1, t + 1);\n              } else for (v && (E = v.indexOf(\"x\"), w = v.indexOf(\"y\"), E = 0 <= E ? E : 0, w = 0 <= w ? w : 1), c = 0; c < z; c++) {\n                D = d[c], p[c] = D[E], B[c] = D[w];\n              }\n            } else a.error(12, !1, r);\n          } else for (c = 0; c < z; c++) {\n            void 0 !== d[c] && (D = {\n              series: f\n            }, f.pointClass.prototype.applyOptions.apply(D, [d[c]]), f.updateParallelArrays(D, c));\n          }\n\n          B && n(B[0]) && a.error(14, !0, r);\n          f.data = [];\n          f.options.data = f.userOptions.data = d;\n\n          for (c = k; c--;) {\n            m[c] && m[c].destroy && m[c].destroy();\n          }\n\n          x && (x.minRange = x.userMinRange);\n          f.isDirty = r.isDirtyBox = !0;\n          f.isDirtyData = !!m;\n          c = !1;\n        }\n\n        \"point\" === u.legendType && (this.processData(), this.generatePoints());\n        g && r.redraw(c);\n      },\n      processData: function processData(b) {\n        var d = this.xData,\n            e = this.yData,\n            c = d.length,\n            f;\n        f = 0;\n        var g,\n            h,\n            m = this.xAxis,\n            l,\n            k = this.options;\n        l = k.cropThreshold;\n        var n = this.getExtremesFromAll || k.getExtremesFromAll,\n            u = this.isCartesian,\n            k = m && m.val2lin,\n            r = m && m.isLog,\n            x = this.requireSorting,\n            p,\n            B;\n        if (u && !this.isDirty && !m.isDirty && !this.yAxis.isDirty && !b) return !1;\n        m && (b = m.getExtremes(), p = b.min, B = b.max);\n        u && this.sorted && !n && (!l || c > l || this.forceCrop) && (d[c - 1] < p || d[0] > B ? (d = [], e = []) : this.yData && (d[0] < p || d[c - 1] > B) && (f = this.cropData(this.xData, this.yData, p, B), d = f.xData, e = f.yData, f = f.start, g = !0));\n\n        for (l = d.length || 1; --l;) {\n          c = r ? k(d[l]) - k(d[l - 1]) : d[l] - d[l - 1], 0 < c && (void 0 === h || c < h) ? h = c : 0 > c && x && (a.error(15, !1, this.chart), x = !1);\n        }\n\n        this.cropped = g;\n        this.cropStart = f;\n        this.processedXData = d;\n        this.processedYData = e;\n        this.closestPointRange = h;\n      },\n      cropData: function cropData(a, d, e, c, f) {\n        var g = a.length,\n            h = 0,\n            m = g,\n            l;\n        f = b(f, this.cropShoulder);\n\n        for (l = 0; l < g; l++) {\n          if (a[l] >= e) {\n            h = Math.max(0, l - f);\n            break;\n          }\n        }\n\n        for (e = l; e < g; e++) {\n          if (a[e] > c) {\n            m = e + f;\n            break;\n          }\n        }\n\n        return {\n          xData: a.slice(h, m),\n          yData: d.slice(h, m),\n          start: h,\n          end: m\n        };\n      },\n      generatePoints: function generatePoints() {\n        var a = this.options,\n            b = a.data,\n            d = this.data,\n            e,\n            f = this.processedXData,\n            c = this.processedYData,\n            g = this.pointClass,\n            l = f.length,\n            k = this.cropStart || 0,\n            n,\n            x = this.hasGroupedData,\n            a = a.keys,\n            p,\n            B = [],\n            t;\n        d || x || (d = [], d.length = b.length, d = this.data = d);\n        a && x && (this.options.keys = !1);\n\n        for (t = 0; t < l; t++) {\n          n = k + t, x ? (p = new g().init(this, [f[t]].concat(u(c[t]))), p.dataGroup = this.groupMap[t], p.dataGroup.options && (p.options = p.dataGroup.options, r(p, p.dataGroup.options), delete p.dataLabels)) : (p = d[n]) || void 0 === b[n] || (d[n] = p = new g().init(this, b[n], f[t])), p && (p.index = n, B[t] = p);\n        }\n\n        this.options.keys = a;\n        if (d && (l !== (e = d.length) || x)) for (t = 0; t < e; t++) {\n          t !== k || x || (t += l), d[t] && (d[t].destroyElements(), d[t].plotX = void 0);\n        }\n        this.data = d;\n        this.points = B;\n        h(this, \"afterGeneratePoints\");\n      },\n      getExtremes: function getExtremes(a) {\n        var b = this.yAxis,\n            d = this.processedXData,\n            c,\n            f = [],\n            g = 0;\n        c = this.xAxis.getExtremes();\n        var m = c.min,\n            n = c.max,\n            u,\n            r,\n            x = this.requireSorting ? this.cropShoulder : 0,\n            p,\n            B;\n        a = a || this.stackedYData || this.processedYData || [];\n        c = a.length;\n\n        for (B = 0; B < c; B++) {\n          if (r = d[B], p = a[B], u = (l(p, !0) || e(p)) && (!b.positiveValuesOnly || p.length || 0 < p), r = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (d[B + x] || r) >= m && (d[B - x] || r) <= n, u && r) if (u = p.length) for (; u--;) {\n            \"number\" === typeof p[u] && (f[g++] = p[u]);\n          } else f[g++] = p;\n        }\n\n        this.dataMin = k(f);\n        this.dataMax = G(f);\n        h(this, \"afterGetExtremes\");\n      },\n      translate: function translate() {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            d = a.stacking,\n            e = this.xAxis,\n            g = e.categories,\n            f = this.yAxis,\n            q = this.points,\n            k = q.length,\n            n = !!this.modifyValue,\n            u,\n            r = this.pointPlacementToXValue(),\n            x = l(r),\n            p = a.threshold,\n            B = a.startFromThreshold ? p : 0,\n            t,\n            E,\n            w,\n            H,\n            y = this.zoneAxis || \"y\",\n            G = Number.MAX_VALUE;\n\n        for (u = 0; u < k; u++) {\n          var F = q[u],\n              I = F.x,\n              Q = F.y;\n          E = F.low;\n          var N = d && f.stacks[(this.negStacks && Q < (B ? 0 : p) ? \"-\" : \"\") + this.stackKey],\n              V;\n          f.positiveValuesOnly && null !== Q && 0 >= Q && (F.isNull = !0);\n          F.plotX = t = c(Math.min(Math.max(-1E5, e.translate(I, 0, 0, 0, 1, r, \"flags\" === this.type)), 1E5));\n          d && this.visible && !F.isNull && N && N[I] && (H = this.getStackIndicator(H, I, this.index), V = N[I], Q = V.points[H.key], E = Q[0], Q = Q[1], E === B && H.key === N[I].base && (E = b(l(p) && p, f.min)), f.positiveValuesOnly && 0 >= E && (E = null), F.total = F.stackTotal = V.total, F.percentage = V.total && F.y / V.total * 100, F.stackY = Q, V.setOffset(this.pointXOffset || 0, this.barW || 0));\n          F.yBottom = v(E) ? Math.min(Math.max(-1E5, f.translate(E, 0, 1, 0, 1)), 1E5) : null;\n          n && (Q = this.modifyValue(Q, F));\n          F.plotY = E = \"number\" === typeof Q && Infinity !== Q ? Math.min(Math.max(-1E5, f.translate(Q, 0, 1, 0, 1)), 1E5) : void 0;\n          F.isInside = void 0 !== E && 0 <= E && E <= f.len && 0 <= t && t <= e.len;\n          F.clientX = x ? c(e.translate(I, 0, 0, 0, 1, r)) : t;\n          F.negative = F[y] < (a[y + \"Threshold\"] || p || 0);\n          F.category = g && void 0 !== g[F.x] ? g[F.x] : F.x;\n          F.isNull || (void 0 !== w && (G = Math.min(G, Math.abs(t - w))), w = t);\n          F.zone = this.zones.length && F.getZone();\n        }\n\n        this.closestPointRangePx = G;\n        h(this, \"afterTranslate\");\n      },\n      getValidPoints: function getValidPoints(a, b, d) {\n        var e = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return b && !e.isInsidePlot(a.plotX, a.plotY, e.inverted) ? !1 : d || !a.isNull;\n        });\n      },\n      setClip: function setClip(a) {\n        var b = this.chart,\n            d = this.options,\n            e = b.renderer,\n            f = b.inverted,\n            c = this.clipBox,\n            g = c || b.clipBox,\n            h = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, g.height, d.xAxis, d.yAxis].join(),\n            m = b[h],\n            l = b[h + \"m\"];\n        m || (a && (g.width = 0, f && (g.x = b.plotSizeX), b[h + \"m\"] = l = e.clipRect(f ? b.plotSizeX + 99 : -99, f ? -b.plotLeft : -b.plotTop, 99, f ? b.chartWidth : b.chartHeight)), b[h] = m = e.clipRect(g), m.count = {\n          length: 0\n        });\n        a && !m.count[this.index] && (m.count[this.index] = !0, m.count.length += 1);\n        !1 !== d.clip && (this.group.clip(a || c ? m : b.clipRect), this.markerGroup.clip(l), this.sharedClipKey = h);\n        a || (m.count[this.index] && (delete m.count[this.index], --m.count.length), 0 === m.count.length && h && b[h] && (c || (b[h] = b[h].destroy()), b[h + \"m\"] && (b[h + \"m\"] = b[h + \"m\"].destroy())));\n      },\n      animate: function animate(a) {\n        var b = this.chart,\n            d = F(this.options.animation),\n            e;\n        a ? this.setClip(d) : (e = this.sharedClipKey, (a = b[e]) && a.animate({\n          width: b.plotSizeX,\n          x: 0\n        }, d), b[e + \"m\"] && b[e + \"m\"].animate({\n          width: b.plotSizeX + 99,\n          x: 0\n        }, d), this.animate = null);\n      },\n      afterAnimate: function afterAnimate() {\n        this.setClip();\n        h(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function drawPoints() {\n        var a = this.points,\n            d = this.chart,\n            e,\n            c,\n            f,\n            g,\n            h = this.options.marker,\n            l,\n            k,\n            n,\n            u = this[this.specialGroup] || this.markerGroup;\n        e = this.xAxis;\n        var r,\n            x = b(h.enabled, !e || e.isRadial ? !0 : null, this.closestPointRangePx >= h.enabledThreshold * h.radius);\n        if (!1 !== h.enabled || this._hasPointMarkers) for (e = 0; e < a.length; e++) {\n          c = a[e], g = c.graphic, l = c.marker || {}, k = !!c.marker, f = x && void 0 === l.enabled || l.enabled, n = !1 !== c.isInside, f && !c.isNull ? (f = b(l.symbol, this.symbol), r = this.markerAttribs(c, c.selected && \"select\"), g ? g[n ? \"show\" : \"hide\"](!0).animate(r) : n && (0 < r.width || c.hasImage) && (c.graphic = g = d.renderer.symbol(f, r.x, r.y, r.width, r.height, k ? l : h).add(u)), g && !d.styledMode && g.attr(this.pointAttribs(c, c.selected && \"select\")), g && g.addClass(c.getClassName(), !0)) : g && (c.graphic = g.destroy());\n        }\n      },\n      markerAttribs: function markerAttribs(a, d) {\n        var e = this.options.marker,\n            c = a.marker || {},\n            f = c.symbol || e.symbol,\n            g = b(c.radius, e.radius);\n        d && (e = e.states[d], d = c.states && c.states[d], g = b(d && d.radius, e && e.radius, g + (e && e.radiusPlus || 0)));\n        a.hasImage = f && 0 === f.indexOf(\"url\");\n        a.hasImage && (g = 0);\n        a = {\n          x: Math.floor(a.plotX) - g,\n          y: a.plotY - g\n        };\n        g && (a.width = a.height = 2 * g);\n        return a;\n      },\n      pointAttribs: function pointAttribs(a, d) {\n        var e = this.options.marker,\n            c = a && a.options,\n            f = c && c.marker || {},\n            g = this.color,\n            h = c && c.color,\n            m = a && a.color,\n            c = b(f.lineWidth, e.lineWidth);\n        a = a && a.zone && a.zone.color;\n        g = h || a || m || g;\n        a = f.fillColor || e.fillColor || g;\n        g = f.lineColor || e.lineColor || g;\n        d && (e = e.states[d], d = f.states && f.states[d] || {}, c = b(d.lineWidth, e.lineWidth, c + b(d.lineWidthPlus, e.lineWidthPlus, 0)), a = d.fillColor || e.fillColor || a, g = d.lineColor || e.lineColor || g);\n        return {\n          stroke: g,\n          \"stroke-width\": c,\n          fill: a\n        };\n      },\n      destroy: function destroy(b) {\n        var d = this,\n            e = d.chart,\n            c = /AppleWebKit\\/533/.test(B.navigator.userAgent),\n            f,\n            m,\n            l = d.data || [],\n            k,\n            n;\n        h(d, \"destroy\");\n        b || x(d);\n        (d.axisTypes || []).forEach(function (a) {\n          (n = d[a]) && n.series && (w(n.series, d), n.isDirty = n.forceRedraw = !0);\n        });\n        d.legendItem && d.chart.legend.destroyItem(d);\n\n        for (m = l.length; m--;) {\n          (k = l[m]) && k.destroy && k.destroy();\n        }\n\n        d.points = null;\n        a.clearTimeout(d.animationTimeout);\n        g(d, function (a, b) {\n          a instanceof H && !a.survive && (f = c && \"group\" === b ? \"hide\" : \"destroy\", a[f]());\n        });\n        e.hoverSeries === d && (e.hoverSeries = null);\n        w(e.series, d);\n        e.orderSeries();\n        g(d, function (a, f) {\n          b && \"hcEvents\" === f || delete d[f];\n        });\n      },\n      getGraphPath: function getGraphPath(a, b, d) {\n        var e = this,\n            f = e.options,\n            c = f.step,\n            g,\n            h = [],\n            m = [],\n            l;\n        a = a || e.points;\n        (g = a.reversed) && a.reverse();\n        (c = {\n          right: 1,\n          center: 2\n        }[c] || c && 3) && g && (c = 4 - c);\n        !f.connectNulls || b || d || (a = this.getValidPoints(a));\n        a.forEach(function (g, q) {\n          var k = g.plotX,\n              n = g.plotY,\n              u = a[q - 1];\n          (g.leftCliff || u && u.rightCliff) && !d && (l = !0);\n          g.isNull && !v(b) && 0 < q ? l = !f.connectNulls : g.isNull && !b ? l = !0 : (0 === q || l ? q = [\"M\", g.plotX, g.plotY] : e.getPointSpline ? q = e.getPointSpline(a, g, q) : c ? (q = 1 === c ? [\"L\", u.plotX, n] : 2 === c ? [\"L\", (u.plotX + k) / 2, u.plotY, \"L\", (u.plotX + k) / 2, n] : [\"L\", k, u.plotY], q.push(\"L\", k, n)) : q = [\"L\", k, n], m.push(g.x), c && (m.push(g.x), 2 === c && m.push(g.x)), h.push.apply(h, q), l = !1);\n        });\n        h.xMap = m;\n        return e.graphPath = h;\n      },\n      drawGraph: function drawGraph() {\n        var a = this,\n            b = this.options,\n            d = (this.gappedPath || this.getGraphPath).call(this),\n            e = this.chart.styledMode,\n            f = [[\"graph\", \"highcharts-graph\"]];\n        e || f[0].push(b.lineColor || this.color, b.dashStyle);\n        f = a.getZonesGraphs(f);\n        f.forEach(function (f, c) {\n          var g = f[0],\n              h = a[g];\n          h ? (h.endX = a.preventGraphAnimation ? null : d.xMap, h.animate({\n            d: d\n          })) : d.length && (a[g] = a.chart.renderer.path(d).addClass(f[1]).attr({\n            zIndex: 1\n          }).add(a.group), e || (h = {\n            stroke: f[2],\n            \"stroke-width\": b.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, f[3] ? h.dashstyle = f[3] : \"square\" !== b.linecap && (h[\"stroke-linecap\"] = h[\"stroke-linejoin\"] = \"round\"), h = a[g].attr(h).shadow(2 > c && b.shadow)));\n          h && (h.startX = d.xMap, h.isArea = d.isArea);\n        });\n      },\n      getZonesGraphs: function getZonesGraphs(a) {\n        this.zones.forEach(function (b, d) {\n          d = [\"zone-graph-\" + d, \"highcharts-graph highcharts-zone-graph-\" + d + \" \" + (b.className || \"\")];\n          this.chart.styledMode || d.push(b.color || this.color, b.dashStyle || this.options.dashStyle);\n          a.push(d);\n        }, this);\n        return a;\n      },\n      applyZones: function applyZones() {\n        var a = this,\n            d = this.chart,\n            e = d.renderer,\n            c = this.zones,\n            f,\n            g,\n            h = this.clips || [],\n            l,\n            k = this.graph,\n            n = this.area,\n            u = Math.max(d.chartWidth, d.chartHeight),\n            r = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            x,\n            p,\n            B = d.inverted,\n            t,\n            v,\n            E,\n            w,\n            H = !1;\n        c.length && (k || n) && r && void 0 !== r.min && (p = r.reversed, t = r.horiz, k && !this.showLine && k.hide(), n && n.hide(), x = r.getExtremes(), c.forEach(function (c, m) {\n          f = p ? t ? d.plotWidth : 0 : t ? 0 : r.toPixels(x.min) || 0;\n          f = Math.min(Math.max(b(g, f), 0), u);\n          g = Math.min(Math.max(Math.round(r.toPixels(b(c.value, x.max), !0) || 0), 0), u);\n          H && (f = g = r.toPixels(x.max));\n          v = Math.abs(f - g);\n          E = Math.min(f, g);\n          w = Math.max(f, g);\n          r.isXAxis ? (l = {\n            x: B ? w : E,\n            y: 0,\n            width: v,\n            height: u\n          }, t || (l.x = d.plotHeight - l.x)) : (l = {\n            x: 0,\n            y: B ? w : E,\n            width: u,\n            height: v\n          }, t && (l.y = d.plotWidth - l.y));\n          B && e.isVML && (l = r.isXAxis ? {\n            x: 0,\n            y: p ? E : w,\n            height: l.width,\n            width: d.chartWidth\n          } : {\n            x: l.y - d.plotLeft - d.spacingBox.x,\n            y: 0,\n            width: l.height,\n            height: d.chartHeight\n          });\n          h[m] ? h[m].animate(l) : (h[m] = e.clipRect(l), k && a[\"zone-graph-\" + m].clip(h[m]), n && a[\"zone-area-\" + m].clip(h[m]));\n          H = c.value > x.max;\n          a.resetZones && 0 === g && (g = void 0);\n        }), this.clips = h);\n      },\n      invertGroups: function invertGroups(a) {\n        function b() {\n          [\"group\", \"markerGroup\"].forEach(function (b) {\n            d[b] && (e.renderer.isVML && d[b].attr({\n              width: d.yAxis.len,\n              height: d.xAxis.len\n            }), d[b].width = d.yAxis.len, d[b].height = d.xAxis.len, d[b].invert(a));\n          });\n        }\n\n        var d = this,\n            e = d.chart,\n            f;\n        d.xAxis && (f = y(e, \"resize\", b), y(d, \"destroy\", f), b(a), d.invertGroups = b);\n      },\n      plotGroup: function plotGroup(a, b, d, e, f) {\n        var c = this[a],\n            g = !c;\n        g && (this[a] = c = this.chart.renderer.g().attr({\n          zIndex: e || .1\n        }).add(f));\n        c.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (v(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (c.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        c.attr({\n          visibility: d\n        })[g ? \"attr\" : \"animate\"](this.getPlotBox());\n        return c;\n      },\n      getPlotBox: function getPlotBox() {\n        var a = this.chart,\n            b = this.xAxis,\n            d = this.yAxis;\n        a.inverted && (b = d, d = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: d ? d.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      render: function render() {\n        var a = this,\n            b = a.chart,\n            d,\n            e = a.options,\n            f = !!a.animate && b.renderer.isSVG && F(e.animation).duration,\n            c = a.visible ? \"inherit\" : \"hidden\",\n            g = e.zIndex,\n            l = a.hasRendered,\n            k = b.seriesGroup,\n            n = b.inverted;\n        h(this, \"render\");\n        d = a.plotGroup(\"group\", \"series\", c, g, k);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", c, g, k);\n        f && a.animate(!0);\n        d.inverted = a.isCartesian ? n : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.drawDataLabels && a.drawDataLabels();\n        a.visible && a.drawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(n);\n        !1 === e.clip || a.sharedClipKey || l || d.clip(b.clipRect);\n        f && a.animate();\n        l || (a.animationTimeout = E(function () {\n          a.afterAnimate();\n        }, f));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        h(a, \"afterRender\");\n      },\n      redraw: function redraw() {\n        var a = this.chart,\n            d = this.isDirty || this.isDirtyData,\n            e = this.group,\n            c = this.xAxis,\n            f = this.yAxis;\n        e && (a.inverted && e.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), e.animate({\n          translateX: b(c && c.left, a.plotLeft),\n          translateY: b(f && f.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        d && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function searchPoint(a, b) {\n        var d = this.xAxis,\n            e = this.yAxis,\n            f = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: f ? d.len - a.chartY + d.pos : a.chartX - d.pos,\n          plotY: f ? e.len - a.chartX + e.pos : a.chartY - e.pos\n        }, b, a);\n      },\n      buildKDTree: function buildKDTree(a) {\n        function b(a, e, c) {\n          var f, g;\n          if (g = a && a.length) return f = d.kdAxisArray[e % c], a.sort(function (a, b) {\n            return a[f] - b[f];\n          }), g = Math.floor(g / 2), {\n            point: a[g],\n            left: b(a.slice(0, g), e + 1, c),\n            right: b(a.slice(g + 1), e + 1, c)\n          };\n        }\n\n        this.buildingKdTree = !0;\n        var d = this,\n            e = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete d.kdTree;\n        E(function () {\n          d.kdTree = b(d.getValidPoints(null, !d.directTouch), e, e);\n          d.buildingKdTree = !1;\n        }, d.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      },\n      searchKDTree: function searchKDTree(a, b, d) {\n        function e(a, b, d, m) {\n          var l = b.point,\n              k = f.kdAxisArray[d % m],\n              q,\n              n,\n              u = l;\n          n = v(a[c]) && v(l[c]) ? Math.pow(a[c] - l[c], 2) : null;\n          q = v(a[g]) && v(l[g]) ? Math.pow(a[g] - l[g], 2) : null;\n          q = (n || 0) + (q || 0);\n          l.dist = v(q) ? Math.sqrt(q) : Number.MAX_VALUE;\n          l.distX = v(n) ? Math.sqrt(n) : Number.MAX_VALUE;\n          k = a[k] - l[k];\n          q = 0 > k ? \"left\" : \"right\";\n          n = 0 > k ? \"right\" : \"left\";\n          b[q] && (q = e(a, b[q], d + 1, m), u = q[h] < u[h] ? q : l);\n          b[n] && Math.sqrt(k * k) < u[h] && (a = e(a, b[n], d + 1, m), u = a[h] < u[h] ? a : u);\n          return u;\n        }\n\n        var f = this,\n            c = this.kdAxisArray[0],\n            g = this.kdAxisArray[1],\n            h = b ? \"distX\" : \"dist\";\n        b = -1 < f.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(d);\n        if (this.kdTree) return e(a, this.kdTree, b, b);\n      },\n      pointPlacementToXValue: function pointPlacementToXValue() {\n        var a = this.options.pointPlacement;\n        \"between\" === a && (a = .5);\n        l(a) && (a *= b(this.options.pointRange || this.xAxis.pointRange));\n        return a;\n      }\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.Axis,\n        F = a.Chart,\n        G = a.correctFloat,\n        k = a.defined,\n        c = a.destroyObjectProperties,\n        p = a.format,\n        t = a.objectEach,\n        v = a.pick,\n        w = a.Series;\n\n    a.StackItem = function (a, c, e, l, k) {\n      var d = a.chart.inverted;\n      this.axis = a;\n      this.isNegative = e;\n      this.options = c;\n      this.x = l;\n      this.total = null;\n      this.points = {};\n      this.stack = k;\n      this.rightCliff = this.leftCliff = 0;\n      this.alignOptions = {\n        align: c.align || (d ? e ? \"left\" : \"right\" : \"center\"),\n        verticalAlign: c.verticalAlign || (d ? \"middle\" : e ? \"bottom\" : \"top\"),\n        y: v(c.y, d ? 4 : e ? 14 : -6),\n        x: v(c.x, d ? e ? -6 : 6 : 0)\n      };\n      this.textAlign = c.textAlign || (d ? e ? \"right\" : \"left\" : \"center\");\n    };\n\n    a.StackItem.prototype = {\n      destroy: function destroy() {\n        c(this, this.axis);\n      },\n      render: function render(a) {\n        var c = this.axis.chart,\n            e = this.options,\n            l = e.format,\n            l = l ? p(l, this, c.time) : e.formatter.call(this);\n        this.label ? this.label.attr({\n          text: l,\n          visibility: \"hidden\"\n        }) : this.label = c.renderer.text(l, null, null, e.useHTML).css(e.style).attr({\n          align: this.textAlign,\n          rotation: e.rotation,\n          visibility: \"hidden\"\n        }).add(a);\n        this.label.labelrank = c.plotHeight;\n      },\n      setOffset: function setOffset(a, c) {\n        var e = this.axis,\n            h = e.chart,\n            n = e.translate(e.usePercentage ? 100 : this.total, 0, 0, 0, 1),\n            d = e.translate(0),\n            d = k(n) && Math.abs(n - d);\n        a = h.xAxis[0].translate(this.x) + a;\n        e = k(n) && this.getStackBox(h, this, a, n, c, d, e);\n        (c = this.label) && e && (c.align(this.alignOptions, null, e), e = c.alignAttr, c[!1 === this.options.crop || h.isInsidePlot(e.x, e.y) ? \"show\" : \"hide\"](!0));\n      },\n      getStackBox: function getStackBox(a, c, e, l, k, d, g) {\n        var b = c.axis.reversed,\n            h = a.inverted;\n        a = g.height + g.pos - (h ? a.plotLeft : a.plotTop);\n        c = c.isNegative && !b || !c.isNegative && b;\n        return {\n          x: h ? c ? l : l - d : e,\n          y: h ? a - e - k : c ? a - l - d : a - l,\n          width: h ? d : k,\n          height: h ? k : d\n        };\n      }\n    };\n\n    F.prototype.getStacks = function () {\n      var a = this;\n      a.yAxis.forEach(function (a) {\n        a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);\n      });\n      a.series.forEach(function (c) {\n        !c.options.stacking || !0 !== c.visible && !1 !== a.options.chart.ignoreHiddenSeries || (c.stackKey = c.type + v(c.options.stack, \"\"));\n      });\n    };\n\n    y.prototype.buildStacks = function () {\n      var a = this.series,\n          c = v(this.options.reversedStacks, !0),\n          e = a.length,\n          l;\n\n      if (!this.isXAxis) {\n        this.usePercentage = !1;\n\n        for (l = e; l--;) {\n          a[c ? l : e - l - 1].setStackedPoints();\n        }\n\n        for (l = 0; l < e; l++) {\n          a[l].modifyStacks();\n        }\n      }\n    };\n\n    y.prototype.renderStackTotals = function () {\n      var a = this.chart,\n          c = a.renderer,\n          e = this.stacks,\n          l = this.stackTotalGroup;\n      l || (this.stackTotalGroup = l = c.g(\"stack-labels\").attr({\n        visibility: \"visible\",\n        zIndex: 6\n      }).add());\n      l.translate(a.plotLeft, a.plotTop);\n      t(e, function (a) {\n        t(a, function (a) {\n          a.render(l);\n        });\n      });\n    };\n\n    y.prototype.resetStacks = function () {\n      var a = this,\n          c = a.stacks;\n      a.isXAxis || t(c, function (e) {\n        t(e, function (c, h) {\n          c.touched < a.stacksTouched ? (c.destroy(), delete e[h]) : (c.total = null, c.cumulative = null);\n        });\n      });\n    };\n\n    y.prototype.cleanStacks = function () {\n      var a;\n      this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), t(a, function (a) {\n        t(a, function (a) {\n          a.cumulative = a.total;\n        });\n      }));\n    };\n\n    w.prototype.setStackedPoints = function () {\n      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var c = this.processedXData,\n            h = this.processedYData,\n            e = [],\n            l = h.length,\n            n = this.options,\n            d = n.threshold,\n            g = v(n.startFromThreshold && d, 0),\n            b = n.stack,\n            n = n.stacking,\n            x = this.stackKey,\n            u = \"-\" + x,\n            p = this.negStacks,\n            t = this.yAxis,\n            B = t.stacks,\n            m = t.oldStacks,\n            z,\n            D,\n            A,\n            f,\n            q,\n            w,\n            y;\n        t.stacksTouched += 1;\n\n        for (q = 0; q < l; q++) {\n          w = c[q], y = h[q], z = this.getStackIndicator(z, w, this.index), f = z.key, A = (D = p && y < (g ? 0 : d)) ? u : x, B[A] || (B[A] = {}), B[A][w] || (m[A] && m[A][w] ? (B[A][w] = m[A][w], B[A][w].total = null) : B[A][w] = new a.StackItem(t, t.options.stackLabels, D, w, b)), A = B[A][w], null !== y ? (A.points[f] = A.points[this.index] = [v(A.cumulative, g)], k(A.cumulative) || (A.base = f), A.touched = t.stacksTouched, 0 < z.index && !1 === this.singleStacks && (A.points[f][0] = A.points[this.index + \",\" + w + \",0\"][0])) : A.points[f] = A.points[this.index] = null, \"percent\" === n ? (D = D ? x : u, p && B[D] && B[D][w] ? (D = B[D][w], A.total = D.total = Math.max(D.total, A.total) + Math.abs(y) || 0) : A.total = G(A.total + (Math.abs(y) || 0))) : A.total = G(A.total + (y || 0)), A.cumulative = v(A.cumulative, g) + (y || 0), null !== y && (A.points[f].push(A.cumulative), e[q] = A.cumulative);\n        }\n\n        \"percent\" === n && (t.usePercentage = !0);\n        this.stackedYData = e;\n        t.oldStacks = {};\n      }\n    };\n\n    w.prototype.modifyStacks = function () {\n      var a = this,\n          c = a.stackKey,\n          e = a.yAxis.stacks,\n          l = a.processedXData,\n          k,\n          d = a.options.stacking;\n      a[d + \"Stacker\"] && [c, \"-\" + c].forEach(function (c) {\n        for (var b = l.length, g, h; b--;) {\n          if (g = l[b], k = a.getStackIndicator(k, g, a.index, c), h = (g = e[c] && e[c][g]) && g.points[k.key]) a[d + \"Stacker\"](h, g, b);\n        }\n      });\n    };\n\n    w.prototype.percentStacker = function (a, c, e) {\n      c = c.total ? 100 / c.total : 0;\n      a[0] = G(a[0] * c);\n      a[1] = G(a[1] * c);\n      this.stackedYData[e] = a[1];\n    };\n\n    w.prototype.getStackIndicator = function (a, c, e, l) {\n      !k(a) || a.x !== c || l && a.key !== l ? a = {\n        x: c,\n        index: 0,\n        key: l\n      } : a.index++;\n      a.key = [e, c, a.index].join();\n      return a;\n    };\n  })(I);\n\n  (function (a) {\n    var y = a.addEvent,\n        F = a.animate,\n        G = a.Axis,\n        k = a.Chart,\n        c = a.createElement,\n        p = a.css,\n        t = a.defined,\n        v = a.erase,\n        w = a.extend,\n        r = a.fireEvent,\n        h = a.isNumber,\n        e = a.isObject,\n        l = a.isArray,\n        n = a.merge,\n        d = a.objectEach,\n        g = a.pick,\n        b = a.Point,\n        x = a.Series,\n        u = a.seriesTypes,\n        H = a.setAnimation,\n        E = a.splat;\n\n    a.cleanRecursively = function (b, c) {\n      var g = {};\n      d(b, function (d, h) {\n        if (e(b[h], !0) && c[h]) d = a.cleanRecursively(b[h], c[h]), Object.keys(d).length && (g[h] = d);else if (e(b[h]) || b[h] !== c[h]) g[h] = b[h];\n      });\n      return g;\n    };\n\n    w(k.prototype, {\n      addSeries: function addSeries(a, b, d) {\n        var e,\n            c = this;\n        a && (b = g(b, !0), r(c, \"addSeries\", {\n          options: a\n        }, function () {\n          e = c.initSeries(a);\n          c.isDirtyLegend = !0;\n          c.linkSeries();\n          r(c, \"afterAddSeries\");\n          b && c.redraw(d);\n        }));\n        return e;\n      },\n      addAxis: function addAxis(a, b, d, e) {\n        var c = b ? \"xAxis\" : \"yAxis\",\n            f = this.options;\n        a = n(a, {\n          index: this[c].length,\n          isX: b\n        });\n        b = new G(this, a);\n        f[c] = E(f[c] || {});\n        f[c].push(a);\n        g(d, !0) && this.redraw(e);\n        return b;\n      },\n      showLoading: function showLoading(a) {\n        var b = this,\n            d = b.options,\n            e = b.loadingDiv,\n            g = d.loading,\n            f = function f() {\n          e && p(e, {\n            left: b.plotLeft + \"px\",\n            top: b.plotTop + \"px\",\n            width: b.plotWidth + \"px\",\n            height: b.plotHeight + \"px\"\n          });\n        };\n\n        e || (b.loadingDiv = e = c(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, b.container), b.loadingSpan = c(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, e), y(b, \"redraw\", f));\n        e.className = \"highcharts-loading\";\n        b.loadingSpan.innerHTML = a || d.lang.loading;\n        b.styledMode || (p(e, w(g.style, {\n          zIndex: 10\n        })), p(b.loadingSpan, g.labelStyle), b.loadingShown || (p(e, {\n          opacity: 0,\n          display: \"\"\n        }), F(e, {\n          opacity: g.style.opacity || .5\n        }, {\n          duration: g.showDuration || 0\n        })));\n        b.loadingShown = !0;\n        f();\n      },\n      hideLoading: function hideLoading() {\n        var a = this.options,\n            b = this.loadingDiv;\n        b && (b.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || F(b, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function complete() {\n            p(b, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      collectionsWithUpdate: \"xAxis yAxis zAxis series colorAxis pane\".split(\" \"),\n      update: function update(b, e, c, l) {\n        var m = this,\n            f = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\"\n        },\n            k,\n            u,\n            p,\n            x = [];\n        r(m, \"update\", {\n          options: b\n        });\n        b.isResponsiveOptions || m.setResponsive(!1, !0);\n        b = a.cleanRecursively(b, m.options);\n\n        if (k = b.chart) {\n          n(!0, m.options.chart, k);\n          \"className\" in k && m.setClassName(k.className);\n          \"reflow\" in k && m.setReflow(k.reflow);\n          if (\"inverted\" in k || \"polar\" in k || \"type\" in k) m.propFromSeries(), u = !0;\n          \"alignTicks\" in k && (u = !0);\n          d(k, function (a, b) {\n            -1 !== m.propsRequireUpdateSeries.indexOf(\"chart.\" + b) && (p = !0);\n            -1 !== m.propsRequireDirtyBox.indexOf(b) && (m.isDirtyBox = !0);\n          });\n          !m.styledMode && \"style\" in k && m.renderer.setStyle(k.style);\n        }\n\n        !m.styledMode && b.colors && (this.options.colors = b.colors);\n        b.plotOptions && n(!0, this.options.plotOptions, b.plotOptions);\n        d(b, function (a, b) {\n          if (m[b] && \"function\" === typeof m[b].update) m[b].update(a, !1);else if (\"function\" === typeof m[f[b]]) m[f[b]](a);\n          \"chart\" !== b && -1 !== m.propsRequireUpdateSeries.indexOf(b) && (p = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (a) {\n          var d;\n          b[a] && (\"series\" === a && (d = [], m[a].forEach(function (a, b) {\n            a.options.isInternal || d.push(g(a.options.index, b));\n          })), E(b[a]).forEach(function (b, f) {\n            (f = t(b.id) && m.get(b.id) || m[a][d ? d[f] : f]) && f.coll === a && (f.update(b, !1), c && (f.touched = !0));\n            if (!f && c) if (\"series\" === a) m.addSeries(b, !1).touched = !0;else if (\"xAxis\" === a || \"yAxis\" === a) m.addAxis(b, \"xAxis\" === a, !1).touched = !0;\n          }), c && m[a].forEach(function (a) {\n            a.touched || a.options.isInternal ? delete a.touched : x.push(a);\n          }));\n        });\n        x.forEach(function (a) {\n          a.remove && a.remove(!1);\n        });\n        u && m.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        p && m.series.forEach(function (a) {\n          a.update({}, !1);\n        });\n        b.loading && n(!0, m.options.loading, b.loading);\n        u = k && k.width;\n        k = k && k.height;\n        h(u) && u !== m.chartWidth || h(k) && k !== m.chartHeight ? m.setSize(u, k, l) : g(e, !0) && m.redraw(l);\n        r(m, \"afterUpdate\", {\n          options: b\n        });\n      },\n      setSubtitle: function setSubtitle(a) {\n        this.setTitle(void 0, a);\n      }\n    });\n    w(b.prototype, {\n      update: function update(a, b, d, c) {\n        function h() {\n          f.applyOptions(a);\n          null === f.y && l && (f.graphic = l.destroy());\n          e(a, !0) && (l && l.element && a && a.marker && void 0 !== a.marker.symbol && (f.graphic = l.destroy()), a && a.dataLabels && f.dataLabel && (f.dataLabel = f.dataLabel.destroy()), f.connector && (f.connector = f.connector.destroy()));\n          k = f.index;\n          m.updateParallelArrays(f, k);\n          u.data[k] = e(u.data[k], !0) || e(a, !0) ? f.options : g(a, u.data[k]);\n          m.isDirty = m.isDirtyData = !0;\n          !m.fixedBox && m.hasCartesianSeries && (n.isDirtyBox = !0);\n          \"point\" === u.legendType && (n.isDirtyLegend = !0);\n          b && n.redraw(d);\n        }\n\n        var f = this,\n            m = f.series,\n            l = f.graphic,\n            k,\n            n = m.chart,\n            u = m.options;\n        b = g(b, !0);\n        !1 === c ? h() : f.firePointEvent(\"update\", {\n          options: a\n        }, h);\n      },\n      remove: function remove(a, b) {\n        this.series.removePoint(this.series.data.indexOf(this), a, b);\n      }\n    });\n    w(x.prototype, {\n      addPoint: function addPoint(a, b, d, e) {\n        var c = this.options,\n            f = this.data,\n            h = this.chart,\n            m = this.xAxis,\n            m = m && m.hasNames && m.names,\n            l = c.data,\n            k,\n            n,\n            u = this.xData,\n            p,\n            r;\n        b = g(b, !0);\n        k = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(k, [a]);\n        r = k.x;\n        p = u.length;\n        if (this.requireSorting && r < u[p - 1]) for (n = !0; p && u[p - 1] > r;) {\n          p--;\n        }\n        this.updateParallelArrays(k, \"splice\", p, 0, 0);\n        this.updateParallelArrays(k, p);\n        m && k.name && (m[r] = k.name);\n        l.splice(p, 0, a);\n        n && (this.data.splice(p, 0, null), this.processData());\n        \"point\" === c.legendType && this.generatePoints();\n        d && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(k, \"shift\"), l.shift()));\n        this.isDirtyData = this.isDirty = !0;\n        b && h.redraw(e);\n      },\n      removePoint: function removePoint(a, b, d) {\n        var e = this,\n            c = e.data,\n            f = c[a],\n            h = e.points,\n            m = e.chart,\n            l = function l() {\n          h && h.length === c.length && h.splice(a, 1);\n          c.splice(a, 1);\n          e.options.data.splice(a, 1);\n          e.updateParallelArrays(f || {\n            series: e\n          }, \"splice\", a, 1);\n          f && f.destroy();\n          e.isDirty = !0;\n          e.isDirtyData = !0;\n          b && m.redraw();\n        };\n\n        H(d, m);\n        b = g(b, !0);\n        f ? f.firePointEvent(\"remove\", null, l) : l();\n      },\n      remove: function remove(a, b, d, e) {\n        function c() {\n          f.destroy(e);\n          f.remove = null;\n          h.isDirtyLegend = h.isDirtyBox = !0;\n          h.linkSeries();\n          g(a, !0) && h.redraw(b);\n        }\n\n        var f = this,\n            h = f.chart;\n        !1 !== d ? r(f, \"remove\", null, c) : c();\n      },\n      update: function update(b, d) {\n        b = a.cleanRecursively(b, this.userOptions);\n        var e = this,\n            c = e.chart,\n            h = e.userOptions,\n            f = e.initialType || e.type,\n            m = b.type || h.type || c.options.chart.type,\n            l = u[f].prototype,\n            k,\n            p = [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n            x = [\"navigatorSeries\", \"baseSeries\"],\n            t = e.finishedAnimating && {\n          animation: !1\n        },\n            v = [\"data\", \"name\", \"turboThreshold\"],\n            B = Object.keys(b),\n            E = 0 < B.length;\n        B.forEach(function (a) {\n          -1 === v.indexOf(a) && (E = !1);\n        });\n        if (E) b.data && this.setData(b.data, !1), b.name && this.setName(b.name, !1);else {\n          x = p.concat(x);\n          x.forEach(function (a) {\n            x[a] = e[a];\n            delete e[a];\n          });\n          b = n(h, t, {\n            index: e.index,\n            pointStart: g(h.pointStart, e.xData[0])\n          }, {\n            data: e.options.data\n          }, b);\n          e.remove(!1, null, !1, !0);\n\n          for (k in l) {\n            e[k] = void 0;\n          }\n\n          u[m || f] ? w(e, u[m || f].prototype) : a.error(17, !0, c);\n          x.forEach(function (a) {\n            e[a] = x[a];\n          });\n          e.init(c, b);\n          b.zIndex !== h.zIndex && p.forEach(function (a) {\n            e[a] && e[a].attr({\n              zIndex: b.zIndex\n            });\n          });\n          e.initialType = f;\n          c.linkSeries();\n        }\n        r(this, \"afterUpdate\");\n        g(d, !0) && c.redraw(E ? void 0 : !1);\n      },\n      setName: function setName(a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    w(G.prototype, {\n      update: function update(a, b) {\n        var e = this.chart,\n            c = a && a.events || {};\n        a = n(this.userOptions, a);\n        e.options[this.coll].indexOf && (e.options[this.coll][e.options[this.coll].indexOf(this.userOptions)] = a);\n        d(e.options[this.coll].events, function (a, b) {\n          \"undefined\" === typeof c[b] && (c[b] = void 0);\n        });\n        this.destroy(!0);\n        this.init(e, w(a, {\n          events: c\n        }));\n        e.isDirtyBox = !0;\n        g(b, !0) && e.redraw();\n      },\n      remove: function remove(a) {\n        for (var b = this.chart, d = this.coll, e = this.series, c = e.length; c--;) {\n          e[c] && e[c].remove(!1);\n        }\n\n        v(b.axes, this);\n        v(b[d], this);\n        l(b.options[d]) ? b.options[d].splice(this.options.index, 1) : delete b.options[d];\n        b[d].forEach(function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });\n        this.destroy();\n        b.isDirtyBox = !0;\n        g(a, !0) && b.redraw();\n      },\n      setTitle: function setTitle(a, b) {\n        this.update({\n          title: a\n        }, b);\n      },\n      setCategories: function setCategories(a, b) {\n        this.update({\n          categories: a\n        }, b);\n      }\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.color,\n        F = a.pick,\n        G = a.Series,\n        k = a.seriesType;\n    k(\"area\", \"line\", {\n      softThreshold: !1,\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function getStackPoints(c) {\n        var k = [],\n            t = [],\n            v = this.xAxis,\n            w = this.yAxis,\n            r = w.stacks[this.stackKey],\n            h = {},\n            e = this.index,\n            l = w.series,\n            n = l.length,\n            d,\n            g = F(w.options.reversedStacks, !0) ? 1 : -1,\n            b;\n        c = c || this.points;\n\n        if (this.options.stacking) {\n          for (b = 0; b < c.length; b++) {\n            c[b].leftNull = c[b].rightNull = null, h[c[b].x] = c[b];\n          }\n\n          a.objectEach(r, function (a, b) {\n            null !== a.total && t.push(b);\n          });\n          t.sort(function (a, b) {\n            return a - b;\n          });\n          d = l.map(function (a) {\n            return a.visible;\n          });\n          t.forEach(function (a, c) {\n            var l = 0,\n                u,\n                p;\n            if (h[a] && !h[a].isNull) k.push(h[a]), [-1, 1].forEach(function (l) {\n              var k = 1 === l ? \"rightNull\" : \"leftNull\",\n                  m = 0,\n                  x = r[t[c + l]];\n              if (x) for (b = e; 0 <= b && b < n;) {\n                u = x.points[b], u || (b === e ? h[a][k] = !0 : d[b] && (p = r[a].points[b]) && (m -= p[1] - p[0])), b += g;\n              }\n              h[a][1 === l ? \"rightCliff\" : \"leftCliff\"] = m;\n            });else {\n              for (b = e; 0 <= b && b < n;) {\n                if (u = r[a].points[b]) {\n                  l = u[1];\n                  break;\n                }\n\n                b += g;\n              }\n\n              l = w.translate(l, 0, 1, 0, 1);\n              k.push({\n                isNull: !0,\n                plotX: v.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: l,\n                yBottom: l\n              });\n            }\n          });\n        }\n\n        return k;\n      },\n      getGraphPath: function getGraphPath(a) {\n        var c = G.prototype.getGraphPath,\n            k = this.options,\n            v = k.stacking,\n            w = this.yAxis,\n            r,\n            h,\n            e = [],\n            l = [],\n            n = this.index,\n            d,\n            g = w.stacks[this.stackKey],\n            b = k.threshold,\n            x = w.getThreshold(k.threshold),\n            u,\n            k = k.connectNulls || \"percent\" === v,\n            H = function H(c, h, k) {\n          var m = a[c];\n          c = v && g[m.x].points[n];\n          var u = m[k + \"Null\"] || 0;\n          k = m[k + \"Cliff\"] || 0;\n          var p,\n              f,\n              m = !0;\n          k || u ? (p = (u ? c[0] : c[1]) + k, f = c[0] + k, m = !!u) : !v && a[h] && a[h].isNull && (p = f = b);\n          void 0 !== p && (l.push({\n            plotX: d,\n            plotY: null === p ? x : w.getThreshold(p),\n            isNull: m,\n            isCliff: !0\n          }), e.push({\n            plotX: d,\n            plotY: null === f ? x : w.getThreshold(f),\n            doCurve: !1\n          }));\n        };\n\n        a = a || this.points;\n        v && (a = this.getStackPoints(a));\n\n        for (r = 0; r < a.length; r++) {\n          if (h = a[r].isNull, d = F(a[r].rectPlotX, a[r].plotX), u = F(a[r].yBottom, x), !h || k) k || H(r, r - 1, \"left\"), h && !v && k || (l.push(a[r]), e.push({\n            x: r,\n            plotX: d,\n            plotY: u\n          })), k || H(r, r + 1, \"right\");\n        }\n\n        r = c.call(this, l, !0, !0);\n        e.reversed = !0;\n        h = c.call(this, e, !0, !0);\n        h.length && (h[0] = \"L\");\n        h = r.concat(h);\n        c = c.call(this, l, !1, k);\n        h.xMap = r.xMap;\n        this.areaPath = h;\n        return c;\n      },\n      drawGraph: function drawGraph() {\n        this.areaPath = [];\n        G.prototype.drawGraph.apply(this);\n        var a = this,\n            k = this.areaPath,\n            t = this.options,\n            v = [[\"area\", \"highcharts-area\", this.color, t.fillColor]];\n        this.zones.forEach(function (c, k) {\n          v.push([\"zone-area-\" + k, \"highcharts-area highcharts-zone-area-\" + k + \" \" + c.className, c.color || a.color, c.fillColor || t.fillColor]);\n        });\n        v.forEach(function (c) {\n          var p = c[0],\n              h = a[p];\n          h ? (h.endX = a.preventGraphAnimation ? null : k.xMap, h.animate({\n            d: k\n          })) : (h = {\n            zIndex: 0\n          }, a.chart.styledMode || (h.fill = F(c[3], y(c[2]).setOpacity(F(t.fillOpacity, .75)).get())), h = a[p] = a.chart.renderer.path(k).addClass(c[1]).attr(h).add(a.group), h.isArea = !0);\n          h.startX = k.xMap;\n          h.shiftUnit = t.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.pick;\n    a = a.seriesType;\n    a(\"spline\", \"line\", {}, {\n      getPointSpline: function getPointSpline(a, G, k) {\n        var c = G.plotX,\n            p = G.plotY,\n            t = a[k - 1];\n        k = a[k + 1];\n        var v, w, r, h;\n\n        if (t && !t.isNull && !1 !== t.doCurve && !G.isCliff && k && !k.isNull && !1 !== k.doCurve && !G.isCliff) {\n          a = t.plotY;\n          r = k.plotX;\n          k = k.plotY;\n          var e = 0;\n          v = (1.5 * c + t.plotX) / 2.5;\n          w = (1.5 * p + a) / 2.5;\n          r = (1.5 * c + r) / 2.5;\n          h = (1.5 * p + k) / 2.5;\n          r !== v && (e = (h - w) * (r - c) / (r - v) + p - h);\n          w += e;\n          h += e;\n          w > a && w > p ? (w = Math.max(a, p), h = 2 * p - w) : w < a && w < p && (w = Math.min(a, p), h = 2 * p - w);\n          h > k && h > p ? (h = Math.max(k, p), w = 2 * p - h) : h < k && h < p && (h = Math.min(k, p), w = 2 * p - h);\n          G.rightContX = r;\n          G.rightContY = h;\n        }\n\n        G = [\"C\", y(t.rightContX, t.plotX), y(t.rightContY, t.plotY), y(v, c), y(w, p), c, p];\n        t.rightContX = t.rightContY = null;\n        return G;\n      }\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.seriesTypes.area.prototype,\n        F = a.seriesType;\n    F(\"areaspline\", \"spline\", a.defaultPlotOptions.area, {\n      getStackPoints: y.getStackPoints,\n      getGraphPath: y.getGraphPath,\n      drawGraph: y.drawGraph,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.animObject,\n        F = a.color,\n        G = a.extend,\n        k = a.defined,\n        c = a.isNumber,\n        p = a.merge,\n        t = a.pick,\n        v = a.Series,\n        w = a.seriesType,\n        r = a.svg;\n    w(\"column\", \"line\", {\n      borderRadius: 0,\n      crisp: !0,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: null,\n        verticalAlign: null,\n        y: null\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function init() {\n        v.prototype.init.apply(this, arguments);\n        var a = this,\n            e = a.chart;\n        e.hasRendered && e.series.forEach(function (e) {\n          e.type === a.type && (e.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function getColumnMetrics() {\n        var a = this,\n            e = a.options,\n            c = a.xAxis,\n            k = a.yAxis,\n            d = c.options.reversedStacks,\n            d = c.reversed && !d || !c.reversed && d,\n            g,\n            b = {},\n            p = 0;\n        !1 === e.grouping ? p = 1 : a.chart.series.forEach(function (d) {\n          var e = d.options,\n              c = d.yAxis,\n              h;\n          d.type !== a.type || !d.visible && a.chart.options.chart.ignoreHiddenSeries || k.len !== c.len || k.pos !== c.pos || (e.stacking ? (g = d.stackKey, void 0 === b[g] && (b[g] = p++), h = b[g]) : !1 !== e.grouping && (h = p++), d.columnIndex = h);\n        });\n        var u = Math.min(Math.abs(c.transA) * (c.ordinalSlope || e.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),\n            r = u * e.groupPadding,\n            v = (u - 2 * r) / (p || 1),\n            e = Math.min(e.maxPointWidth || c.len, t(e.pointWidth, v * (1 - 2 * e.pointPadding)));\n        a.columnMetrics = {\n          width: e,\n          offset: (v - e) / 2 + (r + ((a.columnIndex || 0) + (d ? 1 : 0)) * v - u / 2) * (d ? -1 : 1)\n        };\n        return a.columnMetrics;\n      },\n      crispCol: function crispCol(a, e, c, k) {\n        var d = this.chart,\n            g = this.borderWidth,\n            b = -(g % 2 ? .5 : 0),\n            g = g % 2 ? .5 : 1;\n        d.inverted && d.renderer.isVML && (g += 1);\n        this.options.crisp && (c = Math.round(a + c) + b, a = Math.round(a) + b, c -= a);\n        k = Math.round(e + k) + g;\n        b = .5 >= Math.abs(e) && .5 < k;\n        e = Math.round(e) + g;\n        k -= e;\n        b && k && (--e, k += 1);\n        return {\n          x: a,\n          y: e,\n          width: c,\n          height: k\n        };\n      },\n      translate: function translate() {\n        var a = this,\n            e = a.chart,\n            c = a.options,\n            n = a.dense = 2 > a.closestPointRange * a.xAxis.transA,\n            n = a.borderWidth = t(c.borderWidth, n ? 0 : 1),\n            d = a.yAxis,\n            g = c.threshold,\n            b = a.translatedThreshold = d.getThreshold(g),\n            p = t(c.minPointLength, 5),\n            u = a.getColumnMetrics(),\n            r = u.width,\n            E = a.barW = Math.max(r, 1 + 2 * n),\n            B = a.pointXOffset = u.offset;\n        e.inverted && (b -= .5);\n        c.pointPadding && (E = Math.ceil(E));\n        v.prototype.translate.apply(a);\n        a.points.forEach(function (c) {\n          var h = t(c.yBottom, b),\n              l = 999 + Math.abs(h),\n              m = r,\n              l = Math.min(Math.max(-l, c.plotY), d.len + l),\n              f = c.plotX + B,\n              n = E,\n              u = Math.min(l, h),\n              x,\n              v = Math.max(l, h) - u;\n          p && Math.abs(v) < p && (v = p, x = !d.reversed && !c.negative || d.reversed && c.negative, c.y === g && a.dataMax <= g && d.min < g && (x = !x), u = Math.abs(u - b) > p ? h - p : b - (x ? p : 0));\n          k(c.options.pointWidth) && (m = n = Math.ceil(c.options.pointWidth), f -= Math.round((m - r) / 2));\n          c.barX = f;\n          c.pointWidth = m;\n          c.tooltipPos = e.inverted ? [d.len + d.pos - e.plotLeft - l, a.xAxis.len - f - n / 2, v] : [f + n / 2, l + d.pos - e.plotTop, v];\n          c.shapeType = c.shapeType || \"rect\";\n          c.shapeArgs = a.crispCol.apply(a, c.isNull ? [f, b, n, 0] : [f, u, n, v]);\n        });\n      },\n      getSymbol: a.noop,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      drawGraph: function drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function pointAttribs(a, e) {\n        var c = this.options,\n            h,\n            d = this.pointAttrToOptions || {};\n        h = d.stroke || \"borderColor\";\n        var g = d[\"stroke-width\"] || \"borderWidth\",\n            b = a && a.color || this.color,\n            k = a && a[h] || c[h] || this.color || b,\n            u = a && a[g] || c[g] || this[g] || 0,\n            d = c.dashStyle;\n        a && this.zones.length && (b = a.getZone(), b = a.options.color || b && b.color || this.color);\n        e && (a = p(c.states[e], a.options.states && a.options.states[e] || {}), e = a.brightness, b = a.color || void 0 !== e && F(b).brighten(a.brightness).get() || b, k = a[h] || k, u = a[g] || u, d = a.dashStyle || d);\n        h = {\n          fill: b,\n          stroke: k,\n          \"stroke-width\": u\n        };\n        d && (h.dashstyle = d);\n        return h;\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            e = this.chart,\n            k = a.options,\n            n = e.renderer,\n            d = k.animationLimit || 250,\n            g;\n        a.points.forEach(function (b) {\n          var h = b.graphic,\n              l = h && e.pointCount < d ? \"animate\" : \"attr\";\n\n          if (c(b.plotY) && null !== b.y) {\n            g = b.shapeArgs;\n            if (h) h[l](p(g));else b.graphic = h = n[b.shapeType](g).add(b.group || a.group);\n            k.borderRadius && h.attr({\n              r: k.borderRadius\n            });\n            e.styledMode || h[l](a.pointAttribs(b, b.selected && \"select\")).shadow(k.shadow, null, k.stacking && !k.borderRadius);\n            h.addClass(b.getClassName(), !0);\n          } else h && (b.graphic = h.destroy());\n        });\n      },\n      animate: function animate(a) {\n        var e = this,\n            c = this.yAxis,\n            h = e.options,\n            d = this.chart.inverted,\n            g = {},\n            b = d ? \"translateX\" : \"translateY\",\n            k;\n        r && (a ? (g.scaleY = .001, a = Math.min(c.pos + c.len, Math.max(c.pos, c.toPixels(h.threshold))), d ? g.translateX = a - c.len : g.translateY = a, e.clipBox && e.setClip(), e.group.attr(g)) : (k = e.group.attr(b), e.group.animate({\n          scaleY: 1\n        }, G(y(e.options.animation), {\n          step: function step(a, d) {\n            g[b] = k + d.pos * (c.pos - k);\n            e.group.attr(g);\n          }\n        })), e.animate = null));\n      },\n      remove: function remove() {\n        var a = this,\n            e = a.chart;\n        e.hasRendered && e.series.forEach(function (e) {\n          e.type === a.type && (e.isDirty = !0);\n        });\n        v.prototype.remove.apply(a, arguments);\n      }\n    });\n  })(I);\n\n  (function (a) {\n    a = a.seriesType;\n    a(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.Series,\n        F = a.seriesType;\n    F(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <span style=\\\"font-size: 10px\\\"> {series.name}</span><br/>\",\n        pointFormat: \"x: \\x3cb\\x3e{point.x}\\x3c/b\\x3e\\x3cbr/\\x3ey: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function drawGraph() {\n        this.options.lineWidth && y.prototype.drawGraph.call(this);\n      },\n      applyJitter: function applyJitter() {\n        var a = this,\n            k = this.options.jitter,\n            c = this.points.length;\n        k && this.points.forEach(function (p, t) {\n          [\"x\", \"y\"].forEach(function (v, w) {\n            var r,\n                h = \"plot\" + v.toUpperCase(),\n                e,\n                l;\n            k[v] && !p.isNull && (r = a[v + \"Axis\"], l = k[v] * r.transA, r && !r.isLog && (e = Math.max(0, p[h] - l), r = Math.min(r.len, p[h] + l), w = 1E4 * Math.sin(t + w * c), p[h] = e + (r - e) * (w - Math.floor(w)), \"x\" === v && (p.clientX = p.plotX)));\n          });\n        });\n      }\n    });\n    a.addEvent(y, \"afterTranslate\", function () {\n      this.applyJitter && this.applyJitter();\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.deg2rad,\n        F = a.isNumber,\n        G = a.pick,\n        k = a.relativeLength;\n    a.CenteredSeriesMixin = {\n      getCenter: function getCenter() {\n        var a = this.options,\n            p = this.chart,\n            t = 2 * (a.slicedOffset || 0),\n            v = p.plotWidth - 2 * t,\n            p = p.plotHeight - 2 * t,\n            w = a.center,\n            w = [G(w[0], \"50%\"), G(w[1], \"50%\"), a.size || \"100%\", a.innerSize || 0],\n            r = Math.min(v, p),\n            h,\n            e;\n\n        for (h = 0; 4 > h; ++h) {\n          e = w[h], a = 2 > h || 2 === h && /%$/.test(e), w[h] = k(e, [v, p, r, w[2]][h]) + (a ? t : 0);\n        }\n\n        w[3] > w[2] && (w[3] = w[2]);\n        return w;\n      },\n      getStartAndEndRadians: function getStartAndEndRadians(a, k) {\n        a = F(a) ? a : 0;\n        k = F(k) && k > a && 360 > k - a ? k : a + 360;\n        return {\n          start: y * (a + -90),\n          end: y * (k + -90)\n        };\n      }\n    };\n  })(I);\n\n  (function (a) {\n    var y = a.addEvent,\n        F = a.CenteredSeriesMixin,\n        G = a.defined,\n        k = a.extend,\n        c = F.getStartAndEndRadians,\n        p = a.noop,\n        t = a.pick,\n        v = a.Point,\n        w = a.Series,\n        r = a.seriesType,\n        h = a.setAnimation;\n    r(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0,\n        connectorShape: \"fixedOffset\",\n        crookDistance: \"70%\"\n      },\n      ignoreHiddenPoint: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: a.seriesTypes.column.prototype.pointAttribs,\n      animate: function animate(a) {\n        var e = this,\n            c = e.points,\n            d = e.startAngleRad;\n        a || (c.forEach(function (a) {\n          var b = a.graphic,\n              c = a.shapeArgs;\n          b && (b.attr({\n            r: a.startR || e.center[3] / 2,\n            start: d,\n            end: d\n          }), b.animate({\n            r: c.r,\n            start: c.start,\n            end: c.end\n          }, e.options.animation));\n        }), e.animate = null);\n      },\n      updateTotals: function updateTotals() {\n        var a,\n            c = 0,\n            h = this.points,\n            d = h.length,\n            g,\n            b = this.options.ignoreHiddenPoint;\n\n        for (a = 0; a < d; a++) {\n          g = h[a], c += b && !g.visible ? 0 : g.isNull ? 0 : g.y;\n        }\n\n        this.total = c;\n\n        for (a = 0; a < d; a++) {\n          g = h[a], g.percentage = 0 < c && (g.visible || !b) ? g.y / c * 100 : 0, g.total = c;\n        }\n      },\n      generatePoints: function generatePoints() {\n        w.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      getX: function getX(a, c, h) {\n        var d = this.center,\n            e = this.radii ? this.radii[h.index] : d[2] / 2;\n        return d[0] + (c ? -1 : 1) * Math.cos(Math.asin(Math.max(Math.min((a - d[1]) / (e + h.labelDistance), 1), -1))) * (e + h.labelDistance) + (0 < h.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);\n      },\n      translate: function translate(a) {\n        this.generatePoints();\n        var e = 0,\n            h = this.options,\n            d = h.slicedOffset,\n            g = d + (h.borderWidth || 0),\n            b,\n            k,\n            u = c(h.startAngle, h.endAngle),\n            p = this.startAngleRad = u.start,\n            u = (this.endAngleRad = u.end) - p,\n            r = this.points,\n            v,\n            m,\n            z = h.dataLabels.distance,\n            h = h.ignoreHiddenPoint,\n            w,\n            A = r.length,\n            f;\n        a || (this.center = a = this.getCenter());\n\n        for (w = 0; w < A; w++) {\n          f = r[w];\n          f.labelDistance = t(f.options.dataLabels && f.options.dataLabels.distance, z);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, f.labelDistance);\n          b = p + e * u;\n          if (!h || f.visible) e += f.percentage / 100;\n          k = p + e * u;\n          f.shapeType = \"arc\";\n          f.shapeArgs = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * b) / 1E3,\n            end: Math.round(1E3 * k) / 1E3\n          };\n          k = (k + b) / 2;\n          k > 1.5 * Math.PI ? k -= 2 * Math.PI : k < -Math.PI / 2 && (k += 2 * Math.PI);\n          f.slicedTranslation = {\n            translateX: Math.round(Math.cos(k) * d),\n            translateY: Math.round(Math.sin(k) * d)\n          };\n          v = Math.cos(k) * a[2] / 2;\n          m = Math.sin(k) * a[2] / 2;\n          f.tooltipPos = [a[0] + .7 * v, a[1] + .7 * m];\n          f.half = k < -Math.PI / 2 || k > Math.PI / 2 ? 1 : 0;\n          f.angle = k;\n          b = Math.min(g, f.labelDistance / 5);\n          f.labelPosition = {\n            natural: {\n              x: a[0] + v + Math.cos(k) * f.labelDistance,\n              y: a[1] + m + Math.sin(k) * f.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > f.labelDistance ? \"center\" : f.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: a[0] + v + Math.cos(k) * b,\n                y: a[1] + m + Math.sin(k) * b\n              },\n              touchingSliceAt: {\n                x: a[0] + v,\n                y: a[1] + m\n              }\n            }\n          };\n        }\n      },\n      drawGraph: null,\n      drawPoints: function drawPoints() {\n        var a = this,\n            c = a.chart,\n            h = c.renderer,\n            d,\n            g,\n            b,\n            p,\n            u = a.options.shadow;\n        !u || a.shadowGroup || c.styledMode || (a.shadowGroup = h.g(\"shadow\").add(a.group));\n        a.points.forEach(function (e) {\n          g = e.graphic;\n          if (e.isNull) g && (e.graphic = g.destroy());else {\n            p = e.shapeArgs;\n            d = e.getTranslate();\n\n            if (!c.styledMode) {\n              var l = e.shadowGroup;\n              u && !l && (l = e.shadowGroup = h.g(\"shadow\").add(a.shadowGroup));\n              l && l.attr(d);\n              b = a.pointAttribs(e, e.selected && \"select\");\n            }\n\n            g ? (g.setRadialReference(a.center), c.styledMode || g.attr(b), g.animate(k(p, d))) : (e.graphic = g = h[e.shapeType](p).setRadialReference(a.center).attr(d).add(a.group), c.styledMode || g.attr(b).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(u, l));\n            g.attr({\n              visibility: e.visible ? \"inherit\" : \"hidden\"\n            });\n            g.addClass(e.getClassName());\n          }\n        });\n      },\n      searchPoint: p,\n      sortByAngle: function sortByAngle(a, c) {\n        a.sort(function (a, d) {\n          return void 0 !== a.angle && (d.angle - a.angle) * c;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      getCenter: F.getCenter,\n      getSymbol: p\n    }, {\n      init: function init() {\n        v.prototype.init.apply(this, arguments);\n        var a = this,\n            c;\n        a.name = t(a.name, \"Slice\");\n\n        c = function c(e) {\n          a.slice(\"select\" === e.type);\n        };\n\n        y(a, \"select\", c);\n        y(a, \"unselect\", c);\n        return a;\n      },\n      isValid: function isValid() {\n        return a.isNumber(this.y, !0) && 0 <= this.y;\n      },\n      setVisible: function setVisible(a, c) {\n        var e = this,\n            d = e.series,\n            g = d.chart,\n            b = d.options.ignoreHiddenPoint;\n        c = t(c, b);\n        a !== e.visible && (e.visible = e.options.visible = a = void 0 === a ? !e.visible : a, d.options.data[d.data.indexOf(e)] = e.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (b) {\n          if (e[b]) e[b][a ? \"show\" : \"hide\"](!0);\n        }), e.legendItem && g.legend.colorizeItem(e, a), a || \"hover\" !== e.state || e.setState(\"\"), b && (d.isDirty = !0), c && g.redraw());\n      },\n      slice: function slice(a, c, k) {\n        var d = this.series;\n        h(k, d.chart);\n        t(c, !0);\n        this.sliced = this.options.sliced = G(a) ? a : !this.sliced;\n        d.options.data[d.data.indexOf(this)] = this.options;\n        this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function haloPath(a) {\n        var e = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + a, e.r + a, {\n          innerR: this.shapeArgs.r - 1,\n          start: e.start,\n          end: e.end\n        });\n      },\n      connectorShapes: {\n        fixedOffset: function fixedOffset(a, c, h) {\n          var d = c.breakAt;\n          c = c.touchingSliceAt;\n          return [\"M\", a.x, a.y].concat(h.softConnector ? [\"C\", a.x + (\"left\" === a.alignment ? -5 : 5), a.y, 2 * d.x - c.x, 2 * d.y - c.y, d.x, d.y] : [\"L\", d.x, d.y]).concat([\"L\", c.x, c.y]);\n        },\n        straight: function straight(a, c) {\n          c = c.touchingSliceAt;\n          return [\"M\", a.x, a.y, \"L\", c.x, c.y];\n        },\n        crookedLine: function crookedLine(e, c, h) {\n          c = c.touchingSliceAt;\n          var d = this.series,\n              g = d.center[0],\n              b = d.chart.plotWidth,\n              k = d.chart.plotLeft,\n              d = e.alignment,\n              l = this.shapeArgs.r;\n          h = a.relativeLength(h.crookDistance, 1);\n          h = \"left\" === d ? g + l + (b + k - g - l) * (1 - h) : k + (g - l) * h;\n          g = [\"L\", h, e.y];\n          if (\"left\" === d ? h > e.x || h < c.x : h < e.x || h > c.x) g = [];\n          return [\"M\", e.x, e.y].concat(g).concat([\"L\", c.x, c.y]);\n        }\n      },\n      getConnectorPath: function getConnectorPath() {\n        var a = this.labelPosition,\n            c = this.series.options.dataLabels,\n            h = c.connectorShape,\n            d = this.connectorShapes;\n        d[h] && (h = d[h]);\n        return h.call(this, {\n          x: a.final.x,\n          y: a.final.y,\n          alignment: a.alignment\n        }, a.connectorPosition, c);\n      }\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.addEvent,\n        F = a.arrayMax,\n        G = a.defined,\n        k = a.extend,\n        c = a.format,\n        p = a.merge,\n        t = a.noop,\n        v = a.pick,\n        w = a.relativeLength,\n        r = a.Series,\n        h = a.seriesTypes,\n        e = a.stableSort,\n        l = a.isArray,\n        n = a.splat;\n\n    a.distribute = function (d, c, b) {\n      function g(a, b) {\n        return a.target - b.target;\n      }\n\n      var h,\n          k = !0,\n          l = d,\n          n = [],\n          m;\n      m = 0;\n      var p = l.reducedLen || c;\n\n      for (h = d.length; h--;) {\n        m += d[h].size;\n      }\n\n      if (m > p) {\n        e(d, function (a, b) {\n          return (b.rank || 0) - (a.rank || 0);\n        });\n\n        for (m = h = 0; m <= p;) {\n          m += d[h].size, h++;\n        }\n\n        n = d.splice(h - 1, d.length);\n      }\n\n      e(d, g);\n\n      for (d = d.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: v(a.align, .5)\n        };\n      }); k;) {\n        for (h = d.length; h--;) {\n          k = d[h], m = (Math.min.apply(0, k.targets) + Math.max.apply(0, k.targets)) / 2, k.pos = Math.min(Math.max(0, m - k.size * k.align), c - k.size);\n        }\n\n        h = d.length;\n\n        for (k = !1; h--;) {\n          0 < h && d[h - 1].pos + d[h - 1].size > d[h].pos && (d[h - 1].size += d[h].size, d[h - 1].targets = d[h - 1].targets.concat(d[h].targets), d[h - 1].align = .5, d[h - 1].pos + d[h - 1].size > c && (d[h - 1].pos = c - d[h - 1].size), d.splice(h, 1), k = !0);\n        }\n      }\n\n      l.push.apply(l, n);\n      h = 0;\n      d.some(function (d) {\n        var e = 0;\n        if (d.targets.some(function () {\n          l[h].pos = d.pos + e;\n          if (Math.abs(l[h].pos - l[h].target) > b) return l.slice(0, h + 1).forEach(function (a) {\n            delete a.pos;\n          }), l.reducedLen = (l.reducedLen || c) - .1 * c, l.reducedLen > .1 * c && a.distribute(l, c, b), !0;\n          e += l[h].size;\n          h++;\n        })) return !0;\n      });\n      e(l, g);\n    };\n\n    r.prototype.drawDataLabels = function () {\n      function d(a, b) {\n        var d = b.filter;\n        return d ? (b = d.operator, a = a[d.property], d = d.value, \"\\x3e\" === b && a > d || \"\\x3c\" === b && a < d || \"\\x3e\\x3d\" === b && a >= d || \"\\x3c\\x3d\" === b && a <= d || \"\\x3d\\x3d\" === b && a == d || \"\\x3d\\x3d\\x3d\" === b && a === d ? !0 : !1) : !0;\n      }\n\n      function e(a, b) {\n        var d = [],\n            c;\n        if (l(a) && !l(b)) d = a.map(function (a) {\n          return p(a, b);\n        });else if (l(b) && !l(a)) d = b.map(function (b) {\n          return p(a, b);\n        });else if (l(a) || l(b)) for (c = Math.max(a.length, b.length); c--;) {\n          d[c] = p(a[c], b[c]);\n        } else d = p(a, b);\n        return d;\n      }\n\n      var b = this,\n          h = b.chart,\n          k = b.options,\n          r = k.dataLabels,\n          t = b.points,\n          w,\n          m = b.hasRendered || 0,\n          z,\n          D = v(r.defer, !!k.animation),\n          A = h.renderer,\n          r = e(e(h.options.plotOptions && h.options.plotOptions.series && h.options.plotOptions.series.dataLabels, h.options.plotOptions && h.options.plotOptions[b.type] && h.options.plotOptions[b.type].dataLabels), r);\n      a.fireEvent(this, \"drawDataLabels\");\n      if (l(r) || r.enabled || b._hasPointLabels) z = b.plotGroup(\"dataLabelsGroup\", \"data-labels\", D && !m ? \"hidden\" : \"visible\", r.zIndex || 6), D && (z.attr({\n        opacity: +m\n      }), m || y(b, \"afterAnimate\", function () {\n        b.visible && z.show(!0);\n        z[k.animation ? \"animate\" : \"attr\"]({\n          opacity: 1\n        }, {\n          duration: 200\n        });\n      })), t.forEach(function (f) {\n        w = n(e(r, f.dlOptions || f.options && f.options.dataLabels));\n        w.forEach(function (e, g) {\n          var m = e.enabled && !f.isNull && d(f, e),\n              l,\n              n,\n              q,\n              u,\n              p = f.dataLabels ? f.dataLabels[g] : f.dataLabel,\n              r = f.connectors ? f.connectors[g] : f.connector,\n              t = !p;\n          m && (l = f.getLabelConfig(), n = e[f.formatPrefix + \"Format\"] || e.format, l = G(n) ? c(n, l, h.time) : (e[f.formatPrefix + \"Formatter\"] || e.formatter).call(l, e), n = e.style, q = e.rotation, h.styledMode || (n.color = v(e.color, n.color, b.color, \"#000000\"), \"contrast\" === n.color && (f.contrastColor = A.getContrast(f.color || b.color), n.color = e.inside || 0 > v(e.distance, f.labelDistance) || k.stacking ? f.contrastColor : \"#000000\"), k.cursor && (n.cursor = k.cursor)), u = {\n            r: e.borderRadius || 0,\n            rotation: q,\n            padding: e.padding,\n            zIndex: 1\n          }, h.styledMode || (u.fill = e.backgroundColor, u.stroke = e.borderColor, u[\"stroke-width\"] = e.borderWidth), a.objectEach(u, function (a, b) {\n            void 0 === a && delete u[b];\n          }));\n          !p || m && G(l) ? m && G(l) && (p ? u.text = l : (f.dataLabels = f.dataLabels || [], p = f.dataLabels[g] = q ? A.text(l, 0, -9999).addClass(\"highcharts-data-label\") : A.label(l, 0, -9999, e.shape, null, null, e.useHTML, null, \"data-label\"), g || (f.dataLabel = p), p.addClass(\" highcharts-data-label-color-\" + f.colorIndex + \" \" + (e.className || \"\") + (e.useHTML ? \" highcharts-tracker\" : \"\"))), p.options = e, p.attr(u), h.styledMode || p.css(n).shadow(e.shadow), p.added || p.add(z), b.alignDataLabel(f, p, e, null, t)) : (f.dataLabel = f.dataLabel && f.dataLabel.destroy(), f.dataLabels && (1 === f.dataLabels.length ? delete f.dataLabels : delete f.dataLabels[g]), g || delete f.dataLabel, r && (f.connector = f.connector.destroy(), f.connectors && (1 === f.connectors.length ? delete f.connectors : delete f.connectors[g])));\n        });\n      });\n      a.fireEvent(this, \"afterDrawDataLabels\");\n    };\n\n    r.prototype.alignDataLabel = function (a, e, b, c, h) {\n      var d = this.chart,\n          g = this.isCartesian && d.inverted,\n          l = v(a.dlBox && a.dlBox.centerX, a.plotX, -9999),\n          m = v(a.plotY, -9999),\n          n = e.getBBox(),\n          u,\n          p = b.rotation,\n          f = b.align,\n          q = this.visible && (a.series.forceDL || d.isInsidePlot(l, Math.round(m), g) || c && d.isInsidePlot(l, g ? c.x + 1 : c.y + c.height - 1, g)),\n          r = \"justify\" === v(b.overflow, \"justify\");\n      if (q && (u = d.renderer.fontMetrics(d.styledMode ? void 0 : b.style.fontSize, e).b, c = k({\n        x: g ? this.yAxis.len - m : l,\n        y: Math.round(g ? this.xAxis.len - l : m),\n        width: 0,\n        height: 0\n      }, c), k(b, {\n        width: n.width,\n        height: n.height\n      }), p ? (r = !1, l = d.renderer.rotCorr(u, p), l = {\n        x: c.x + b.x + c.width / 2 + l.x,\n        y: c.y + b.y + {\n          top: 0,\n          middle: .5,\n          bottom: 1\n        }[b.verticalAlign] * c.height\n      }, e[h ? \"attr\" : \"animate\"](l).attr({\n        align: f\n      }), m = (p + 720) % 360, m = 180 < m && 360 > m, \"left\" === f ? l.y -= m ? n.height : 0 : \"center\" === f ? (l.x -= n.width / 2, l.y -= n.height / 2) : \"right\" === f && (l.x -= n.width, l.y -= m ? 0 : n.height), e.placed = !0, e.alignAttr = l) : (e.align(b, null, c), l = e.alignAttr), r && 0 <= c.height ? a.isLabelJustified = this.justifyDataLabel(e, b, l, n, c, h) : v(b.crop, !0) && (q = d.isInsidePlot(l.x, l.y) && d.isInsidePlot(l.x + n.width, l.y + n.height)), b.shape && !p)) e[h ? \"attr\" : \"animate\"]({\n        anchorX: g ? d.plotWidth - a.plotY : a.plotX,\n        anchorY: g ? d.plotHeight - a.plotX : a.plotY\n      });\n      q || (e.attr({\n        y: -9999\n      }), e.placed = !1);\n    };\n\n    r.prototype.justifyDataLabel = function (a, e, b, c, h, k) {\n      var d = this.chart,\n          g = e.align,\n          m = e.verticalAlign,\n          l,\n          n,\n          u = a.box ? 0 : a.padding || 0;\n      l = b.x + u;\n      0 > l && (\"right\" === g ? e.align = \"left\" : e.x = -l, n = !0);\n      l = b.x + c.width - u;\n      l > d.plotWidth && (\"left\" === g ? e.align = \"right\" : e.x = d.plotWidth - l, n = !0);\n      l = b.y + u;\n      0 > l && (\"bottom\" === m ? e.verticalAlign = \"top\" : e.y = -l, n = !0);\n      l = b.y + c.height - u;\n      l > d.plotHeight && (\"top\" === m ? e.verticalAlign = \"bottom\" : e.y = d.plotHeight - l, n = !0);\n      n && (a.placed = !k, a.align(e, null, h));\n      return n;\n    };\n\n    h.pie && (h.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function radialDistributionY(a) {\n        return a.top + a.distributeBox.pos;\n      },\n      radialDistributionX: function radialDistributionX(a, e, b, c) {\n        return a.getX(b < e.top + 2 || b > e.bottom - 2 ? c : b, e.half, e);\n      },\n      justify: function justify(a, e, b) {\n        return b[0] + (a.half ? -1 : 1) * (e + a.labelDistance);\n      },\n      alignToPlotEdges: function alignToPlotEdges(a, e, b, c) {\n        a = a.getBBox().width;\n        return e ? a + c : b - a - c;\n      },\n      alignToConnectors: function alignToConnectors(a, e, b, c) {\n        var d = 0,\n            g;\n        a.forEach(function (a) {\n          g = a.dataLabel.getBBox().width;\n          g > d && (d = g);\n        });\n        return e ? d + c : b - d - c;\n      }\n    }, h.pie.prototype.drawDataLabels = function () {\n      var d = this,\n          e = d.data,\n          b,\n          c = d.chart,\n          h = d.options.dataLabels,\n          k = h.connectorPadding,\n          l = v(h.connectorWidth, 1),\n          n = c.plotWidth,\n          m = c.plotHeight,\n          p = c.plotLeft,\n          t = Math.round(c.chartWidth / 3),\n          w,\n          f = d.center,\n          q = f[2] / 2,\n          y = f[1],\n          K,\n          I,\n          J,\n          M,\n          R = [[], []],\n          C,\n          P,\n          N,\n          S,\n          O = [0, 0, 0, 0],\n          W = d.dataLabelPositioners;\n      d.visible && (h.enabled || d._hasPointLabels) && (e.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), r.prototype.drawDataLabels.apply(d), e.forEach(function (a) {\n        a.dataLabel && (a.visible ? (R[a.half].push(a), a.dataLabel._pos = null, !G(h.style.width) && !G(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > t && (a.dataLabel.css({\n          width: .7 * t\n        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n      }), R.forEach(function (e, g) {\n        var l,\n            u,\n            r = e.length,\n            t = [],\n            x;\n        if (r) for (d.sortByAngle(e, g - .5), 0 < d.maxLabelDistance && (l = Math.max(0, y - q - d.maxLabelDistance), u = Math.min(y + q + d.maxLabelDistance, c.plotHeight), e.forEach(function (a) {\n          0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, y - q - a.labelDistance), a.bottom = Math.min(y + q + a.labelDistance, c.plotHeight), x = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n            target: a.labelPosition.natural.y - a.top + x / 2,\n            size: x,\n            rank: a.y\n          }, t.push(a.distributeBox));\n        }), l = u + x - l, a.distribute(t, l, l / 5)), S = 0; S < r; S++) {\n          b = e[S];\n          J = b.labelPosition;\n          K = b.dataLabel;\n          N = !1 === b.visible ? \"hidden\" : \"inherit\";\n          P = l = J.natural.y;\n          t && G(b.distributeBox) && (void 0 === b.distributeBox.pos ? N = \"hidden\" : (M = b.distributeBox.size, P = W.radialDistributionY(b)));\n          delete b.positionIndex;\n          if (h.justify) C = W.justify(b, q, f);else switch (h.alignTo) {\n            case \"connectors\":\n              C = W.alignToConnectors(e, g, n, p);\n              break;\n\n            case \"plotEdges\":\n              C = W.alignToPlotEdges(K, g, n, p);\n              break;\n\n            default:\n              C = W.radialDistributionX(d, b, P, l);\n          }\n          K._attr = {\n            visibility: N,\n            align: J.alignment\n          };\n          K._pos = {\n            x: C + h.x + ({\n              left: k,\n              right: -k\n            }[J.alignment] || 0),\n            y: P + h.y - 10\n          };\n          J.final.x = C;\n          J.final.y = P;\n          v(h.crop, !0) && (I = K.getBBox().width, l = null, C - I < k && 1 === g ? (l = Math.round(I - C + k), O[3] = Math.max(l, O[3])) : C + I > n - k && 0 === g && (l = Math.round(C + I - n + k), O[1] = Math.max(l, O[1])), 0 > P - M / 2 ? O[0] = Math.max(Math.round(-P + M / 2), O[0]) : P + M / 2 > m && (O[2] = Math.max(Math.round(P + M / 2 - m), O[2])), K.sideOverflow = l);\n        }\n      }), 0 === F(O) || this.verifyDataLabelOverflow(O)) && (this.placeDataLabels(), l && this.points.forEach(function (a) {\n        var b;\n        w = a.connector;\n\n        if ((K = a.dataLabel) && K._pos && a.visible && 0 < a.labelDistance) {\n          N = K._attr.visibility;\n          if (b = !w) a.connector = w = c.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + a.colorIndex + (a.className ? \" \" + a.className : \"\")).add(d.dataLabelsGroup), c.styledMode || w.attr({\n            \"stroke-width\": l,\n            stroke: h.connectorColor || a.color || \"#666666\"\n          });\n          w[b ? \"attr\" : \"animate\"]({\n            d: a.getConnectorPath()\n          });\n          w.attr(\"visibility\", N);\n        } else w && (a.connector = w.destroy());\n      }));\n    }, h.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (a) {\n        var d = a.dataLabel;\n        d && a.visible && ((a = d._pos) ? (d.sideOverflow && (d._attr.width = d.getBBox().width - d.sideOverflow, d.css({\n          width: d._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), d.shortened = !0), d.attr(d._attr), d[d.moved ? \"animate\" : \"attr\"](a), d.moved = !0) : d && d.attr({\n          y: -9999\n        }));\n      }, this);\n    }, h.pie.prototype.alignDataLabel = t, h.pie.prototype.verifyDataLabelOverflow = function (a) {\n      var d = this.center,\n          b = this.options,\n          e = b.center,\n          c = b.minSize || 80,\n          h,\n          k = null !== b.size;\n      k || (null !== e[0] ? h = Math.max(d[2] - Math.max(a[1], a[3]), c) : (h = Math.max(d[2] - a[1] - a[3], c), d[0] += (a[3] - a[1]) / 2), null !== e[1] ? h = Math.max(Math.min(h, d[2] - Math.max(a[0], a[2])), c) : (h = Math.max(Math.min(h, d[2] - a[0] - a[2]), c), d[1] += (a[0] - a[2]) / 2), h < d[2] ? (d[2] = h, d[3] = Math.min(w(b.innerSize || 0, h), h), this.translate(d), this.drawDataLabels && this.drawDataLabels()) : k = !0);\n      return k;\n    });\n    h.column && (h.column.prototype.alignDataLabel = function (a, e, b, c, h) {\n      var d = this.chart.inverted,\n          g = a.series,\n          k = a.dlBox || a.shapeArgs,\n          l = v(a.below, a.plotY > v(this.translatedThreshold, g.yAxis.len)),\n          n = v(b.inside, !!this.options.stacking);\n      k && (c = p(k), 0 > c.y && (c.height += c.y, c.y = 0), k = c.y + c.height - g.yAxis.len, 0 < k && (c.height -= k), d && (c = {\n        x: g.yAxis.len - c.y - c.height,\n        y: g.xAxis.len - c.x - c.width,\n        width: c.height,\n        height: c.width\n      }), n || (d ? (c.x += l ? 0 : c.width, c.width = 0) : (c.y += l ? c.height : 0, c.height = 0)));\n      b.align = v(b.align, !d || n ? \"center\" : l ? \"right\" : \"left\");\n      b.verticalAlign = v(b.verticalAlign, d || n ? \"middle\" : l ? \"top\" : \"bottom\");\n      r.prototype.alignDataLabel.call(this, a, e, b, c, h);\n      a.isLabelJustified && a.contrastColor && e.css({\n        color: a.contrastColor\n      });\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.Chart,\n        F = a.isArray,\n        G = a.objectEach,\n        k = a.pick,\n        c = a.addEvent,\n        p = a.fireEvent;\n    c(y, \"render\", function () {\n      var a = [];\n      (this.labelCollectors || []).forEach(function (c) {\n        a = a.concat(c());\n      });\n      (this.yAxis || []).forEach(function (c) {\n        c.options.stackLabels && !c.options.stackLabels.allowOverlap && G(c.stacks, function (c) {\n          G(c, function (c) {\n            a.push(c.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (c) {\n        var p = c.options.dataLabels;\n        c.visible && (!1 !== p.enabled || c._hasPointLabels) && c.points.forEach(function (c) {\n          c.visible && (F(c.dataLabels) ? c.dataLabels : c.dataLabel ? [c.dataLabel] : []).forEach(function (h) {\n            var e = h.options;\n            h.labelrank = k(e.labelrank, c.labelrank, c.shapeArgs && c.shapeArgs.height);\n            e.allowOverlap || a.push(h);\n          });\n        });\n      });\n      this.hideOverlappingLabels(a);\n    });\n\n    y.prototype.hideOverlappingLabels = function (a) {\n      var c = this,\n          k = a.length,\n          r = c.renderer,\n          h,\n          e,\n          l,\n          n,\n          d,\n          g,\n          b = function b(a, _b, c, d, e, g, h, k) {\n        return !(e > a + c || e + h < a || g > _b + d || g + k < _b);\n      };\n\n      l = function l(a) {\n        var b,\n            c,\n            d,\n            e = a.box ? 0 : a.padding || 0;\n        d = 0;\n        if (a && (!a.alignAttr || a.placed)) return b = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, c = a.parentGroup, a.width || (d = a.getBBox(), a.width = d.width, a.height = d.height, d = r.fontMetrics(null, a.element).h), {\n          x: b.x + (c.translateX || 0) + e,\n          y: b.y + (c.translateY || 0) + e - d,\n          width: a.width - 2 * e,\n          height: a.height - 2 * e\n        };\n      };\n\n      for (e = 0; e < k; e++) {\n        if (h = a[e]) h.oldOpacity = h.opacity, h.newOpacity = 1, h.absoluteBox = l(h);\n      }\n\n      a.sort(function (a, b) {\n        return (b.labelrank || 0) - (a.labelrank || 0);\n      });\n\n      for (e = 0; e < k; e++) {\n        for (g = (l = a[e]) && l.absoluteBox, h = e + 1; h < k; ++h) {\n          if (d = (n = a[h]) && n.absoluteBox, g && d && l !== n && 0 !== l.newOpacity && 0 !== n.newOpacity && (d = b(g.x, g.y, g.width, g.height, d.x, d.y, d.width, d.height))) (l.labelrank < n.labelrank ? l : n).newOpacity = 0;\n        }\n      }\n\n      a.forEach(function (a) {\n        var b, d;\n        a && (d = a.newOpacity, a.oldOpacity !== d && (a.alignAttr && a.placed ? (d ? a.show(!0) : b = function b() {\n          a.hide();\n        }, a.alignAttr.opacity = d, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, b), p(c, \"afterHideOverlappingLabels\")) : a.attr({\n          opacity: d\n        })), a.isOld = !0);\n      });\n    };\n  })(I);\n\n  (function (a) {\n    var y = a.addEvent,\n        F = a.Chart,\n        G = a.createElement,\n        k = a.css,\n        c = a.defaultOptions,\n        p = a.defaultPlotOptions,\n        t = a.extend,\n        v = a.fireEvent,\n        w = a.hasTouch,\n        r = a.isObject,\n        h = a.Legend,\n        e = a.merge,\n        l = a.pick,\n        n = a.Point,\n        d = a.Series,\n        g = a.seriesTypes,\n        b = a.svg,\n        x;\n    x = a.TrackerMixin = {\n      drawTrackerPoint: function drawTrackerPoint() {\n        var a = this,\n            b = a.chart,\n            c = b.pointer,\n            d = function d(a) {\n          var b = c.getPointFromEvent(a);\n          void 0 !== b && (c.isDirectTouch = !0, b.onMouseOver(a));\n        };\n\n        a.points.forEach(function (a) {\n          a.graphic && (a.graphic.element.point = a);\n          a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a);\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (e) {\n          if (a[e]) {\n            a[e].addClass(\"highcharts-tracker\").on(\"mouseover\", d).on(\"mouseout\", function (a) {\n              c.onTrackerMouseOut(a);\n            });\n            if (w) a[e].on(\"touchstart\", d);\n            !b.styledMode && a.options.cursor && a[e].css(k).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        v(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function drawTrackerGraph() {\n        var a = this,\n            c = a.options,\n            d = c.trackByArea,\n            e = [].concat(d ? a.areaPath : a.graphPath),\n            g = e.length,\n            h = a.chart,\n            k = h.pointer,\n            l = h.renderer,\n            f = h.options.tooltip.snap,\n            n = a.tracker,\n            p,\n            r = function r() {\n          if (h.hoverSeries !== a) a.onMouseOver();\n        },\n            t = \"rgba(192,192,192,\" + (b ? .0001 : .002) + \")\";\n\n        if (g && !d) for (p = g + 1; p--;) {\n          \"M\" === e[p] && e.splice(p + 1, 0, e[p + 1] - f, e[p + 2], \"L\"), (p && \"M\" === e[p] || p === g) && e.splice(p, 0, \"L\", e[p - 2] + f, e[p - 1]);\n        }\n        n ? n.attr({\n          d: e\n        }) : a.graph && (a.tracker = l.path(e).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(d ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), h.styledMode || a.tracker.attr({\n          \"stroke-linejoin\": \"round\",\n          stroke: t,\n          fill: d ? t : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (d ? 0 : 2 * f)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", r).on(\"mouseout\", function (a) {\n            k.onTrackerMouseOut(a);\n          });\n          c.cursor && !h.styledMode && a.css({\n            cursor: c.cursor\n          });\n          if (w) a.on(\"touchstart\", r);\n        }));\n        v(this, \"afterDrawTracker\");\n      }\n    };\n    g.column && (g.column.prototype.drawTracker = x.drawTrackerPoint);\n    g.pie && (g.pie.prototype.drawTracker = x.drawTrackerPoint);\n    g.scatter && (g.scatter.prototype.drawTracker = x.drawTrackerPoint);\n    t(h.prototype, {\n      setItemEvents: function setItemEvents(a, b, c) {\n        var d = this,\n            g = d.chart.renderer.boxWrapper,\n            h = \"highcharts-legend-\" + (a instanceof n ? \"point\" : \"series\") + \"-active\",\n            k = d.chart.styledMode;\n        (c ? b : a.legendGroup).on(\"mouseover\", function () {\n          a.setState(\"hover\");\n          g.addClass(h);\n          k || b.css(d.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          d.styledMode || b.css(e(a.visible ? d.itemStyle : d.itemHiddenStyle));\n          g.removeClass(h);\n          a.setState();\n        }).on(\"click\", function (b) {\n          var c = function c() {\n            a.setVisible && a.setVisible();\n          };\n\n          g.removeClass(h);\n          b = {\n            browserEvent: b\n          };\n          a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, c) : v(a, \"legendItemClick\", b, c);\n        });\n      },\n      createCheckboxForItem: function createCheckboxForItem(a) {\n        a.checkbox = G(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        y(a.checkbox, \"click\", function (b) {\n          v(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    t(F.prototype, {\n      showResetZoom: function showResetZoom() {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            d = c.lang,\n            e = b.options.chart.resetZoomButton,\n            g = e.theme,\n            h = g.states,\n            k = \"chart\" === e.relativeTo ? null : \"plotBox\";\n        v(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(d.resetZoom, null, null, a, g, h && h.hover).attr({\n            align: e.position.align,\n            title: d.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(e.position, !1, k);\n        });\n      },\n      zoomOut: function zoomOut() {\n        v(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function zoom(a) {\n        var b,\n            c = this.pointer,\n            d = !1,\n            e;\n        !a || a.resetSelection ? (this.axes.forEach(function (a) {\n          b = a.zoom();\n        }), c.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var e = a.axis;\n          c[e.isXAxis ? \"zoomX\" : \"zoomY\"] && (b = e.zoom(a.min, a.max), e.displayBtn && (d = !0));\n        });\n        e = this.resetZoomButton;\n        d && !e ? this.showResetZoom() : !d && r(e) && (this.resetZoomButton = e.destroy());\n        b && this.redraw(l(this.options.chart.animation, a && a.animation, 100 > this.pointCount));\n      },\n      pan: function pan(a, b) {\n        var c = this,\n            d = c.hoverPoints,\n            e;\n        v(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          d && d.forEach(function (a) {\n            a.setState();\n          });\n          (\"xy\" === b ? [1, 0] : [1]).forEach(function (b) {\n            b = c[b ? \"xAxis\" : \"yAxis\"][0];\n            var d = b.horiz,\n                g = a[d ? \"chartX\" : \"chartY\"],\n                d = d ? \"mouseDownX\" : \"mouseDownY\",\n                f = c[d],\n                h = (b.pointRange || 0) / 2,\n                k = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1,\n                l = b.getExtremes(),\n                m = b.toValue(f - g, !0) + h * k,\n                k = b.toValue(f + b.len - g, !0) - h * k,\n                n = k < m,\n                f = n ? k : m,\n                m = n ? m : k,\n                k = Math.min(l.dataMin, h ? l.min : b.toValue(b.toPixels(l.min) - b.minPixelPadding)),\n                h = Math.max(l.dataMax, h ? l.max : b.toValue(b.toPixels(l.max) + b.minPixelPadding)),\n                n = k - f;\n            0 < n && (m += n, f = k);\n            n = m - h;\n            0 < n && (m = h, f -= n);\n            b.series.length && f !== l.min && m !== l.max && (b.setExtremes(f, m, !1, !1, {\n              trigger: \"pan\"\n            }), e = !0);\n            c[d] = g;\n          });\n          e && c.redraw(!1);\n          k(c.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    });\n    t(n.prototype, {\n      select: function select(a, b) {\n        var c = this,\n            d = c.series,\n            e = d.chart;\n        a = l(a, !c.selected);\n        c.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          c.selected = c.options.selected = a;\n          d.options.data[d.data.indexOf(c)] = c.options;\n          c.setState(a && \"select\");\n          b || e.getSelectedPoints().forEach(function (a) {\n            a.selected && a !== c && (a.selected = a.options.selected = !1, d.options.data[d.data.indexOf(a)] = a.options, a.setState(\"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n      },\n      onMouseOver: function onMouseOver(a) {\n        var b = this.series.chart,\n            c = b.pointer;\n        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);\n        c.runPointActions(a, this);\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function importEvents() {\n        if (!this.hasImportedEvents) {\n          var b = this,\n              c = e(b.series.options.point, b.options).events;\n          b.events = c;\n          a.objectEach(c, function (a, c) {\n            y(b, c, a);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function setState(a, b) {\n        var c = Math.floor(this.plotX),\n            d = this.plotY,\n            e = this.series,\n            g = e.options.states[a || \"normal\"] || {},\n            h = p[e.type].marker && e.options.marker,\n            k = h && !1 === h.enabled,\n            f = h && h.states && h.states[a || \"normal\"] || {},\n            n = !1 === f.enabled,\n            r = e.stateMarkerGraphic,\n            u = this.marker || {},\n            w = e.chart,\n            x = e.halo,\n            y,\n            F = h && e.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !b || this.selected && \"select\" !== a || !1 === g.enabled || a && (n || k && !1 === f.enabled) || a && u.states && u.states[a] && !1 === u.states[a].enabled)) {\n          F && (y = e.markerAttribs(this, a));\n          if (this.graphic) this.state && this.graphic.removeClass(\"highcharts-point-\" + this.state), a && this.graphic.addClass(\"highcharts-point-\" + a), w.styledMode || this.graphic.animate(e.pointAttribs(this, a), l(w.options.chart.animation, g.animation)), y && this.graphic.animate(y, l(w.options.chart.animation, f.animation, h.animation)), r && r.hide();else {\n            if (a && f) {\n              h = u.symbol || e.symbol;\n              r && r.currentSymbol !== h && (r = r.destroy());\n              if (r) r[b ? \"animate\" : \"attr\"]({\n                x: y.x,\n                y: y.y\n              });else h && (e.stateMarkerGraphic = r = w.renderer.symbol(h, y.x, y.y, y.width, y.height).add(e.markerGroup), r.currentSymbol = h);\n              !w.styledMode && r && r.attr(e.pointAttribs(this, a));\n            }\n\n            r && (r[a && w.isInsidePlot(c, d, w.inverted) ? \"show\" : \"hide\"](), r.element.point = this);\n          }\n          (c = g.halo) && c.size ? (x || (e.halo = x = w.renderer.path().add((this.graphic || r).parentGroup)), x.show()[b ? \"animate\" : \"attr\"]({\n            d: this.haloPath(c.size)\n          }), x.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + l(this.colorIndex, e.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            zIndex: -1\n          }), x.point = this, w.styledMode || x.attr(t({\n            fill: this.color || e.color,\n            \"fill-opacity\": c.opacity\n          }, c.attributes))) : x && x.point && x.point.haloPath && x.animate({\n            d: x.point.haloPath(0)\n          }, null, x.hide);\n          this.state = a;\n          v(this, \"afterSetState\");\n        }\n      },\n      haloPath: function haloPath(a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    t(d.prototype, {\n      onMouseOver: function onMouseOver() {\n        var a = this.chart,\n            b = a.hoverSeries;\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && v(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.options,\n            b = this.chart,\n            c = b.tooltip,\n            d = b.hoverPoint;\n        b.hoverSeries = null;\n        if (d) d.onMouseOut();\n        this && a.events.mouseOut && v(this, \"mouseOut\");\n        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n        this.setState();\n      },\n      setState: function setState(a) {\n        var b = this,\n            c = b.options,\n            d = b.graph,\n            e = c.states,\n            g = c.lineWidth,\n            c = 0;\n        a = a || \"\";\n        if (b.state !== a && ([b.group, b.markerGroup, b.dataLabelsGroup].forEach(function (c) {\n          c && (b.state && c.removeClass(\"highcharts-series-\" + b.state), a && c.addClass(\"highcharts-series-\" + a));\n        }), b.state = a, !(b.chart.styledMode || e[a] && !1 === e[a].enabled) && (a && (g = e[a].lineWidth || g + (e[a].lineWidthPlus || 0)), d && !d.dashstyle))) for (g = {\n          \"stroke-width\": g\n        }, d.animate(g, l(e[a || \"normal\"] && e[a || \"normal\"].animation, b.chart.options.chart.animation)); b[\"zone-graph-\" + c];) {\n          b[\"zone-graph-\" + c].attr(g), c += 1;\n        }\n      },\n      setVisible: function setVisible(a, b) {\n        var c = this,\n            d = c.chart,\n            e = c.legendItem,\n            g,\n            h = d.options.chart.ignoreHiddenSeries,\n            k = c.visible;\n        g = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !k : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (c[a]) c[a][g]();\n        });\n        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();\n        e && d.legend.colorizeItem(c, a);\n        c.isDirty = !0;\n        c.options.stacking && d.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        c.linkedSeries.forEach(function (b) {\n          b.setVisible(a, !1);\n        });\n        h && (d.isDirtyBox = !0);\n        v(c, g);\n        !1 !== b && d.redraw();\n      },\n      show: function show() {\n        this.setVisible(!0);\n      },\n      hide: function hide() {\n        this.setVisible(!1);\n      },\n      select: function select(a) {\n        this.selected = a = this.options.selected = void 0 === a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        v(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: x.drawTrackerGraph\n    });\n  })(I);\n\n  (function (a) {\n    var y = a.Chart,\n        F = a.isArray,\n        G = a.isObject,\n        k = a.pick,\n        c = a.splat;\n\n    y.prototype.setResponsive = function (c, k) {\n      var p = this.options.responsive,\n          t = [],\n          r = this.currentResponsive;\n      !k && p && p.rules && p.rules.forEach(function (h) {\n        void 0 === h._id && (h._id = a.uniqueKey());\n        this.matchResponsiveRule(h, t, c);\n      }, this);\n      k = a.merge.apply(0, t.map(function (c) {\n        return a.find(p.rules, function (a) {\n          return a._id === c;\n        }).chartOptions;\n      }));\n      k.isResponsiveOptions = !0;\n      t = t.toString() || void 0;\n      t !== (r && r.ruleIds) && (r && this.update(r.undoOptions, c), t ? (r = this.currentOptions(k), r.isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: t,\n        mergedOptions: k,\n        undoOptions: r\n      }, this.update(k, c)) : this.currentResponsive = void 0);\n    };\n\n    y.prototype.matchResponsiveRule = function (a, c) {\n      var p = a.condition;\n      (p.callback || function () {\n        return this.chartWidth <= k(p.maxWidth, Number.MAX_VALUE) && this.chartHeight <= k(p.maxHeight, Number.MAX_VALUE) && this.chartWidth >= k(p.minWidth, 0) && this.chartHeight >= k(p.minHeight, 0);\n      }).call(this) && c.push(a._id);\n    };\n\n    y.prototype.currentOptions = function (k) {\n      function p(k, r, h, e) {\n        var l;\n        a.objectEach(k, function (a, d) {\n          if (!e && -1 < [\"series\", \"xAxis\", \"yAxis\"].indexOf(d)) for (a = c(a), h[d] = [], l = 0; l < a.length; l++) {\n            r[d][l] && (h[d][l] = {}, p(a[l], r[d][l], h[d][l], e + 1));\n          } else G(a) ? (h[d] = F(a) ? [] : {}, p(a, r[d] || {}, h[d], e + 1)) : h[d] = r[d] || null;\n        });\n      }\n\n      var v = {};\n      p(k, this.options, v, 0);\n      return v;\n    };\n  })(I);\n\n  return I;\n});","map":null,"metadata":{},"sourceType":"script"}